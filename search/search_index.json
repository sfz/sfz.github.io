{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to SFZFormat.com! This is the main reference point for anyone who wants to create virtual musical instruments using the SFZ format. The SFZ format is a file format to define how a collection of samples are arranged for performance. The goal behind the SFZ format is to provide a free, simple, minimalistic and expandable format to arrange, distribute and use audio samples with the highest possible quality and the highest possible performance flexibility. Soundware, software and hardware developers can create, use and distribute the SFZ format files for free, for either free or commercial applications. What SFZ is not To clarify, the term SFZ as used on this site does not mean a sforzando dynamic marking, and it also is not the same thing as a soundfont. Soundfonts are a completely different file format which includes both the samples and the definitions of sample behavior in the same binary file, while SFZ is a file format which only defines the behavior of musical instruments and does not include the sample content. SF2 may look a bit like SFZ visually, but that's a coincidence. Features A .sfz definition file is just a text file. Consequently, it can be created by using any text editor. Samples of any bit depth (8/16/24/32-bit) and sample rate (44.1 kHz, 48 kHz, 384 kHz etc.), mono or stereo. Compressed and uncompressed sample formats can both be used within the same instrument. Loops embedded in sample files or configured in the SFZ. Velocity layers, round robins, keyboard splits and layers. Sample playback based on MIDI controllers (note on, note off, continuous controllers, pitch bend, channel - and polyphonic aftertouch, keyboard switches) and internal generators (random, sequence counters). Unidirectional and bidirectional exclusive regions (mute groups). Release trigger regions with release trigger attenuation control. Crossfade layer controls. Ability to distinguish legato notes from first notes. Envelope and LFO modulation sources with possible targets including volume, pitch, filter cutoff and more. Requirements To make use of the SFZ format requires three things: Samples SFZ player SFZ file which tells the player how to use the samples. The SFZ file itself can be created using any text editor, though for more complex cases with hundreds or thousands of samples, additional tools can make this easier - some people use spreadsheets, and there are also dedicated SFZ creation tools . Here's a basic SFZ file you can copy to start your own. Making Instruments Text guides on how to make a simple instrument, covering the essential opcodes Drum basics - covers global , group and region headers, sample , key , lovel / hivel , amp_velcurve_N , seq_length , seq_position and lorand / hirand . Sustained note basics - using a flute as an example. Adds lokey / hikey , pitch_keycenter , xfin / xfout , locc / hicc , keyswitching , group , off_by and off_mode . Some more advanced topics Vibrato - typical string vibrato, humanized vibrato, asymmetrical vibrato, and even filter wobble. Legato - simulated legato and portamento as well as true sampled legato. Cymbal muting - using group , off_by , off_mode and polyphony to make hi-hat and cymbal notes mute previous notes in a musically useful way. Brush stirs - two different approaches to brushed drum techniques which produce a continuous sound rather than a hit.","title":"Home"},{"location":"#welcome-to-sfzformatcom","text":"This is the main reference point for anyone who wants to create virtual musical instruments using the SFZ format. The SFZ format is a file format to define how a collection of samples are arranged for performance. The goal behind the SFZ format is to provide a free, simple, minimalistic and expandable format to arrange, distribute and use audio samples with the highest possible quality and the highest possible performance flexibility. Soundware, software and hardware developers can create, use and distribute the SFZ format files for free, for either free or commercial applications.","title":"Welcome to SFZFormat.com!"},{"location":"#what-sfz-is-not","text":"To clarify, the term SFZ as used on this site does not mean a sforzando dynamic marking, and it also is not the same thing as a soundfont. Soundfonts are a completely different file format which includes both the samples and the definitions of sample behavior in the same binary file, while SFZ is a file format which only defines the behavior of musical instruments and does not include the sample content. SF2 may look a bit like SFZ visually, but that's a coincidence.","title":"What SFZ is not"},{"location":"#features","text":"A .sfz definition file is just a text file. Consequently, it can be created by using any text editor. Samples of any bit depth (8/16/24/32-bit) and sample rate (44.1 kHz, 48 kHz, 384 kHz etc.), mono or stereo. Compressed and uncompressed sample formats can both be used within the same instrument. Loops embedded in sample files or configured in the SFZ. Velocity layers, round robins, keyboard splits and layers. Sample playback based on MIDI controllers (note on, note off, continuous controllers, pitch bend, channel - and polyphonic aftertouch, keyboard switches) and internal generators (random, sequence counters). Unidirectional and bidirectional exclusive regions (mute groups). Release trigger regions with release trigger attenuation control. Crossfade layer controls. Ability to distinguish legato notes from first notes. Envelope and LFO modulation sources with possible targets including volume, pitch, filter cutoff and more.","title":"Features"},{"location":"#requirements","text":"To make use of the SFZ format requires three things: Samples SFZ player SFZ file which tells the player how to use the samples. The SFZ file itself can be created using any text editor, though for more complex cases with hundreds or thousands of samples, additional tools can make this easier - some people use spreadsheets, and there are also dedicated SFZ creation tools . Here's a basic SFZ file you can copy to start your own.","title":"Requirements"},{"location":"#making-instruments","text":"Text guides on how to make a simple instrument, covering the essential opcodes Drum basics - covers global , group and region headers, sample , key , lovel / hivel , amp_velcurve_N , seq_length , seq_position and lorand / hirand . Sustained note basics - using a flute as an example. Adds lokey / hikey , pitch_keycenter , xfin / xfout , locc / hicc , keyswitching , group , off_by and off_mode . Some more advanced topics Vibrato - typical string vibrato, humanized vibrato, asymmetrical vibrato, and even filter wobble. Legato - simulated legato and portamento as well as true sampled legato. Cymbal muting - using group , off_by , off_mode and polyphony to make hi-hat and cymbal notes mute previous notes in a musically useful way. Brush stirs - two different approaches to brushed drum techniques which produce a continuous sound rather than a hit.","title":"Making Instruments"},{"location":"versions/","text":"SFZ v1 The first version of the format was originally published on the rgc:audio website , which is the most supported by sfz related software. SFZ v2 The SFZ v2 standard has never been clearly set down anywhere. For the purpose of this website, anything included in the Simon Cann's Cakewalk Synthesizers is considered SFZ v2, regardless of which SFZ players it might or might not be actually implemented in. If something works in ARIA but not in any Cakewalk products, that's considered an ARIA extension. Cakewalk Synthesizers is not a recent book, and was not intended to be a standards document, but rather a manual for users of Cakewalk products. So, if you are developing a new SFZ player, do not feel obligated to support all opcodes , headers etc. listed on this website - instead, use your judgment. Extensions ARIA ARIA also adds some extended MIDI CCs in addition to those already added by SFZ 2, and XML instrument banks as a way of organizing multiple SFZ instruments and configuring graphical user interfaces. See also the Plogue forum's ARIA's Custom opcodes post.","title":"Versions"},{"location":"versions/#sfz-v1","text":"The first version of the format was originally published on the rgc:audio website , which is the most supported by sfz related software.","title":"SFZ v1"},{"location":"versions/#sfz-v2","text":"The SFZ v2 standard has never been clearly set down anywhere. For the purpose of this website, anything included in the Simon Cann's Cakewalk Synthesizers is considered SFZ v2, regardless of which SFZ players it might or might not be actually implemented in. If something works in ARIA but not in any Cakewalk products, that's considered an ARIA extension. Cakewalk Synthesizers is not a recent book, and was not intended to be a standards document, but rather a manual for users of Cakewalk products. So, if you are developing a new SFZ player, do not feel obligated to support all opcodes , headers etc. listed on this website - instead, use your judgment.","title":"SFZ v2"},{"location":"versions/#extensions","text":"","title":"Extensions"},{"location":"versions/#aria","text":"ARIA also adds some extended MIDI CCs in addition to those already added by SFZ 2, and XML instrument banks as a way of organizing multiple SFZ instruments and configuring graphical user interfaces. See also the Plogue forum's ARIA's Custom opcodes post.","title":"ARIA"},{"location":"extensions/midi_ccs/","text":"In the MIDI specification, MIDI Control Change Messages can have numbers from 0 to 127. SFZ 2 and ARIA add some special CCs numbered 128 and above. The additions in SFZ 2 are: pitch bend: 128 channel aftertouch: 129 polyphonic aftertouch: 130 note on velocity: 131 note off velocity: 132 keyboard note number: 133 keyboard note gate: 134 unipolar random: 135 bipolar random: 136 alternate: 137 Values such as note on velocity and MIDI note number, when used as CCs, do not behave exactly the same as note number or velocity of the note itself, in some contexts. This is because once a note is played, its MIDI note number and note on velocity remain the same for that note. MIDI CC, however, is shared across the entire instrument, and this means another note on or note off event will change CC 131, 132 and 133. This can give unexpected results when using these CCs to adjust keytracking or velocity tracking of various parameters, especially in polyphonic instruments with long-sustaining sounds. Note gate is an on/off - it's 0 when no MIDI notes are pressed, and 1 when at least one note is currently pressed. Unipolar random is from 0 to 1. Bipolar random is from -1 to 1. Alternate changes between 0 and 1 every time a note on message is received. Some of the parameters, such as aftertouch and note off velocity, are rarely supported by modern MIDI hardware controllers, though they are part of the MIDI specification and can be edited in DAWs. Many MIDI keyboards will send a default note off velocity, such as 64, with every note off event regardless of how fast the key was actually moving at the time. Anything above 137 is not specified in the SFZ 2 standard and strictly engine-dependent. ARIA adds more. Some of these might not work properly in all DAWs. keydelta: 140 keydelta absolute: 141 host tempo (bpm): 142 host transport status (0 is off, 1 on in non-loop mode, 2 is playing in loop mode): 143 host sample rate: 144 time since the engine has been up: 145 current time signature numerator: 146 current time signature denominator: 147 position since song start in PPQ (pulses per quarter note): 148 position since bar start in PPQ: 149 time since the instrument has been up: 150 time since last key on (in seconds): 151 time since last key off (in seconds): 152 number of keys currently down: 153 number of currently active voices: 154 last playahead (offset) of any sample in the instrument: 155 Practical Considerations While all the \"regular\" CCs have the same range of 0 to 127, and some of these extended CCs behave the same way (for example CC 131 or note on velocity), others do not. CC136 or bipolar random can have a negative value, for example. Many will often have non-integer values. These CCs will not always behave the same as others and have not been thoroughly documented. Some of the additional CCs are shared across all instances of the ARIA engine currently running, for example the host tempo. Others can have concurrently have a different value for different instances or different instruments concurrently, for example keydelta. CC 140 and 141 are measured in half-steps. So, the below will result in an envelope with a depth of 100 cents per half-step. This is typically what would be used for portamento glides. eg07_pitch_oncc140=100 Using locc and hicc with CC 140 and 141 does not work the same as for other CCs. However, they can be used with lohdcc and hihdcc. For example, the below will restrict a region to play only when the interval between the current note and the previous one is an octave, ascending. Whether the decimal is necessary needs to be tested, but the below is confirmed to work. lohdcc140=12 hihdcc140=12.1 Using lohdcc alone does not work and will result in the region not triggering, but adding hihdcc with a high value will. The below example was tested in an instrument with a range of less than two octaves, and there works as a way to trigger some regions only when the interval is more than one octave in either direction. lohdcc141=12.1 hihdcc141=24 CC 151 is reset as soon as a new note is hit, so it cannot be used to measure the time between the previous note and the current one, for adaptive legato speed purposes. It can, however, be used to control the triggering of release samples. Like CC140 and CC141, it also requires using hdcc to function properly - which makes sense, as time since note-on as measured in seconds usually involves fractions of a second in real scenarios. In Cakewalk Dimension Pro, 140 is bitred and 141 is decim.","title":"Extended MIDI CCs"},{"location":"extensions/midi_ccs/#practical-considerations","text":"While all the \"regular\" CCs have the same range of 0 to 127, and some of these extended CCs behave the same way (for example CC 131 or note on velocity), others do not. CC136 or bipolar random can have a negative value, for example. Many will often have non-integer values. These CCs will not always behave the same as others and have not been thoroughly documented. Some of the additional CCs are shared across all instances of the ARIA engine currently running, for example the host tempo. Others can have concurrently have a different value for different instances or different instruments concurrently, for example keydelta. CC 140 and 141 are measured in half-steps. So, the below will result in an envelope with a depth of 100 cents per half-step. This is typically what would be used for portamento glides. eg07_pitch_oncc140=100 Using locc and hicc with CC 140 and 141 does not work the same as for other CCs. However, they can be used with lohdcc and hihdcc. For example, the below will restrict a region to play only when the interval between the current note and the previous one is an octave, ascending. Whether the decimal is necessary needs to be tested, but the below is confirmed to work. lohdcc140=12 hihdcc140=12.1 Using lohdcc alone does not work and will result in the region not triggering, but adding hihdcc with a high value will. The below example was tested in an instrument with a range of less than two octaves, and there works as a way to trigger some regions only when the interval is more than one octave in either direction. lohdcc141=12.1 hihdcc141=24 CC 151 is reset as soon as a new note is hit, so it cannot be used to measure the time between the previous note and the current one, for adaptive legato speed purposes. It can, however, be used to control the triggering of release samples. Like CC140 and CC141, it also requires using hdcc to function properly - which makes sense, as time since note-on as measured in seconds usually involves fractions of a second in real scenarios. In Cakewalk Dimension Pro, 140 is bitred and 141 is decim.","title":"Practical Considerations"},{"location":"extensions/aria/xml_instrument_bank/","text":"An ARIA-specific element, an XML bank is a collection of several SFZ instruments in one instrument bank. Though technically not part of the SFZ format, it is relevant to instrument creation for ARIA. The #define directive can also be used at the bank level, but otherwise there is no SFZ there. XML banks for ARIA must be digitally signed by Plogue - contact them if interested in creating instruments with banks and graphical user interfaces.","title":"XML instrument bank"},{"location":"headers/","text":"SFZ files are subdivided into sections by headers. The region header is the most essential, and is the basic unit from which instruments are constructed. A group is an optional organizational level containing one or more regions. The global header (one per file) contains opcodes which apply to all regions in the file. The master header is an extra level added inbetween group and global for the ARIA player. So, the global/group/region or global/master/group/region hierarchy contains the opcodes which define which samples are played, when they are to be played, and how. The control header would be found at the beginning of the file and includes special opcodes for setting up MIDI CC controls. The curve headers, when used, are normally found at the end of the file, and define the curves used for shaping envelopes, parameter response etc. Header Version < region > SFZ v1 < group > SFZ v1 < control > SFZ v2 < global > SFZ v2 < curve > SFZ v2 < effect > SFZ v2 < master > ARIA < midi > ARIA < sample > SFZ v2","title":"Headers"},{"location":"headers/control/","text":"SFZ 2 header which should come before \u2039global\u203a in the file, and can contain the following special directives, which should not be used under other headers: #define default_path note_offset octave_offset label_ccN set_ccN Multiple \u2039control\u203a headers can be used in one file, and this can be very useful when specifying default_path. This path will then be used for all regions until another \u2039control\u203a header is encountered. Whether settings other than default_path should also be reset by a new control header is not entirely clear. As implemented in ARIA, a new control header resets default_path only and not other control settings, and this does not seem unreasonable. See also ARIA Extensions .","title":"\u2039control\u203a"},{"location":"headers/curve/","text":"One curve header is used to define each curve. The values for various points along the curve can then be set, from v000 to v127 . The default is v000=0 and v127=1 . Any points along the curve not defined explicitly will be interpolated linearly between points which are defined. There are default built-in curves in ARIA. If no curve is specified for a modulation, curve 0 is used. The built-in ARIA curves are: Default curve (number 0). linear, from 0 to 1 1. bipolar, from -1 to 1 (useful for things such as tuning and panning, used by CC10 panning by default) 2. linear inverted, from 1 to 0 3. bipolar inverted, from 1 to -1 4. concave (used for CC7 volume tracking and amp_veltrack) 5. Xfin power curve 6. Xfout power curve These can be overwritten, but as they are used by the engine for their normal functions, it's safer to use curve_index numbers of 7 and above for custom curves. Curve_index in ARIA can be any integer from 0 to 255. Examples <curve>curve_index=17 v000=0 v095=1 v127=1 <curve>curve_index=18 v000=0 v095=0.5 v127=1 Here's a scenario using one MIDI CC to control the amplitude of two samples along two different curves. <region> amplitude_oncc110=100 amplitude_curvecc110=9 sample=bigger.wav <region> amplitude_oncc110=100 amplitude_curvecc110=10 sample=smaller.wav //The curves for the room ambiences - bigger room first <curve>curve_index=9 v000=0 v063=0 v127=1 <curve>curve_index=10 v000=0 v063=1 v127=0.1 And how to use the default curve 1 to create a tuning control which goes down and up, with the pitch unmodulated when the control is in the middle. pitch_oncc27=100 pitch_curvecc27=1","title":"\u2039curve\u203a"},{"location":"headers/curve/#examples","text":"<curve>curve_index=17 v000=0 v095=1 v127=1 <curve>curve_index=18 v000=0 v095=0.5 v127=1 Here's a scenario using one MIDI CC to control the amplitude of two samples along two different curves. <region> amplitude_oncc110=100 amplitude_curvecc110=9 sample=bigger.wav <region> amplitude_oncc110=100 amplitude_curvecc110=10 sample=smaller.wav //The curves for the room ambiences - bigger room first <curve>curve_index=9 v000=0 v063=0 v127=1 <curve>curve_index=10 v000=0 v063=1 v127=0.1 And how to use the default curve 1 to create a tuning control which goes down and up, with the pitch unmodulated when the control is in the middle. pitch_oncc27=100 pitch_curvecc27=1","title":"Examples"},{"location":"headers/effect/","text":"In SFZ v1 only effect1 and effect2 opcodes was available and only at \u2039region\u203a level. From SFZ v2 this header was added together with the addition of effect3 and effect4 opcodes also to modulate the related bus. Other opcodes listed in the book are bus , type and dsp_order . The specifics of what can be used under this header differ widely between SFZ players. The information on available effects and how to control them in ARIA and Cakewalk products can be found on the type page.","title":"\u2039effect\u203a"},{"location":"headers/global/","text":"If the same opcode defined in global is also defined in group or region, the group or region setting is used. This means global can be used to set values which are common for most regions in the SFZ file, but if a few regions need something different, they can override the global setting at a lower level. Here is a typical example with two opcodes set at the global header level, some at the group level, and others at the region level. The seq_length (number of round robins) is set to 4 in global, but as the fourth dynamic layer only contains three samples, seq_length is set to for that layer at the group header level. It is possible to have multiple global headers in one file, at least under ARIA. As with any other header, anything specified under a global header is active until another global header is encountered in the SFZ file. <global>loop_mode=one_shot seq_length=4 <group>key=36 hivel=31 amp_velcurve_31=1 <region>seq_position=1 sample=kick_vl1_rr1.wav <region>seq_position=2 sample=kick_vl1_rr2.wav <region>seq_position=3 sample=kick_vl1_rr3.wav <region>seq_position=4 sample=kick_vl1_rr4.wav <group>key=36 lovel=32 hivel=63 amp_velcurve_63=1 <region>seq_position=1 sample=kick_vl2_rr1.wav <region>seq_position=2 sample=kick_vl2_rr2.wav <region>seq_position=3 sample=kick_vl2_rr3.wav <region>seq_position=4 sample=kick_vl2_rr4.wav <group>key=36 lovel=64 hivel=95 amp_velcurve_95=1 <region>seq_position=1 sample=kick_vl3_rr1.wav <region>seq_position=2 sample=kick_vl3_rr2.wav <region>seq_position=3 sample=kick_vl3_rr3.wav <region>seq_position=4 sample=kick_vl3_rr4.wav <group>key=36 lovel=96 seq_length=3 <region>seq_position=1 sample=kick_vl4_rr1.wav <region>seq_position=2 sample=kick_vl4_rr2.wav <region>seq_position=3 sample=kick_vl4_rr3.wav","title":"\u2039global\u203a"},{"location":"headers/group/","text":"The group header is different than the group opcode, and it's important to avoid confusing the two. ARIA adds the polyphony_group opcode as an alias for group, to reduce this confusion. Groups allow entering common parameters for multiple regions. A group is defined with the \u2039group\u203a opcode, and the parameters enumerated on it last till the next group opcode, or till the end of the file. <group> ampeg_attack=0.04 ampeg_release=0.45 <region> sample=trumpet_pp_c4.wav key=c4 <region> sample=trumpet_pp_c#4.wav key=c#4 <region> sample=trumpet_pp_d4.wav key=d4 <region> sample=trumpet_pp_d#4.wav key=d#4 <group> ampeg_attack=0.03 ampeg_release=0.42 <region> sample=trumpet_pp_e4.wav key=e4 <region> sample=trumpet_pp_f4.wav key=f4 If the same opcode is defined at both the group and region levels, the region setting overrides the group setting and is used. If an opcode is defined under the global level and group level but not region, the group setting overrides the global setting. For example: <group> ampeg_attack=0.04 ampeg_release=0.45 <region> sample=trumpet_pp_c4.wav key=c4 <region> ampeg_attack=0.05 sample=trumpet_pp_c#4.wav key=c#4 <region> sample=trumpet_pp_d4.wav key=d4 <region> sample=trumpet_pp_d#4.wav key=d#4 With the above code, C#4 would use an attack time of 0.05 seconds, while C4, D4 and D#4 would use the 0.04 seconds set at the group level.","title":"\u2039group\u203a"},{"location":"headers/master/","text":"Example <global> loop_mode=one_shot ampeg_attack=0.001 ampeg_decay=0.7 ampeg_sustain=100 <master> amplitude_cc30=100 offset_cc33=3000 ampeg_sustain_oncc33=-100 <group> key=36 <region> sample=../Samples/bobobo/bobobo_bass_vl1_rr1.wav hirand=0.250 <region> sample=../Samples/bobobo/bobobo_bass_vl1_rr2.wav lorand=0.250 hirand=0.500 <region> sample=../Samples/bobobo/bobobo_bass_vl1_rr3.wav lorand=0.500 hirand=0.750 <region> sample=../Samples/bobobo/bobobo_bass_vl1_rr4.wav lorand=0.750 <master> amplitude_cc35=100 offset_cc38=1500 ampeg_sustain_oncc38=-100 <group>key=38 <region> sample=../Samples/bobobo/bobobo_tenor_l_vl1_rr1.wav hirand=0.250 <region> sample=../Samples/bobobo/bobobo_tenor_l_vl1_rr2.wav lorand=0.250 hirand=0.500 <region> sample=../Samples/bobobo/bobobo_tenor_l_vl1_rr3.wav lorand=0.500 hirand=0.750 <region> sample=../Samples/bobobo/bobobo_tenor_l_vl1_rr4.wav lorand=0.750","title":"\u2039master\u203a"},{"location":"headers/master/#example","text":"<global> loop_mode=one_shot ampeg_attack=0.001 ampeg_decay=0.7 ampeg_sustain=100 <master> amplitude_cc30=100 offset_cc33=3000 ampeg_sustain_oncc33=-100 <group> key=36 <region> sample=../Samples/bobobo/bobobo_bass_vl1_rr1.wav hirand=0.250 <region> sample=../Samples/bobobo/bobobo_bass_vl1_rr2.wav lorand=0.250 hirand=0.500 <region> sample=../Samples/bobobo/bobobo_bass_vl1_rr3.wav lorand=0.500 hirand=0.750 <region> sample=../Samples/bobobo/bobobo_bass_vl1_rr4.wav lorand=0.750 <master> amplitude_cc35=100 offset_cc38=1500 ampeg_sustain_oncc38=-100 <group>key=38 <region> sample=../Samples/bobobo/bobobo_tenor_l_vl1_rr1.wav hirand=0.250 <region> sample=../Samples/bobobo/bobobo_tenor_l_vl1_rr2.wav lorand=0.250 hirand=0.500 <region> sample=../Samples/bobobo/bobobo_tenor_l_vl1_rr3.wav lorand=0.500 hirand=0.750 <region> sample=../Samples/bobobo/bobobo_tenor_l_vl1_rr4.wav lorand=0.750","title":"Example"},{"location":"headers/midi/","text":"","title":"\u2039midi\u203a"},{"location":"headers/region/","text":"Inside the definition file, a region starts with the \u2039region\u203a header. A region is defined between two \u2039region\u203a headers, or between a \u2039region\u203a header and a \u2039group\u203a header, or between a \u2039region\u203a header and the end of the file. Following the \u2039region\u203a header one or more opcodes can be defined. The opcodes are special keywords which instruct the player on what, when and how to play a sample. Opcodes within a region can appear in any order, and they have to be separated by one or more spaces or tabulation controls. Opcodes can appear in separated lines within a region. Opcodes and assigned opcode values are separated by the equal to sign (=), without spaces between the opcode and the sign. For instance: sample=trombone_a4_ff.wav sample=cello_a5_pp_first_take.wav are valid examples, while: sample = cello_a4_pp.wav Is not (note the spaces at the sides of the = sign). Input Controls and Performance Parameters opcodes are optional, so they might not be present in the definition file. An 'expectable' default value for each parameter is pre-defined, and will be used if there's no definition. Example region definitions: <region> sample=440.wav This region definition instructs the player to play the sample file '440.wav' for the whole keyboard range. <region> lokey=64 hikey=67 sample=440.wav This region features a very basic set of input parameters (lokey and hikey, which represent the low and high MIDI notes in the keyboard), and the sample definition. This instructs the player to play the sample '440.wav', if a key in the 64-67 range is played. It is very important to note that all Input Controls defined in a region act using the AND boolean operator. Consequently, all conditions must be matched for the region to play. For instance: <region> lokey=64 hikey=67 lovel=0 hivel=34 locc1=0 hicc1=40 sample=440.wav This region definition instructs the player to play the sample '440.wav' if there is an incoming note event in the 64-67 range AND the note has a velocity in the 0~34 range AND last modulation wheel (cc1) message was in the 0-40 range.","title":"\u2039region\u203a"},{"location":"headers/sample/","text":"Example <region> sample=mysample.wav <sample> name=mysample.wav data=[encoded-content-of-mysample.wav] The content encoding is an alphabet mapping of 256 entries that map to each byte. (in the encoding, a WAV file is immediately recognizable by having its four byte \"RIFF\" header encoded to \"|spp\") This C source file can be compiled to convert a wav file to an embedded sample. Decoding The decoding algorithm is as follows: Loop while there is an input byte b1 if b1 is the end marker $24, stop reading if b1 is '\\r' ( \\(0D) or '\\n' (\\) 0A), discard it if b1 is the escape character '=' ($3D), extract the next byte b2 , and compute the next output byte as (b2+$C0)%256 otherwise, compute the next output byte as (b2+$D6)%256 Encoding Loop while there is an input byte b1 if (b1+$2A)%256 is one of the \"forbidden characters\" ($3D, $00, $09, $0A, $0D, $24) output the escape character $3D, and then output the byte (b1+$40)%256 otherwise, output (b1+$2A)%256 Output the end marker $24 Alphabet The alphabet used for the coding is as following: $00 $10 $20 $30 $40 $50 $60 $70 $80 $90 $A0 $B0 $C0 $D0 $E0 $F0 $00 $2A $3A $4A $5A $6A $7A $8A $9A $AA $BA $CA $DA $EA $FA $3D20 $1A $01 $2B $3B $4B $5B $6B $7B $8B $9B $AB $BB $CB $DB $EB $FB $0B $1B $02 $2C $3C $4C $5C $6C $7C $8C $9C $AC $BC $CC $DC $EC $FC $0C $1C $03 $2D $3D53 $4D $5D $6D $7D $8D $9D $AD $BD $CD $DD $ED $FD $3D23 $1D $04 $2E $3E $4E $5E $6E $7E $8E $9E $AE $BE $CE $DE $EE $FE $0E $1E $05 $2F $3F $4F $5F $6F $7F $8F $9F $AF $BF $CF $DF $EF $FF $0F $1F $06 $30 $40 $50 $60 $70 $80 $90 $A0 $B0 $C0 $D0 $E0 $F0 $3D16 $10 $20 $07 $31 $41 $51 $61 $71 $81 $91 $A1 $B1 $C1 $D1 $E1 $F1 $01 $11 $21 $08 $32 $42 $52 $62 $72 $82 $92 $A2 $B2 $C2 $D2 $E2 $F2 $02 $12 $22 $09 $33 $43 $53 $63 $73 $83 $93 $A3 $B3 $C3 $D3 $E3 $F3 $03 $13 $23 $0A $34 $44 $54 $64 $74 $84 $94 $A4 $B4 $C4 $D4 $E4 $F4 $04 $14 $3D3A $0B $35 $45 $55 $65 $75 $85 $95 $A5 $B5 $C5 $D5 $E5 $F5 $05 $15 $25 $0C $36 $46 $56 $66 $76 $86 $96 $A6 $B6 $C6 $D6 $E6 $F6 $06 $16 $26 $0D $37 $47 $57 $67 $77 $87 $97 $A7 $B7 $C7 $D7 $E7 $F7 $07 $17 $27 $0E $38 $48 $58 $68 $78 $88 $98 $A8 $B8 $C8 $D8 $E8 $F8 $08 $18 $28 $0F $39 $49 $59 $69 $79 $89 $99 $A9 $B9 $C9 $D9 $E9 $F9 $3D1F $19 $29 {: .table .table-sm .table-bordered .table-striped }","title":"\u2039sample\u203a"},{"location":"headers/sample/#example","text":"<region> sample=mysample.wav <sample> name=mysample.wav data=[encoded-content-of-mysample.wav] The content encoding is an alphabet mapping of 256 entries that map to each byte. (in the encoding, a WAV file is immediately recognizable by having its four byte \"RIFF\" header encoded to \"|spp\") This C source file can be compiled to convert a wav file to an embedded sample.","title":"Example"},{"location":"headers/sample/#decoding","text":"The decoding algorithm is as follows: Loop while there is an input byte b1 if b1 is the end marker $24, stop reading if b1 is '\\r' ( \\(0D) or '\\n' (\\) 0A), discard it if b1 is the escape character '=' ($3D), extract the next byte b2 , and compute the next output byte as (b2+$C0)%256 otherwise, compute the next output byte as (b2+$D6)%256","title":"Decoding"},{"location":"headers/sample/#encoding","text":"Loop while there is an input byte b1 if (b1+$2A)%256 is one of the \"forbidden characters\" ($3D, $00, $09, $0A, $0D, $24) output the escape character $3D, and then output the byte (b1+$40)%256 otherwise, output (b1+$2A)%256 Output the end marker $24","title":"Encoding"},{"location":"headers/sample/#alphabet","text":"The alphabet used for the coding is as following: $00 $10 $20 $30 $40 $50 $60 $70 $80 $90 $A0 $B0 $C0 $D0 $E0 $F0 $00 $2A $3A $4A $5A $6A $7A $8A $9A $AA $BA $CA $DA $EA $FA $3D20 $1A $01 $2B $3B $4B $5B $6B $7B $8B $9B $AB $BB $CB $DB $EB $FB $0B $1B $02 $2C $3C $4C $5C $6C $7C $8C $9C $AC $BC $CC $DC $EC $FC $0C $1C $03 $2D $3D53 $4D $5D $6D $7D $8D $9D $AD $BD $CD $DD $ED $FD $3D23 $1D $04 $2E $3E $4E $5E $6E $7E $8E $9E $AE $BE $CE $DE $EE $FE $0E $1E $05 $2F $3F $4F $5F $6F $7F $8F $9F $AF $BF $CF $DF $EF $FF $0F $1F $06 $30 $40 $50 $60 $70 $80 $90 $A0 $B0 $C0 $D0 $E0 $F0 $3D16 $10 $20 $07 $31 $41 $51 $61 $71 $81 $91 $A1 $B1 $C1 $D1 $E1 $F1 $01 $11 $21 $08 $32 $42 $52 $62 $72 $82 $92 $A2 $B2 $C2 $D2 $E2 $F2 $02 $12 $22 $09 $33 $43 $53 $63 $73 $83 $93 $A3 $B3 $C3 $D3 $E3 $F3 $03 $13 $23 $0A $34 $44 $54 $64 $74 $84 $94 $A4 $B4 $C4 $D4 $E4 $F4 $04 $14 $3D3A $0B $35 $45 $55 $65 $75 $85 $95 $A5 $B5 $C5 $D5 $E5 $F5 $05 $15 $25 $0C $36 $46 $56 $66 $76 $86 $96 $A6 $B6 $C6 $D6 $E6 $F6 $06 $16 $26 $0D $37 $47 $57 $67 $77 $87 $97 $A7 $B7 $C7 $D7 $E7 $F7 $07 $17 $27 $0E $38 $48 $58 $68 $78 $88 $98 $A8 $B8 $C8 $D8 $E8 $F8 $08 $18 $28 $0F $39 $49 $59 $69 $79 $89 $99 $A9 $B9 $C9 $D9 $E9 $F9 $3D1F $19 $29 {: .table .table-sm .table-bordered .table-striped }","title":"Alphabet"},{"location":"misc/all_opcodes/","text":"All opcode versions , including extensions, starting in alphabetical order. Note that modulations such as (on)ccN and vel2* are included in the pages describing the parameters they modulate. Opcode links in red color represent obsolete opcodes which should not be used in new instruments.","title":"Opcodes"},{"location":"misc/amp_velcurve_N_gen/","text":"#gfx_insert1 { padding-top: 15px; } #output { width: 440px; text-align: right; font-size: 14px; border: none; padding: 20px 20px 20px; -webkit-columns: 180px 2; /* Chrome, Safari, Opera */ -moz-columns: 180px 2; /* Firefox */ columns: 180px 2; } .barcontainer { width: 508px; margin-left: 20px; } .bar { width: 3px; background: #2196F3; margin: 0 1px 0 0; float: left; display: block; } Min Amplitude: Hint: exact 0 holds a surprise Max Amplitude: Usually 1.0 Growth Factor: 1.x = Concave | 0.x = Convex cc5 cc4 cc3 cc2 cc1 c cv1 cv2 cv3 cv4 cv5 inv","title":"Curve Generator"},{"location":"misc/aria/","text":"All opcode versions , including extensions, starting in alphabetical order. Note that modulations such as (on)ccN and vel2* are included in the pages describing the parameters they modulate. Opcode links in red color represent obsolete opcodes which should not be used in new instruments.","title":"Opcodes"},{"location":"misc/categories/","text":"Instruments Settings Instruments Settings are opcodes used under the \u2039control\u203a header. Other Instruments settings opcodes are of the Voice Lifecycle type. Modulation Modulation opcodes comprise of all the LFO and EG controls Envelope Generators LFO Performance Parameters Performance Parameters are all sound modifiers including: Pitch : influence the pitch of the region played Amplifier : influence the amplitude (volume), pan (width, position) and crossfades. Filter : influence the timbre of the layer played. Two filters can be used at the same time. Further frequency shaping can be added via EQ opcodes. EQ : simple frequency sound shaping tools independent from the filters. As many as three EQs can be set for each SFZ file. Each names eq1, eq2 and eq3. Most Performance parameters are targets for the Modulation opcodes. Region Logic Region Logic opcodes define the conditions under which a voice plays or stops: Key Mapping MIDI Conditions Internal Conditions Triggers Sound Source Sound Source defines the nature of the voice generated. It could be samples or oscillators: Sample Playback : defines the parameters of the sound generation.","title":"Categories"},{"location":"misc/categories/#instruments-settings","text":"Instruments Settings are opcodes used under the \u2039control\u203a header. Other Instruments settings opcodes are of the Voice Lifecycle type.","title":"Instruments Settings"},{"location":"misc/categories/#modulation","text":"Modulation opcodes comprise of all the LFO and EG controls Envelope Generators LFO","title":"Modulation"},{"location":"misc/categories/#performance-parameters","text":"Performance Parameters are all sound modifiers including: Pitch : influence the pitch of the region played Amplifier : influence the amplitude (volume), pan (width, position) and crossfades. Filter : influence the timbre of the layer played. Two filters can be used at the same time. Further frequency shaping can be added via EQ opcodes. EQ : simple frequency sound shaping tools independent from the filters. As many as three EQs can be set for each SFZ file. Each names eq1, eq2 and eq3. Most Performance parameters are targets for the Modulation opcodes.","title":"Performance Parameters"},{"location":"misc/categories/#region-logic","text":"Region Logic opcodes define the conditions under which a voice plays or stops: Key Mapping MIDI Conditions Internal Conditions Triggers","title":"Region Logic"},{"location":"misc/categories/#sound-source","text":"Sound Source defines the nature of the voice generated. It could be samples or oscillators: Sample Playback : defines the parameters of the sound generation.","title":"Sound Source"},{"location":"misc/sfz1/","text":"All opcode versions , including extensions, starting in alphabetical order. Note that modulations such as (on)ccN and vel2* are included in the pages describing the parameters they modulate. Opcode links in red color represent obsolete opcodes which should not be used in new instruments.","title":"Opcodes"},{"location":"misc/sfz2/","text":"All opcode versions , including extensions, starting in alphabetical order. Note that modulations such as (on)ccN and vel2* are included in the pages describing the parameters they modulate. Opcode links in red color represent obsolete opcodes which should not be used in new instruments.","title":"Opcodes"},{"location":"misc/tablewarp2/","text":"Overview TableWarp2 is an instrument built into the plogue Sforzando sfz player. It's a synthesizer which is a plugin for sforzando, and does not quite operate like standard sfz instrument but does use sfz for its controls. So, while it is capable of FM syntheiss, this does not mean that other sfz instruments in sforzando can also do FM. It was implemented by Hubert Lamontagne, with GUI by Hubert Lamontagne and Eric Patenaude. TableWarp2 uses a special value for the sample opcode. sample=*com.Madbrain.TableWarp2 Parameters TableWarp2 uses the sample_dyn_paramN opcode for its controls, as sample_dyn_param allows ARIA-specific controls to exist without having to create new opcodes or parameters. Here are the four parameters: 01 Wave Table offset (the transition between waveforms, like Serum/Vital) Float Range: 0.0 - 1.0 02 Warp offset (The intensity of the warp effect) Float Range: 0.0 - 1.0 03 Wave Table switcher Float Range: 0.0 - 15.875 Wave list: WAVE CC % Sine-tri-saw 4 0 Sine-tri-sqr 12 7 Overdrive saw 20 14 Overdrive sqr 28 19 Resonant saw 36 26 Resonant sqr 44 32 Dist reso saw 52 38 Dist reso sqr 60 45 Plucked str 68 51 Abs sine pwm 76 58 Soft pwm 84 64 Hard pwm 92 70 Hard sync 100 78 Xor wave 108 82 Dark noise 116 89 Bright noise 124 95 04 Warp switcher Float Range: 0.0 - 15.875 Warp list: WARP CC % Saw bend 4 0 Pwm bend 12 7 Square bend 20 14 Square bend 2 28 19 Pulse bend 36 26 Pulse bend 2 44 32 Impulse bend 52 38 Impulse bend 2 60 45 FM sine 68 51 FM half-sine 76 58 FM 1:5 84 64 FM 1:7 92 70 Pseudo filter 100 78 Soft sync 108 82 Pwm-like fx 116 89 Pixelate 124 95 Modulators egX_sample_dyn_paramY / lfoX_sample_dyn_paramY egX_sample_dyn_paramY_onccZ / lfoX_sample_dyn_paramY_onccZ Float Range: -1.0 - 1.0 Note Researched and documented by a user on the sfz Discord.","title":"TableWarp2"},{"location":"misc/tablewarp2/#overview","text":"TableWarp2 is an instrument built into the plogue Sforzando sfz player. It's a synthesizer which is a plugin for sforzando, and does not quite operate like standard sfz instrument but does use sfz for its controls. So, while it is capable of FM syntheiss, this does not mean that other sfz instruments in sforzando can also do FM. It was implemented by Hubert Lamontagne, with GUI by Hubert Lamontagne and Eric Patenaude. TableWarp2 uses a special value for the sample opcode. sample=*com.Madbrain.TableWarp2","title":"Overview"},{"location":"misc/tablewarp2/#parameters","text":"TableWarp2 uses the sample_dyn_paramN opcode for its controls, as sample_dyn_param allows ARIA-specific controls to exist without having to create new opcodes or parameters. Here are the four parameters: 01 Wave Table offset (the transition between waveforms, like Serum/Vital) Float Range: 0.0 - 1.0 02 Warp offset (The intensity of the warp effect) Float Range: 0.0 - 1.0 03 Wave Table switcher Float Range: 0.0 - 15.875 Wave list: WAVE CC % Sine-tri-saw 4 0 Sine-tri-sqr 12 7 Overdrive saw 20 14 Overdrive sqr 28 19 Resonant saw 36 26 Resonant sqr 44 32 Dist reso saw 52 38 Dist reso sqr 60 45 Plucked str 68 51 Abs sine pwm 76 58 Soft pwm 84 64 Hard pwm 92 70 Hard sync 100 78 Xor wave 108 82 Dark noise 116 89 Bright noise 124 95 04 Warp switcher Float Range: 0.0 - 15.875 Warp list: WARP CC % Saw bend 4 0 Pwm bend 12 7 Square bend 20 14 Square bend 2 28 19 Pulse bend 36 26 Pulse bend 2 44 32 Impulse bend 52 38 Impulse bend 2 60 45 FM sine 68 51 FM half-sine 76 58 FM 1:5 84 64 FM 1:7 92 70 Pseudo filter 100 78 Soft sync 108 82 Pwm-like fx 116 89 Pixelate 124 95","title":"Parameters"},{"location":"misc/tablewarp2/#modulators","text":"egX_sample_dyn_paramY / lfoX_sample_dyn_paramY egX_sample_dyn_paramY_onccZ / lfoX_sample_dyn_paramY_onccZ Float Range: -1.0 - 1.0","title":"Modulators"},{"location":"misc/tablewarp2/#note","text":"Researched and documented by a user on the sfz Discord.","title":"Note"},{"location":"modulations/","text":"Modulations which are part of the SFZ1 specification generally uses both the _ccN and ccN suffixes, for example cutoff_ccN or ampeg_releaseccN . Modulations added in the SFZ2 specification generally use _onccN instead, for example delay_samples_onccN . This is a source of possible confusion. As a solution, ARIA and possibly other SFZ2 players allow either _ccN , _onccN or ccN (with no underscore) to be used for many modulations, and interpret all of those the same. However, these aliases are not part of either the SFZ1 and SFZ2 standard, and for maximum compatibility, it is best to use the standard syntax. In this section they will be described in a generic way, to be applied to the various opcode targets. See also the related tutorials for SFZ1 and SFZ2 . curveccN smoothccN stepccN","title":"Modulations"},{"location":"modulations/curveccN/","text":"The curvecc modifier, when it's present, designates a \u2039curve\u203a which shapes the controller input. If absent, the default curve is used, a straight line which runs from 0 to 1. The value of curvecc is a positive integer. It is the index of a curve, either built in or user-defined, which corresponds to the \u2039curve\u203a opcode curve_index .","title":"curveccN"},{"location":"modulations/envelope_generators/","text":"Envelope Generator opcodes are part of the Modulation category of opcodes: Traditional (SFZ 1.0) Traditional envelope generators using ADSR phases can be set using the SFZ 1.0 ampeg (amplitude), pitcheg (pitch) and fileg (filter) opcodes. These opcodes also support additional delay and hold phases. The phases in order are: Delay-Attack-Hold-Decay-Sustain-Release . See below for the full list of relevant opcodes. Flex (SFZ 2.0) With SFZ 2.0, you can create one or more \"flex\" envelope generators. Each flex EG is mapped to a destination (amplitude, pitch, etc.) and contains two or more points with a duration and level determined at each point. The duration indicates the amount of time it takes from the previous envelope point to the current. In this way, you can use flex EGs to essentially draw any envelope shape you desire. Here is an example flex EG: eg01_pitch=1200 eg01_time1=0 eg01_level1=0 eg01_time2=1 eg01_level2=1 eg01_time3=2 eg01_level3=0.5 eg01_sustain=3 eg01_time4=1 eg01_level4=0 How to interpret the opcodes in the example above: All of these opcodes begin with \"eg01_\", indicating the first flex EG for the current region. A second flex EG would begin with \"eg02_\", and so on. The first opcode determines that the envelope will affect note pitch to a maximum of 1200 cents (one octave). Each envelope point is numbered, and these numbers appear at the end of the opcode name (this opcode has four envelope points). There should be both a \"time\" and and a \"level\" opcode specified for each envelope point. The \"time\" opcodes indicate time duration in seconds from the previous envelope point. The \"level\" opcodes indicate the level percentage at each envelope point (0-1, with \"1\" meaning \"100%\"). The optional \"sustain\" opcode determines which envelope point will function as \"sustain\" in the traditional ADSR model. So here is what happens in the four envelope points in the example: Note starts at original pitch. Pitch takes one second to rise 1200 cents (one octave). Pitch takes two seconds to lower to 50% of 1200 cents. The pitch will remain at this level as long as the note is held. After releasing the note, the note will take one second to lower to the original pitch. Envelope Curves SFZ\u2014at least the ARIA Engine and sfizz implementations\u2014uses the following curves for SFZ 1.0 envelopes ( ampeg , pitcheg , fileg , probably others but not tested): Attack: linear (convex in dB) Decay: convex (linear in dB) Release: convex (linear in dB) ARIA supports changing the shape of each phase curve via opcodes such as ampeg_attack_shape , fileg_decay_shape , etc. Setting the value for any of these to 0 will result in a linear curve shape, with positive and negative values resulting in concave and convex curves, respectively. Flex EGs (SFZ 2.0) phases all use a linear curve shape by default, but this can be bent into a logarithmic curve using positive/negative values as described in the above paragraph. For example, the following opcode will set the shape of the first eg01 phase to match the convex curve used in the SFZ 1.0 ampeg decay/release: eg01_shape2=-10.36 Note that the shape opcode should be placed on the second point affected by the curve. In other words, eg01_shape2=-10.36 will affect the curve between envelope points 1 and 2. It is also important to know that ampeg/pitcheg/fileg decay (both SFZ & SF2) behaves differently than flex EG in relation to the sustain level: ampeg decay: The level in the decay phase descends at the rate determined by ampeg_decay but stops once it hits the sustain level. If your decay phase length is 1 second and sustain is 50%, the sustain level is reached after only half a second in the decay phase (assuming linear phase curve). flex EG phase: The level always scales from starting to ending value over the full duration of the phase. When emulating an ADSR envelope using a flex EG, if your decay phase length is 1 second and sustain is 50%, the volume level won't reach 50% until the end of that one second. If trying to match a SoundFont instrument's logarithmic curves, set the phase's shape to 6 (concave) or -6 (convex). This is only an approximation, as the curve is not identical. If you wish to use a flex EG to replace the SFZ 1.0 ampeg, set the destination as eg01_ampeg=100 rather than eg01_amplitude=100 . This will disable the SFZ 1.0 ampeg and allow the flex EG to provide a release phase. SFZ 1 EG Opcodes The 3 EG destinations in the SFZ 1 standard are: ampeg (amplitude), fileg (filter) and pitcheg (pitch). The EG destinations are represented by (eg type) in the below list - so ampeg_attack would be the amplitude envelope attack, pitcheg_sustain would be the pitch envelope sustain level etc. These are 6-points Delay-Attack-Hold-Decay-Sustain-Release. (eg type)_attack (eg type)_attack_oncc (eg type)_decay (eg type)_decay_oncc (eg type)_delay (eg type)_delay_oncc (eg type)_depth (eg type)_dynamic (eg type)_hold (eg type)_hold_oncc (eg type)_release (eg type)_release_oncc (eg type)_start (eg type)_start_oncc (eg type)_sustain (eg type)_sustain_oncc (eg type)_vel2attack (eg type)_vel2decay (eg type)_vel2delay (eg type)_vel2hold (eg type)_vel2release (eg type)_vel2sustain Flex EGs (SFZ 2) Opcodes Flexible EG can have as many points as needed. level and time for each point is set accordingly. egN_curveX egN_dynamic egN_levelX egN_levelX_onccY egN_loop egN_points egN_shapeX egN_sustain egN_timeX egN_timeX_onccY Flex EGs Destinations These destinations are added as a suffix to 'egN_' - for example, eg01_pitch=2400 would have envelope 01 modulate pitch, with an envelope depth of 2400 cents. amplitude amplitude_oncc depth depth_lfoX depth_oncc depthadd_lfoX freq_lfoX pitch pitch_oncc cutoff cutoff_oncc cutoff2 cutoff2_oncc eqNbw eqNbw_oncc eqNfreq eqNfreq_oncc eqNgain eqNgain_oncc pan pan_oncc resonance resonance_oncc resonance2 resonance2_oncc volume volume_oncc width width_oncc","title":"Envelope Generators"},{"location":"modulations/envelope_generators/#traditional-sfz-10","text":"Traditional envelope generators using ADSR phases can be set using the SFZ 1.0 ampeg (amplitude), pitcheg (pitch) and fileg (filter) opcodes. These opcodes also support additional delay and hold phases. The phases in order are: Delay-Attack-Hold-Decay-Sustain-Release . See below for the full list of relevant opcodes.","title":"Traditional (SFZ 1.0)"},{"location":"modulations/envelope_generators/#flex-sfz-20","text":"With SFZ 2.0, you can create one or more \"flex\" envelope generators. Each flex EG is mapped to a destination (amplitude, pitch, etc.) and contains two or more points with a duration and level determined at each point. The duration indicates the amount of time it takes from the previous envelope point to the current. In this way, you can use flex EGs to essentially draw any envelope shape you desire. Here is an example flex EG: eg01_pitch=1200 eg01_time1=0 eg01_level1=0 eg01_time2=1 eg01_level2=1 eg01_time3=2 eg01_level3=0.5 eg01_sustain=3 eg01_time4=1 eg01_level4=0 How to interpret the opcodes in the example above: All of these opcodes begin with \"eg01_\", indicating the first flex EG for the current region. A second flex EG would begin with \"eg02_\", and so on. The first opcode determines that the envelope will affect note pitch to a maximum of 1200 cents (one octave). Each envelope point is numbered, and these numbers appear at the end of the opcode name (this opcode has four envelope points). There should be both a \"time\" and and a \"level\" opcode specified for each envelope point. The \"time\" opcodes indicate time duration in seconds from the previous envelope point. The \"level\" opcodes indicate the level percentage at each envelope point (0-1, with \"1\" meaning \"100%\"). The optional \"sustain\" opcode determines which envelope point will function as \"sustain\" in the traditional ADSR model. So here is what happens in the four envelope points in the example: Note starts at original pitch. Pitch takes one second to rise 1200 cents (one octave). Pitch takes two seconds to lower to 50% of 1200 cents. The pitch will remain at this level as long as the note is held. After releasing the note, the note will take one second to lower to the original pitch.","title":"Flex (SFZ 2.0)"},{"location":"modulations/envelope_generators/#envelope-curves","text":"SFZ\u2014at least the ARIA Engine and sfizz implementations\u2014uses the following curves for SFZ 1.0 envelopes ( ampeg , pitcheg , fileg , probably others but not tested): Attack: linear (convex in dB) Decay: convex (linear in dB) Release: convex (linear in dB) ARIA supports changing the shape of each phase curve via opcodes such as ampeg_attack_shape , fileg_decay_shape , etc. Setting the value for any of these to 0 will result in a linear curve shape, with positive and negative values resulting in concave and convex curves, respectively. Flex EGs (SFZ 2.0) phases all use a linear curve shape by default, but this can be bent into a logarithmic curve using positive/negative values as described in the above paragraph. For example, the following opcode will set the shape of the first eg01 phase to match the convex curve used in the SFZ 1.0 ampeg decay/release: eg01_shape2=-10.36 Note that the shape opcode should be placed on the second point affected by the curve. In other words, eg01_shape2=-10.36 will affect the curve between envelope points 1 and 2. It is also important to know that ampeg/pitcheg/fileg decay (both SFZ & SF2) behaves differently than flex EG in relation to the sustain level: ampeg decay: The level in the decay phase descends at the rate determined by ampeg_decay but stops once it hits the sustain level. If your decay phase length is 1 second and sustain is 50%, the sustain level is reached after only half a second in the decay phase (assuming linear phase curve). flex EG phase: The level always scales from starting to ending value over the full duration of the phase. When emulating an ADSR envelope using a flex EG, if your decay phase length is 1 second and sustain is 50%, the volume level won't reach 50% until the end of that one second. If trying to match a SoundFont instrument's logarithmic curves, set the phase's shape to 6 (concave) or -6 (convex). This is only an approximation, as the curve is not identical. If you wish to use a flex EG to replace the SFZ 1.0 ampeg, set the destination as eg01_ampeg=100 rather than eg01_amplitude=100 . This will disable the SFZ 1.0 ampeg and allow the flex EG to provide a release phase.","title":"Envelope Curves"},{"location":"modulations/envelope_generators/#sfz-1-eg-opcodes","text":"The 3 EG destinations in the SFZ 1 standard are: ampeg (amplitude), fileg (filter) and pitcheg (pitch). The EG destinations are represented by (eg type) in the below list - so ampeg_attack would be the amplitude envelope attack, pitcheg_sustain would be the pitch envelope sustain level etc. These are 6-points Delay-Attack-Hold-Decay-Sustain-Release. (eg type)_attack (eg type)_attack_oncc (eg type)_decay (eg type)_decay_oncc (eg type)_delay (eg type)_delay_oncc (eg type)_depth (eg type)_dynamic (eg type)_hold (eg type)_hold_oncc (eg type)_release (eg type)_release_oncc (eg type)_start (eg type)_start_oncc (eg type)_sustain (eg type)_sustain_oncc (eg type)_vel2attack (eg type)_vel2decay (eg type)_vel2delay (eg type)_vel2hold (eg type)_vel2release (eg type)_vel2sustain","title":"SFZ 1 EG Opcodes"},{"location":"modulations/envelope_generators/#flex-egs-sfz-2-opcodes","text":"Flexible EG can have as many points as needed. level and time for each point is set accordingly. egN_curveX egN_dynamic egN_levelX egN_levelX_onccY egN_loop egN_points egN_shapeX egN_sustain egN_timeX egN_timeX_onccY","title":"Flex EGs (SFZ 2) Opcodes"},{"location":"modulations/envelope_generators/#flex-egs-destinations","text":"These destinations are added as a suffix to 'egN_' - for example, eg01_pitch=2400 would have envelope 01 modulate pitch, with an envelope depth of 2400 cents. amplitude amplitude_oncc depth depth_lfoX depth_oncc depthadd_lfoX freq_lfoX pitch pitch_oncc cutoff cutoff_oncc cutoff2 cutoff2_oncc eqNbw eqNbw_oncc eqNfreq eqNfreq_oncc eqNgain eqNgain_oncc pan pan_oncc resonance resonance_oncc resonance2 resonance2_oncc volume volume_oncc width width_oncc","title":"Flex EGs Destinations"},{"location":"modulations/icurveccN/","text":"(target)_icurvecc is a deprecated ARIA extension. It acted as a companion to (target)_curvecc and determined whether the curve for the specified target and CC should be calculated allowing fractional values, or whether the calculations should be rounded off to allow whole numbers only. With interpolation, it would be possible, for example, for CC2 to be effectively equal to 63.5, but with interpolation off it would jump from 63 directly to 64. In later versions of ARIA, fractional values are always used.","title":"icurveccN"},{"location":"modulations/lfo/","text":"LFO (Low Frequency Oscillator) opcodes are part of the Modulation category of opcodes. They are used to create effects such as pitch vibrato (when modulating pitch), tremolo (when modulating volume) and filter wobble (when modulating filter cutoff) LFOs are triggered by note-on events for the specified region, which means there are no free-running LFOs in the SFZ spec. If a free-running LFO is needed, for example to apply one slow pitch vibrato wave to a series of rapidly plucked oud notes, that will need to use an external modulation source outside the SFZ player - in other words, perhaps in a DAW that the SFZ player is being used in as a plugin. SFZ 1 LFOs 3 LFO destinations in SFZ 1 standard: amplfo (amplitude) fillfo (filter) pitchlfo (pitch) Here's a very simple example of a pitch LFO integration (lfo type)_delay (lfo type)_fade (lfo type)_freq (lfo type)_freqccX (lfo type)_depth (lfo type)_depthccX (lfo type)_depthchanaft (lfo type)_depthpolyaft (lfo type)_freqchanaft (lfo type)_freqpolyaft Assignable LFOs (SFZ 2) Much like the Flex EG, these newer LFO can target almost any tone-defining parameter: Here's a very simple example of an sfz 2 lfo integration, targeted to pitch lfoN_wave lfoN_freq lfoN_freq_onccX lfoN_freq_smoothccX lfoN_freq_stepccX lfoN_delay lfoN_delay_onccX lfoN_fade lfoN_fade_onccX lfoN_phase lfoN_phase_onccX lfoN_count Assignable LFO Destinations These destinations are added as a suffix to 'lfoN_'. For example, lfo01_pitch=100 makes LFO 01 affect pitch with a max depth of 100 cents, and lfo03_freq_lfo01=1.3 would make LFO 03 add up to 1.3 Hertz to the frequency of LFO 01. Note that it's possible to create modulation feedback loops this way, for example LFO 01 modulating LFO 02 while LFO 02 modulates LFO 01. In addition to the below, in ARIA it's possible to control the amount of freq_lfo with MIDI CC, so lfo03_freq_lfo01_oncc117=1.3 would make LFO 03 add up to 1.3 Hertz to the frequency of LFO 01, with the amount modulated by MIDI CC 117. So, freq_lfo_oncc would be added to the below list for ARIA, though depth_lfo_oncc and depthadd_lfo_oncc do not appear to be available. freq_lfoX depth_lfoX depthadd_lfoX pitch pitch_oncc pitch_smoothcc pitch_stepcc decim decim_oncc decim_smoothcc decim_stepcc bitred bitred_oncc bitred_smoothcc bitred_stepcc cutoff cutoff_oncc cutoff_smoothcc cutoff_stepcc resonance resonance_oncc resonance_smoothcc resonance_stepcc cutoff2 cutoff2_oncc cutoff2_smoothcc cutoff2_stepcc resonance2 resonance2_oncc resonance2_smoothcc resonance2_stepcc eqNfreq eqNfreq_oncc eqNfreq_smoothcc eqNfreq_stepcc eqNbw eqNbw_oncc eqNbw_smoothcc eqNbw_stepcc eqNgain eqNgain_oncc eqNgain_smoothcc eqNgain_stepcc volume volume_oncc volume_smoothcc volume_stepcc amplitude amplitude_oncc amplitude_smoothcc amplitude_stepcc pan pan_oncc pan_smoothcc pan_stepcc width width_oncc width_smoothcc width_stepcc Practical Considerations SFZ allows LFOs to modulate the frequency of other LFOs, including feedback (LFO number M modulating LFO number N, and vice versa). Mathematically, this can cause very chaotic results. However, in the Cakewalk products (and possibly also in ARIA, though this is not checked) this is simplified. If the number of the modulating LFO is lower than the LFO being modulated (for example, LFO1 modulates LFO2), the modulation is applied when it is calculated. However, if the number of the modulating LFO is higher than the LFO being modulated (for example, LFO4 modulating LFO2), the modulation is not applied until the next LFO frequency update cycle. This both keeps LFO feedback controlled, and reduces the CPU needed to calculate LFO modulations.","title":"LFO"},{"location":"modulations/lfo/#sfz-1-lfos","text":"3 LFO destinations in SFZ 1 standard: amplfo (amplitude) fillfo (filter) pitchlfo (pitch) Here's a very simple example of a pitch LFO integration (lfo type)_delay (lfo type)_fade (lfo type)_freq (lfo type)_freqccX (lfo type)_depth (lfo type)_depthccX (lfo type)_depthchanaft (lfo type)_depthpolyaft (lfo type)_freqchanaft (lfo type)_freqpolyaft","title":"SFZ 1 LFOs"},{"location":"modulations/lfo/#assignable-lfos-sfz-2","text":"Much like the Flex EG, these newer LFO can target almost any tone-defining parameter: Here's a very simple example of an sfz 2 lfo integration, targeted to pitch lfoN_wave lfoN_freq lfoN_freq_onccX lfoN_freq_smoothccX lfoN_freq_stepccX lfoN_delay lfoN_delay_onccX lfoN_fade lfoN_fade_onccX lfoN_phase lfoN_phase_onccX lfoN_count","title":"Assignable LFOs (SFZ 2)"},{"location":"modulations/lfo/#assignable-lfo-destinations","text":"These destinations are added as a suffix to 'lfoN_'. For example, lfo01_pitch=100 makes LFO 01 affect pitch with a max depth of 100 cents, and lfo03_freq_lfo01=1.3 would make LFO 03 add up to 1.3 Hertz to the frequency of LFO 01. Note that it's possible to create modulation feedback loops this way, for example LFO 01 modulating LFO 02 while LFO 02 modulates LFO 01. In addition to the below, in ARIA it's possible to control the amount of freq_lfo with MIDI CC, so lfo03_freq_lfo01_oncc117=1.3 would make LFO 03 add up to 1.3 Hertz to the frequency of LFO 01, with the amount modulated by MIDI CC 117. So, freq_lfo_oncc would be added to the below list for ARIA, though depth_lfo_oncc and depthadd_lfo_oncc do not appear to be available. freq_lfoX depth_lfoX depthadd_lfoX pitch pitch_oncc pitch_smoothcc pitch_stepcc decim decim_oncc decim_smoothcc decim_stepcc bitred bitred_oncc bitred_smoothcc bitred_stepcc cutoff cutoff_oncc cutoff_smoothcc cutoff_stepcc resonance resonance_oncc resonance_smoothcc resonance_stepcc cutoff2 cutoff2_oncc cutoff2_smoothcc cutoff2_stepcc resonance2 resonance2_oncc resonance2_smoothcc resonance2_stepcc eqNfreq eqNfreq_oncc eqNfreq_smoothcc eqNfreq_stepcc eqNbw eqNbw_oncc eqNbw_smoothcc eqNbw_stepcc eqNgain eqNgain_oncc eqNgain_smoothcc eqNgain_stepcc volume volume_oncc volume_smoothcc volume_stepcc amplitude amplitude_oncc amplitude_smoothcc amplitude_stepcc pan pan_oncc pan_smoothcc pan_stepcc width width_oncc width_smoothcc width_stepcc","title":"Assignable LFO Destinations"},{"location":"modulations/lfo/#practical-considerations","text":"SFZ allows LFOs to modulate the frequency of other LFOs, including feedback (LFO number M modulating LFO number N, and vice versa). Mathematically, this can cause very chaotic results. However, in the Cakewalk products (and possibly also in ARIA, though this is not checked) this is simplified. If the number of the modulating LFO is lower than the LFO being modulated (for example, LFO1 modulates LFO2), the modulation is applied when it is calculated. However, if the number of the modulating LFO is higher than the LFO being modulated (for example, LFO4 modulating LFO2), the modulation is not applied until the next LFO frequency update cycle. This both keeps LFO feedback controlled, and reduces the CPU needed to calculate LFO modulations.","title":"Practical Considerations"},{"location":"modulations/smoothccN/","text":"Sets the smoothness for the target modulation in milliseconds. Adds inertia to the modulation, so fast movements of the controller will have a delayed, smoothed effect, similar to bend_smooth . While SFZv2 does not limit the targets for smoothing in the spec, currently ARIA only implements smoothing for pitch-related and volume-related (including amplitude, pan and position) modulation targets. Examples <region> sample=*sine pitch_oncc27=1200 pitch_smoothcc27=100 Notes Increasing the smoothing past 100 ms allows the SFZ instrument creator to create a noticeable lag in the control response, which is useful when modeling guitar feedback, for example. Default value is 0ms (no smoothing). However be aware some DAWs smooth the drawn CC automation before it reaches the SFZ player, which means some smoothing will occur regardless of what smoothcc is set to, and any smoothcc smoothing will be applied to those already smoothed control values. For a detailed overview of how DAWs handle instananeous jumps in automation, see https://www.admiralbumblebee.com/music/2019/06/22/Daw-V-Daw-Automation-Part-4.html .","title":"smoothccN"},{"location":"modulations/smoothccN/#examples","text":"<region> sample=*sine pitch_oncc27=1200 pitch_smoothcc27=100","title":"Examples"},{"location":"modulations/smoothccN/#notes","text":"Increasing the smoothing past 100 ms allows the SFZ instrument creator to create a noticeable lag in the control response, which is useful when modeling guitar feedback, for example. Default value is 0ms (no smoothing). However be aware some DAWs smooth the drawn CC automation before it reaches the SFZ player, which means some smoothing will occur regardless of what smoothcc is set to, and any smoothcc smoothing will be applied to those already smoothed control values. For a detailed overview of how DAWs handle instananeous jumps in automation, see https://www.admiralbumblebee.com/music/2019/06/22/Daw-V-Daw-Automation-Part-4.html .","title":"Notes"},{"location":"modulations/stepccN/","text":"Sets the interval between consecutive steps. If this is not used, there are 127 modulation steps. Example This describes a pitch controller which has 5 positions: 0, 300, 600, 900, 1200 cents. <region> sample=*sine pitch_oncc16=1200 pitch_stepcc16=300","title":"stepccN"},{"location":"modulations/stepccN/#example","text":"This describes a pitch controller which has 5 positions: 0, 300, 600, 900, 1200 cents. <region> sample=*sine pitch_oncc16=1200 pitch_stepcc16=300","title":"Example"},{"location":"modulations/vel2/","text":"The velocity_to modulations time, in seconds, can be calculated as: (target) time = (eg type)_(target) + (eg type)_vel2(target) * velocity / 127 and the sustain level, in percentage, as: sustain level = (eg type)_sustain + (eg type)_vel2sustain Range is -100 seconds to 100 seconds, but in most typical cases, the effect of velocity on envelope delay and attack times will be negative, and the effect of velocity on other envelope parameters positive. This would make a sound have a faster attack and a slower decay when a note has higher velocity, with attack of 0.5 seconds at 0 velocity and 0.1 seconds at 127 velocity: ampeg_attack=0.5 ampeg_vel2attack=-0.4 ampeg_decay=0.5 ampeg_vel2decay=1 ampeg_sustain=50 ampeg_release=0.25 EQ TODO","title":"(eg type)_vel2(target)"},{"location":"modulations/vel2/#eq","text":"TODO","title":"EQ"},{"location":"modulations/moved/ampeg_vel2attack/","text":"--- Examples pitcheg_vel2delay=-1.2 ampeg_vel2delay=0.1 Attack time will be calculated as attack time = (eg type)_delay + (eg type)_vel2delay * velocity / 127 Range is -100 seconds to 100 seconds, but in most typical cases, the effect of velocity on envelope delay and attack times will be negative, and the effect of velocity on other envelope parameters positive. This would make a sound have a faster attack and a slower decay when a note has higher velocity, with attack of 0.5 seconds at 0 velocity and 0.1 seconds at 127 velocity: ampeg_attack=0.5 ampeg_vel2attack=-0.4 ampeg_decay=0.5 ampeg_vel2decay=1 ampeg_sustain=50 ampeg_release=0.25","title":"Ampeg vel2attack"},{"location":"modulations/moved/ampeg_vel2attack/#-","text":"","title":"---"},{"location":"modulations/moved/ampeg_vel2attack/#examples","text":"pitcheg_vel2delay=-1.2 ampeg_vel2delay=0.1 Attack time will be calculated as attack time = (eg type)_delay + (eg type)_vel2delay * velocity / 127 Range is -100 seconds to 100 seconds, but in most typical cases, the effect of velocity on envelope delay and attack times will be negative, and the effect of velocity on other envelope parameters positive. This would make a sound have a faster attack and a slower decay when a note has higher velocity, with attack of 0.5 seconds at 0 velocity and 0.1 seconds at 127 velocity: ampeg_attack=0.5 ampeg_vel2attack=-0.4 ampeg_decay=0.5 ampeg_vel2decay=1 ampeg_sustain=50 ampeg_release=0.25","title":"Examples"},{"location":"modulations/moved/ampeg_vel2decay/","text":"--- Examples fileg_vel2decay=1.2 ampeg_vel2decay=0.1 Decay time will be calculated as decay time = (eg type)_decay + (eg type)_vel2decay * velocity / 127","title":"Ampeg vel2decay"},{"location":"modulations/moved/ampeg_vel2decay/#-","text":"","title":"---"},{"location":"modulations/moved/ampeg_vel2decay/#examples","text":"fileg_vel2decay=1.2 ampeg_vel2decay=0.1 Decay time will be calculated as decay time = (eg type)_decay + (eg type)_vel2decay * velocity / 127","title":"Examples"},{"location":"modulations/moved/ampeg_vel2delay/","text":"--- Examples pitcheg_vel2delay=-0.2 ampeg_vel2delay=0.1 Delay time will be calculated as delay time = (eg type)_delay + (eg type)_vel2delay * velocity / 127 Range is -100 seconds to 100 seconds, but in most typical cases, the effect of velocity on envelope delay and attack times will be negative, and the effect of velocity on other envelope parameters positive.","title":"Ampeg vel2delay"},{"location":"modulations/moved/ampeg_vel2delay/#-","text":"","title":"---"},{"location":"modulations/moved/ampeg_vel2delay/#examples","text":"pitcheg_vel2delay=-0.2 ampeg_vel2delay=0.1 Delay time will be calculated as delay time = (eg type)_delay + (eg type)_vel2delay * velocity / 127 Range is -100 seconds to 100 seconds, but in most typical cases, the effect of velocity on envelope delay and attack times will be negative, and the effect of velocity on other envelope parameters positive.","title":"Examples"},{"location":"modulations/moved/ampeg_vel2hold/","text":"--- Examples pitcheg_vel2hold=1.2 pitcheg_vel2hold=0.1 Hold time will be calculated as hold time = (eg type)_hold + (eg type)_vel2hold * velocity / 127","title":"Ampeg vel2hold"},{"location":"modulations/moved/ampeg_vel2hold/#-","text":"","title":"---"},{"location":"modulations/moved/ampeg_vel2hold/#examples","text":"pitcheg_vel2hold=1.2 pitcheg_vel2hold=0.1 Hold time will be calculated as hold time = (eg type)_hold + (eg type)_vel2hold * velocity / 127","title":"Examples"},{"location":"modulations/moved/ampeg_vel2release/","text":"--- Examples ampeg_vel2release=1.2 fileg_vel2release=0.1 Release time will be calculated as release time = (eg type)_release + (eg type)_vel2release * velocity / 127","title":"Ampeg vel2release"},{"location":"modulations/moved/ampeg_vel2release/#-","text":"","title":"---"},{"location":"modulations/moved/ampeg_vel2release/#examples","text":"ampeg_vel2release=1.2 fileg_vel2release=0.1 Release time will be calculated as release time = (eg type)_release + (eg type)_vel2release * velocity / 127","title":"Examples"},{"location":"modulations/moved/ampeg_vel2sustain/","text":"--- Examples ampeg_vel2sustain=30 pitcheg_vel2sustain=10 Sustain level will be calculated as sustain level = (eg type)_sustain + (eg type)_vel2sustain","title":"Ampeg vel2sustain"},{"location":"modulations/moved/ampeg_vel2sustain/#-","text":"","title":"---"},{"location":"modulations/moved/ampeg_vel2sustain/#examples","text":"ampeg_vel2sustain=30 pitcheg_vel2sustain=10 Sustain level will be calculated as sustain level = (eg type)_sustain + (eg type)_vel2sustain","title":"Examples"},{"location":"modulations/moved/amplfo_depthchanaft/","text":"--- In decibels for amplitude, in cents for pitch and filter cutoff. Examples amplfo_depthchanaft=1 fillfo_depthchanaft=400","title":"Amplfo depthchanaft"},{"location":"modulations/moved/amplfo_depthchanaft/#-","text":"In decibels for amplitude, in cents for pitch and filter cutoff.","title":"---"},{"location":"modulations/moved/amplfo_depthchanaft/#examples","text":"amplfo_depthchanaft=1 fillfo_depthchanaft=400","title":"Examples"},{"location":"modulations/moved/amplfo_depthpolyaft/","text":"--- In decibels for amplitude, in cents for pitch and filter cutoff. Examples amplfo_depthpolyaft=1 fillfo_depthpolyaft=400","title":"Amplfo depthpolyaft"},{"location":"modulations/moved/amplfo_depthpolyaft/#-","text":"In decibels for amplitude, in cents for pitch and filter cutoff.","title":"---"},{"location":"modulations/moved/amplfo_depthpolyaft/#examples","text":"amplfo_depthpolyaft=1 fillfo_depthpolyaft=400","title":"Examples"},{"location":"modulations/moved/amplfo_freqchanaft/","text":"--- Can be negative, and according to the SFZ spec the allowed range is -200 to 200, which could be used to push LFO frequencies into audio frequency range, allowing AM, FM and filter growl. Perhaps that was a typo and it should be -20 to 20, as 20 Hz is the maximum LFO frequency in the SFZ 1 spec. Examples fillfo_freqchanaft=10 fillfo_freqchanaft=-20","title":"Amplfo freqchanaft"},{"location":"modulations/moved/amplfo_freqchanaft/#-","text":"Can be negative, and according to the SFZ spec the allowed range is -200 to 200, which could be used to push LFO frequencies into audio frequency range, allowing AM, FM and filter growl. Perhaps that was a typo and it should be -20 to 20, as 20 Hz is the maximum LFO frequency in the SFZ 1 spec.","title":"---"},{"location":"modulations/moved/amplfo_freqchanaft/#examples","text":"fillfo_freqchanaft=10 fillfo_freqchanaft=-20","title":"Examples"},{"location":"modulations/moved/amplfo_freqpolyaft/","text":"--- Can be negative, and according to the SFZ spec the allowed range is -200 to 200, which could be used to push LFO frequencies into audio frequency range, allowing AM, FM and filter growl. Perhaps that was a typo and it should be -20 to 20, as 20 Hz is the maximum LFO frequency in the SFZ 1 spec. Examples fillfo_freqpolyaft=10 fillfo_freqpolyaft=-20","title":"Amplfo freqpolyaft"},{"location":"modulations/moved/amplfo_freqpolyaft/#-","text":"Can be negative, and according to the SFZ spec the allowed range is -200 to 200, which could be used to push LFO frequencies into audio frequency range, allowing AM, FM and filter growl. Perhaps that was a typo and it should be -20 to 20, as 20 Hz is the maximum LFO frequency in the SFZ 1 spec.","title":"---"},{"location":"modulations/moved/amplfo_freqpolyaft/#examples","text":"fillfo_freqpolyaft=10 fillfo_freqpolyaft=-20","title":"Examples"},{"location":"modulations/moved/eqN_vel2freq/","text":"--- Examples eq1_vel2freq=1000 eq1_vel2gain=-6 eq2_vel2gain=9 Notes When emulating timbral changes when there are not enough dynamic levels sampled, this will often be a negative value for the lowest band, and a positive value for the two higher bands.","title":"eqN vel2freq"},{"location":"modulations/moved/eqN_vel2freq/#-","text":"","title":"---"},{"location":"modulations/moved/eqN_vel2freq/#examples","text":"eq1_vel2freq=1000 eq1_vel2gain=-6 eq2_vel2gain=9","title":"Examples"},{"location":"modulations/moved/eqN_vel2freq/#notes","text":"When emulating timbral changes when there are not enough dynamic levels sampled, this will often be a negative value for the lowest band, and a positive value for the two higher bands.","title":"Notes"},{"location":"news/","text":"{{ blog_content }}","title":"Latest News"},{"location":"news/posts/2019-04-23-new-website-launched/","text":"We're proud to announce a new website! Built on Jekyll . Most content is authored in Markdown format. Utilizes Bootstrap and SASS for easy skinning and responsive design, making the website available to mobile devices. Utilizes FontAwesome and Favicon Generator for content and website icons.","title":"New Website Launched"},{"location":"news/posts/2019-07-25-new-tutorial/","text":"We've published a new tutorial explaining how to use samples to model brushed drum techniques which produce a continuous sound rather than a discrete hit. Admittedly, this is a rather niche technique not only in the samples world but also in real-world music, mainly used in jazz and some indie music. Next we plan to expand the vibrato tutorial , which is currently only a simple code example. Minor updates: + global_label, master_label, group_label and region_label opcodes added. + Added Carla and Bliss Sampler to SFZ players, updated TAL Sampler info.","title":"New Tutorial"},{"location":"news/posts/2019-08-01-modulation_explained/","text":"We have two new articles explaining the modulations possible in SFZ1 and SFZ2 . Hopefully it will now be much easier to understand what's possible under each spec level, and just what those complex SFZ2 LFOs and envelopes can and can't do.","title":"Modulations Explained"},{"location":"news/posts/2019-09-16-sfz-page-on-italian-wikipedia/","text":"A new page about the SFZ format has been added to the Italian Wikipedia . Let's grow!","title":"SFZ page on Italian Wikipedia"},{"location":"news/posts/2019-11-16-new-players-and-tutorial/","text":"New applications were added to the players list recently: - HISE - sfizz - liquidsfz and a new tutorial from Sonoj 2019 Convention on how to recording samples using Ardour and LinuxSampler by Christoph Kuhr to our Video tutorials section. Thanks to Stefan Westerfeld for our first GitHub pull request! And to Sonoj organization for the video tutorial contribuition. Last but not least, for those like me who prefer IRC we have now also an IRC channel on freenode server. /join us!","title":"New players and tutorial"},{"location":"news/posts/2019-11-21-legato-tutorial/","text":"The legato tutorial has been expanded from one simple example to include simulated legato, simulated portamento, and true sampled legato.","title":"Legato tutorial"},{"location":"news/posts/2019-12-29-happy-new-year/","text":"Here we are with the latest relevant updates, the last ones for this year: Added *_mod and *_dynamic opcodes Added Cakewalk SFZv2 opcodes (work in progress) page Added the SFZ test suite for sample instruments developers in homepage Improved SFZ syntax highlighting in Google Prettify for all pages Search now works correctly, though it is slow and needs some more improvements Happy new year!","title":"Happy new year!"},{"location":"news/posts/2020-01-31-new-year-new-work-in-progress/","text":"The most relevant additions on the website for this month were Instruments and Modulations sections, adding slowly one by one some sample instruments libraries created and freely distribuited over the net, and documenting in a generic way the various modulations used in SFZ. Some new opcodes were also added in our database, starting from some modulation aliases like amplitude_ccN, pan_ccN and tune_ccN to the recent fil_gain. I would like to thank some people who contributed to the site, like falkTX for adding our news feed on Linuxaudio Planet , jpcima, MatFluor, PaulFd and sfw. This website is an opensource non profit project, I hope to see more people involved in the future to help make it grow.","title":"New year, new work in progress"},{"location":"news/posts/2020-03-17-new-tutorial-and-opcode-additions/","text":"A new tutorial about subtractive synthesizers was shared by DSmolken's sample instruments experience applied in the Caveman Cosmonaut sample library. Some fixes and additions were made in our opcode database and in software as well, like the Windows OpenMPT music tracker by sagamusix. New contributions was provided by other users like jisaacstone, and a big contribution from jpcima for the effects section. Now we have also a new page for convenience that lists all opcodes present in our database.","title":"New tutorial and opcode additions"},{"location":"news/posts/2020-10-16-opcodes-page-update/","text":"For those who missed it we have some updates on the website, mainly regarding the opcodes page. Recently I've added a javascript library that permits tables column sorting, and now with an awesome contribution from @jpcima also a script to filter opcode names, versions and categories. Hope you'll find them handy!","title":"Opcodes page update"},{"location":"news/posts/2023-06-03-bootstrap-530-with-color-modes/","text":"Bootstrap updated to v5.3.0 which supports color modes , which means that if your system uses a dark color theme, it will adapt to your visual preferences on browsers that supports it. Highlight.js will adapt to the chosen theme, so the sfz examples will be shown with it.","title":"Bootstrap 5.3.0 with color modes"},{"location":"opcodes/","text":"All opcode versions , including extensions, starting in alphabetical order. Note that modulations such as (on)ccN and vel2* are included in the pages describing the parameters they modulate. Opcode links in red color represent obsolete opcodes which should not be used in new instruments.","title":"Opcodes"},{"location":"opcodes/_mod/","text":"ARIA extension specifying whether modulation of the target parameter should be additive or multiplicative. The default is add for all modulation targets except amplitude, which has mult as the default. Valid targets: delay, delay_beats, stop_beats, offset, pitch, tune, volume, amplitude, cutoff, resonance, fil_gain, cutoff2, resonance2, fil2_gain, pan, position, width. In addition, bitred and decim are also valid targets, though decim and bitred themselves are not implemented in ARIA. Examples cutoff_mod=mult amplitude_mod=add pitch_mod=add","title":" mod"},{"location":"opcodes/_mod/#examples","text":"cutoff_mod=mult amplitude_mod=add pitch_mod=add","title":"Examples"},{"location":"opcodes/amp_attack/","text":"Examples ampeg_attack=1.2 fileg_attack=0.1 Practical Considerations These are very frequently used, especially with amplifier envelopes. ampeg_attack is the standard \"A\" in the basic ADSR volume envelope. fileg_attack is key to 303-style basses. In ARIA, the SFZ1 envelopes have linear attack (for pitcheg and fileg , probably linear in cents, which won't translate into linear in Hertz). Decay and release stages have a curve which is faster than linear, and it seems to match \"well enough\" with a multiplicatively decreasing curve. The step size should be close to \\(\\mu = \\exp \\left( - \\frac{8.0}{t \\times s} \\right)\\) where \\(t\\) is the decay duration in seconds, and \\(s\\) is the sample rate in Hertz. The envelope \\(x_{n+1}\\) at index \\(n+1\\) is thus computed as \\(x_{n+1} = \\mu \\times x_{n}\\) . Here is a screenshot of a file output using Sforzando, showing the ampeg_envelope shape and its stages.","title":"Amp attack"},{"location":"opcodes/amp_attack/#examples","text":"ampeg_attack=1.2 fileg_attack=0.1","title":"Examples"},{"location":"opcodes/amp_attack/#practical-considerations","text":"These are very frequently used, especially with amplifier envelopes. ampeg_attack is the standard \"A\" in the basic ADSR volume envelope. fileg_attack is key to 303-style basses. In ARIA, the SFZ1 envelopes have linear attack (for pitcheg and fileg , probably linear in cents, which won't translate into linear in Hertz). Decay and release stages have a curve which is faster than linear, and it seems to match \"well enough\" with a multiplicatively decreasing curve. The step size should be close to \\(\\mu = \\exp \\left( - \\frac{8.0}{t \\times s} \\right)\\) where \\(t\\) is the decay duration in seconds, and \\(s\\) is the sample rate in Hertz. The envelope \\(x_{n+1}\\) at index \\(n+1\\) is thus computed as \\(x_{n+1} = \\mu \\times x_{n}\\) . Here is a screenshot of a file output using Sforzando, showing the ampeg_envelope shape and its stages.","title":"Practical Considerations"},{"location":"opcodes/amp_decay/","text":"Examples ampeg_decay=1.5 fileg_decay=0.5 This should normally not be shorter than the corresponding envelope's release time.","title":"Amp decay"},{"location":"opcodes/amp_decay/#examples","text":"ampeg_decay=1.5 fileg_decay=0.5 This should normally not be shorter than the corresponding envelope's release time.","title":"Examples"},{"location":"opcodes/amp_delay/","text":"This is the time elapsed from note on to the start of the Attack stage. If both envelope delay and the general delay or delay_random are used in the same region, the envelope delays start after delay and delay_random have both completed their duration. Examples fileg_delay=0.004 ampeg_delay=0.05","title":"Amp delay"},{"location":"opcodes/amp_delay/#examples","text":"fileg_delay=0.004 ampeg_delay=0.05","title":"Examples"},{"location":"opcodes/amp_hold/","text":"During the hold stage, EG output will remain at its maximum value. Examples ampeg_hold=1.5 fileg_hold=0.1","title":"Amp hold"},{"location":"opcodes/amp_hold/#examples","text":"ampeg_hold=1.5 fileg_hold=0.1","title":"Examples"},{"location":"opcodes/amp_keycenter/","text":"Examples amp_keycenter=60 amp_keycenter=48","title":"Amp keycenter"},{"location":"opcodes/amp_keycenter/#examples","text":"amp_keycenter=60 amp_keycenter=48","title":"Examples"},{"location":"opcodes/amp_keytrack/","text":"Examples amp_keytrack=-1.4 amp_keytrack=3","title":"Amp keytrack"},{"location":"opcodes/amp_keytrack/#examples","text":"amp_keytrack=-1.4 amp_keytrack=3","title":"Examples"},{"location":"opcodes/amp_random/","text":"Computed when the note is triggered, remains the same for that region for as long as the region plays. Examples amp_random=10 amp_random=3 volume=-3 amp_random=6 Practical Considerations In ARIA and Cakewalk, amp_random is unipolar. To create variation which can be either negative or positive, this needs to be combined with a fixed volume offset for half the negative value that amp_random is set to. In the rgc sfz player, amp_random is bipolar.","title":"Amp random"},{"location":"opcodes/amp_random/#examples","text":"amp_random=10 amp_random=3 volume=-3 amp_random=6","title":"Examples"},{"location":"opcodes/amp_random/#practical-considerations","text":"In ARIA and Cakewalk, amp_random is unipolar. To create variation which can be either negative or positive, this needs to be combined with a fixed volume offset for half the negative value that amp_random is set to. In the rgc sfz player, amp_random is bipolar.","title":"Practical Considerations"},{"location":"opcodes/amp_release/","text":"Examples ampeg_release=1.34 fileg_release=0.2 In many instruments, ampeg_release will need to be set to avoid the sound cutting off unrealistically quickly when a note ends (unless the instrument uses loop_mode set to one_shot , in which case the entire sample will always play) even if amplifier envelopes are not used otherwise to shape the sound. Also, ampeg_release is used when off_mode is set to normal. Although the spec default is 0.001, ARIA uses a default of 0.03 for smoother default cutoffs. Cakewalk products use 0.001.","title":"Amp release"},{"location":"opcodes/amp_release/#examples","text":"ampeg_release=1.34 fileg_release=0.2 In many instruments, ampeg_release will need to be set to avoid the sound cutting off unrealistically quickly when a note ends (unless the instrument uses loop_mode set to one_shot , in which case the entire sample will always play) even if amplifier envelopes are not used otherwise to shape the sound. Also, ampeg_release is used when off_mode is set to normal. Although the spec default is 0.001, ARIA uses a default of 0.03 for smoother default cutoffs. Cakewalk products use 0.001.","title":"Examples"},{"location":"opcodes/amp_sustain/","text":"Examples ampeg_sustain=40.34 pitcheg_sustain=10(eg type)_sustain","title":"Amp sustain"},{"location":"opcodes/amp_sustain/#examples","text":"ampeg_sustain=40.34 pitcheg_sustain=10(eg type)_sustain","title":"Examples"},{"location":"opcodes/amp_vel2attack/","text":"Examples ampeg_attack=1.2 fileg_attack=0.1 Practical Considerations These are very frequently used, especially with amplifier envelopes. ampeg_attack is the standard \"A\" in the basic ADSR volume envelope. fileg_attack is key to 303-style basses. In ARIA, the SFZ1 envelopes have linear attack (for pitcheg and fileg , probably linear in cents, which won't translate into linear in Hertz). Decay and release stages have a curve which is faster than linear, and it seems to match \"well enough\" with a multiplicatively decreasing curve. The step size should be close to \\(\\mu = \\exp \\left( - \\frac{8.0}{t \\times s} \\right)\\) where \\(t\\) is the decay duration in seconds, and \\(s\\) is the sample rate in Hertz. The envelope \\(x_{n+1}\\) at index \\(n+1\\) is thus computed as \\(x_{n+1} = \\mu \\times x_{n}\\) . Here is a screenshot of a file output using Sforzando, showing the ampeg_envelope shape and its stages.","title":"Amp vel2attack"},{"location":"opcodes/amp_vel2attack/#examples","text":"ampeg_attack=1.2 fileg_attack=0.1","title":"Examples"},{"location":"opcodes/amp_vel2attack/#practical-considerations","text":"These are very frequently used, especially with amplifier envelopes. ampeg_attack is the standard \"A\" in the basic ADSR volume envelope. fileg_attack is key to 303-style basses. In ARIA, the SFZ1 envelopes have linear attack (for pitcheg and fileg , probably linear in cents, which won't translate into linear in Hertz). Decay and release stages have a curve which is faster than linear, and it seems to match \"well enough\" with a multiplicatively decreasing curve. The step size should be close to \\(\\mu = \\exp \\left( - \\frac{8.0}{t \\times s} \\right)\\) where \\(t\\) is the decay duration in seconds, and \\(s\\) is the sample rate in Hertz. The envelope \\(x_{n+1}\\) at index \\(n+1\\) is thus computed as \\(x_{n+1} = \\mu \\times x_{n}\\) . Here is a screenshot of a file output using Sforzando, showing the ampeg_envelope shape and its stages.","title":"Practical Considerations"},{"location":"opcodes/amp_vel2decay/","text":"Examples ampeg_decay=1.5 fileg_decay=0.5 This should normally not be shorter than the corresponding envelope's release time.","title":"Amp vel2decay"},{"location":"opcodes/amp_vel2decay/#examples","text":"ampeg_decay=1.5 fileg_decay=0.5 This should normally not be shorter than the corresponding envelope's release time.","title":"Examples"},{"location":"opcodes/amp_vel2delay/","text":"This is the time elapsed from note on to the start of the Attack stage. If both envelope delay and the general delay or delay_random are used in the same region, the envelope delays start after delay and delay_random have both completed their duration. Examples fileg_delay=0.004 ampeg_delay=0.05","title":"Amp vel2delay"},{"location":"opcodes/amp_vel2delay/#examples","text":"fileg_delay=0.004 ampeg_delay=0.05","title":"Examples"},{"location":"opcodes/amp_vel2hold/","text":"During the hold stage, EG output will remain at its maximum value. Examples ampeg_hold=1.5 fileg_hold=0.1","title":"Amp vel2hold"},{"location":"opcodes/amp_vel2hold/#examples","text":"ampeg_hold=1.5 fileg_hold=0.1","title":"Examples"},{"location":"opcodes/amp_vel2release/","text":"Examples ampeg_release=1.34 fileg_release=0.2 In many instruments, ampeg_release will need to be set to avoid the sound cutting off unrealistically quickly when a note ends (unless the instrument uses loop_mode set to one_shot , in which case the entire sample will always play) even if amplifier envelopes are not used otherwise to shape the sound. Also, ampeg_release is used when off_mode is set to normal. Although the spec default is 0.001, ARIA uses a default of 0.03 for smoother default cutoffs. Cakewalk products use 0.001.","title":"Amp vel2release"},{"location":"opcodes/amp_vel2release/#examples","text":"ampeg_release=1.34 fileg_release=0.2 In many instruments, ampeg_release will need to be set to avoid the sound cutting off unrealistically quickly when a note ends (unless the instrument uses loop_mode set to one_shot , in which case the entire sample will always play) even if amplifier envelopes are not used otherwise to shape the sound. Also, ampeg_release is used when off_mode is set to normal. Although the spec default is 0.001, ARIA uses a default of 0.03 for smoother default cutoffs. Cakewalk products use 0.001.","title":"Examples"},{"location":"opcodes/amp_vel2sustain/","text":"Examples ampeg_sustain=40.34 pitcheg_sustain=10(eg type)_sustain","title":"Amp vel2sustain"},{"location":"opcodes/amp_vel2sustain/#examples","text":"ampeg_sustain=40.34 pitcheg_sustain=10(eg type)_sustain","title":"Examples"},{"location":"opcodes/amp_velcurve_N/","text":"This opcode range allows defining a specific point along the amplifier velocity curve. The value of the opcode indicates the normalized amplitude (0 to 1) for the specified velocity. N can be from 0 to 127. The player will interpolate lineraly between specified opcodes for unspecified ones: amp_velcurve_1=0.2 amp_velcurve_3=0.3 // amp_velcurve_2 is calculated to 0.25 If amp_velcurve_127 is not specified, the player will assign it the value of 1. Examples There are several common ways to use this opcode. One is to reduce the dynamic range so that low-velocity notes will still produce a fairly loud sound. This is similar (but probably not quite identical mathematically) to setting amp_veltrack to less than 100. // linear, compressed dynamic range // amplitude changes from 0.5 to 1 amp_velcurve_1=0.5 It can also be used to set up a specific velocity response. amp_velcurve_1=0.1 amp_velcurve_63=0.25 amp_velcurve_95=0.5 This opcode is also often used with dynamic layers to make each sample play at its full amplitude at the top of its velocity layer, as shown below for a kick drum with four dynamic layers. Note that there's no reason to set amp_velcurve_N values for N below the lovel or above the hivel for a particular region. So, in practice, this often ends up meaning just setting amp_velcurve_N=1 with N being equal to the hivel value for each layer. <region>hivel=31 amp_velcurve_31=1 sample=kick_vl1.wav <region>lovel=32 hivel=63 amp_velcurve_63=1 sample=kick_vl2.wav <region>lovel=64 hivel=95 amp_velcurve_95=1 sample=kick_vl3.wav <region>lovel=96 sample=kick_vl4.wav This could also be combined with the first example so that velocity 1 hits will still be reasonably audible. <region>hivel=31 amp_velcurve_1=0.3 amp_velcurve_31=1 sample=kick_vl1.wav <region>lovel=32 hivel=63 amp_velcurve_63=1 sample=kick_vl2.wav <region>lovel=64 hivel=95 amp_velcurve_95=1 sample=kick_vl3.wav <region>lovel=96 sample=kick_vl4.wav Practical Considerations As a MIDI velocity 0 note is a note-off message, amp_velcurve_0 never actually needs to be set. It just creates a slightly different starting point for one side of the interpolation, compared to setting amp_velcurve_1. By default, amp_velcurve_0 is effectively 0. If amp_velcurve is not set for any N, then amp_velcurve_0 is 0 and amp_velcurve_127 is 1, and the volume for notes with velocity is the same as if amp_velcurve_1=0.007874016. Both amp_velcurve_n and amp_veltrack can be used together, though there's probably more risk of confusion than benefit to doing this. External Links Online curve generator Online curve generator v2 (supports negative values)","title":"amp velcurve N"},{"location":"opcodes/amp_velcurve_N/#examples","text":"There are several common ways to use this opcode. One is to reduce the dynamic range so that low-velocity notes will still produce a fairly loud sound. This is similar (but probably not quite identical mathematically) to setting amp_veltrack to less than 100. // linear, compressed dynamic range // amplitude changes from 0.5 to 1 amp_velcurve_1=0.5 It can also be used to set up a specific velocity response. amp_velcurve_1=0.1 amp_velcurve_63=0.25 amp_velcurve_95=0.5 This opcode is also often used with dynamic layers to make each sample play at its full amplitude at the top of its velocity layer, as shown below for a kick drum with four dynamic layers. Note that there's no reason to set amp_velcurve_N values for N below the lovel or above the hivel for a particular region. So, in practice, this often ends up meaning just setting amp_velcurve_N=1 with N being equal to the hivel value for each layer. <region>hivel=31 amp_velcurve_31=1 sample=kick_vl1.wav <region>lovel=32 hivel=63 amp_velcurve_63=1 sample=kick_vl2.wav <region>lovel=64 hivel=95 amp_velcurve_95=1 sample=kick_vl3.wav <region>lovel=96 sample=kick_vl4.wav This could also be combined with the first example so that velocity 1 hits will still be reasonably audible. <region>hivel=31 amp_velcurve_1=0.3 amp_velcurve_31=1 sample=kick_vl1.wav <region>lovel=32 hivel=63 amp_velcurve_63=1 sample=kick_vl2.wav <region>lovel=64 hivel=95 amp_velcurve_95=1 sample=kick_vl3.wav <region>lovel=96 sample=kick_vl4.wav","title":"Examples"},{"location":"opcodes/amp_velcurve_N/#practical-considerations","text":"As a MIDI velocity 0 note is a note-off message, amp_velcurve_0 never actually needs to be set. It just creates a slightly different starting point for one side of the interpolation, compared to setting amp_velcurve_1. By default, amp_velcurve_0 is effectively 0. If amp_velcurve is not set for any N, then amp_velcurve_0 is 0 and amp_velcurve_127 is 1, and the volume for notes with velocity is the same as if amp_velcurve_1=0.007874016. Both amp_velcurve_n and amp_veltrack can be used together, though there's probably more risk of confusion than benefit to doing this.","title":"Practical Considerations"},{"location":"opcodes/amp_velcurve_N/#external-links","text":"Online curve generator Online curve generator v2 (supports negative values)","title":"External Links"},{"location":"opcodes/amp_veltrack/","text":"With amp_veltrack at the default value of 100, volume is modified by the amount calculated by the following expression, based on incoming velocity. \\[ Gain(v) = 20 * log_{10}[(\\frac{v}{127})^2] dB \\] The amp_velcurve_N opcodes allow overriding the default velocity curve, and are useful for making more complex curves than amp_veltrack allows. Examples amp_veltrack=0 amp_veltrack=100 Allowed values are from -100 (which would make velocity 127 notes silent, and low-velocity notes loud) to 100, but for most practical purposes this paramter is generally set to either 0 or 100.","title":"Amp veltrack"},{"location":"opcodes/amp_veltrack/#examples","text":"amp_veltrack=0 amp_veltrack=100 Allowed values are from -100 (which would make velocity 127 notes silent, and low-velocity notes loud) to 100, but for most practical purposes this paramter is generally set to either 0 or 100.","title":"Examples"},{"location":"opcodes/amp_veltrack_ccN/","text":"With amp_veltrack at the default value of 100, volume is modified by the amount calculated by the following expression, based on incoming velocity. \\[ Gain(v) = 20 * log_{10}[(\\frac{v}{127})^2] dB \\] The amp_velcurve_N opcodes allow overriding the default velocity curve, and are useful for making more complex curves than amp_veltrack allows. Examples amp_veltrack=0 amp_veltrack=100 Allowed values are from -100 (which would make velocity 127 notes silent, and low-velocity notes loud) to 100, but for most practical purposes this paramter is generally set to either 0 or 100.","title":"amp veltrack ccN"},{"location":"opcodes/amp_veltrack_ccN/#examples","text":"amp_veltrack=0 amp_veltrack=100 Allowed values are from -100 (which would make velocity 127 notes silent, and low-velocity notes loud) to 100, but for most practical purposes this paramter is generally set to either 0 or 100.","title":"Examples"},{"location":"opcodes/amp_veltrack_curveccN/","text":"With amp_veltrack at the default value of 100, volume is modified by the amount calculated by the following expression, based on incoming velocity. \\[ Gain(v) = 20 * log_{10}[(\\frac{v}{127})^2] dB \\] The amp_velcurve_N opcodes allow overriding the default velocity curve, and are useful for making more complex curves than amp_veltrack allows. Examples amp_veltrack=0 amp_veltrack=100 Allowed values are from -100 (which would make velocity 127 notes silent, and low-velocity notes loud) to 100, but for most practical purposes this paramter is generally set to either 0 or 100.","title":"amp veltrack curveccN"},{"location":"opcodes/amp_veltrack_curveccN/#examples","text":"amp_veltrack=0 amp_veltrack=100 Allowed values are from -100 (which would make velocity 127 notes silent, and low-velocity notes loud) to 100, but for most practical purposes this paramter is generally set to either 0 or 100.","title":"Examples"},{"location":"opcodes/amp_veltrack_onccN/","text":"With amp_veltrack at the default value of 100, volume is modified by the amount calculated by the following expression, based on incoming velocity. \\[ Gain(v) = 20 * log_{10}[(\\frac{v}{127})^2] dB \\] The amp_velcurve_N opcodes allow overriding the default velocity curve, and are useful for making more complex curves than amp_veltrack allows. Examples amp_veltrack=0 amp_veltrack=100 Allowed values are from -100 (which would make velocity 127 notes silent, and low-velocity notes loud) to 100, but for most practical purposes this paramter is generally set to either 0 or 100.","title":"amp veltrack onccN"},{"location":"opcodes/amp_veltrack_onccN/#examples","text":"amp_veltrack=0 amp_veltrack=100 Allowed values are from -100 (which would make velocity 127 notes silent, and low-velocity notes loud) to 100, but for most practical purposes this paramter is generally set to either 0 or 100.","title":"Examples"},{"location":"opcodes/amp_veltrack_random/","text":"","title":"Amp veltrack random"},{"location":"opcodes/ampeg_attack/","text":"Examples ampeg_attack=1.2 fileg_attack=0.1 Practical Considerations These are very frequently used, especially with amplifier envelopes. ampeg_attack is the standard \"A\" in the basic ADSR volume envelope. fileg_attack is key to 303-style basses. In ARIA, the SFZ1 envelopes have linear attack (for pitcheg and fileg , probably linear in cents, which won't translate into linear in Hertz). Decay and release stages have a curve which is faster than linear, and it seems to match \"well enough\" with a multiplicatively decreasing curve. The step size should be close to \\(\\mu = \\exp \\left( - \\frac{8.0}{t \\times s} \\right)\\) where \\(t\\) is the decay duration in seconds, and \\(s\\) is the sample rate in Hertz. The envelope \\(x_{n+1}\\) at index \\(n+1\\) is thus computed as \\(x_{n+1} = \\mu \\times x_{n}\\) . Here is a screenshot of a file output using Sforzando, showing the ampeg_envelope shape and its stages.","title":"Ampeg attack"},{"location":"opcodes/ampeg_attack/#examples","text":"ampeg_attack=1.2 fileg_attack=0.1","title":"Examples"},{"location":"opcodes/ampeg_attack/#practical-considerations","text":"These are very frequently used, especially with amplifier envelopes. ampeg_attack is the standard \"A\" in the basic ADSR volume envelope. fileg_attack is key to 303-style basses. In ARIA, the SFZ1 envelopes have linear attack (for pitcheg and fileg , probably linear in cents, which won't translate into linear in Hertz). Decay and release stages have a curve which is faster than linear, and it seems to match \"well enough\" with a multiplicatively decreasing curve. The step size should be close to \\(\\mu = \\exp \\left( - \\frac{8.0}{t \\times s} \\right)\\) where \\(t\\) is the decay duration in seconds, and \\(s\\) is the sample rate in Hertz. The envelope \\(x_{n+1}\\) at index \\(n+1\\) is thus computed as \\(x_{n+1} = \\mu \\times x_{n}\\) . Here is a screenshot of a file output using Sforzando, showing the ampeg_envelope shape and its stages.","title":"Practical Considerations"},{"location":"opcodes/ampeg_attack_curveccN/","text":"Examples ampeg_attack=1.2 fileg_attack=0.1 Practical Considerations These are very frequently used, especially with amplifier envelopes. ampeg_attack is the standard \"A\" in the basic ADSR volume envelope. fileg_attack is key to 303-style basses. In ARIA, the SFZ1 envelopes have linear attack (for pitcheg and fileg , probably linear in cents, which won't translate into linear in Hertz). Decay and release stages have a curve which is faster than linear, and it seems to match \"well enough\" with a multiplicatively decreasing curve. The step size should be close to \\(\\mu = \\exp \\left( - \\frac{8.0}{t \\times s} \\right)\\) where \\(t\\) is the decay duration in seconds, and \\(s\\) is the sample rate in Hertz. The envelope \\(x_{n+1}\\) at index \\(n+1\\) is thus computed as \\(x_{n+1} = \\mu \\times x_{n}\\) . Here is a screenshot of a file output using Sforzando, showing the ampeg_envelope shape and its stages.","title":"ampeg attack curveccN"},{"location":"opcodes/ampeg_attack_curveccN/#examples","text":"ampeg_attack=1.2 fileg_attack=0.1","title":"Examples"},{"location":"opcodes/ampeg_attack_curveccN/#practical-considerations","text":"These are very frequently used, especially with amplifier envelopes. ampeg_attack is the standard \"A\" in the basic ADSR volume envelope. fileg_attack is key to 303-style basses. In ARIA, the SFZ1 envelopes have linear attack (for pitcheg and fileg , probably linear in cents, which won't translate into linear in Hertz). Decay and release stages have a curve which is faster than linear, and it seems to match \"well enough\" with a multiplicatively decreasing curve. The step size should be close to \\(\\mu = \\exp \\left( - \\frac{8.0}{t \\times s} \\right)\\) where \\(t\\) is the decay duration in seconds, and \\(s\\) is the sample rate in Hertz. The envelope \\(x_{n+1}\\) at index \\(n+1\\) is thus computed as \\(x_{n+1} = \\mu \\times x_{n}\\) . Here is a screenshot of a file output using Sforzando, showing the ampeg_envelope shape and its stages.","title":"Practical Considerations"},{"location":"opcodes/ampeg_attack_onccN/","text":"Examples ampeg_attack=1.2 fileg_attack=0.1 Practical Considerations These are very frequently used, especially with amplifier envelopes. ampeg_attack is the standard \"A\" in the basic ADSR volume envelope. fileg_attack is key to 303-style basses. In ARIA, the SFZ1 envelopes have linear attack (for pitcheg and fileg , probably linear in cents, which won't translate into linear in Hertz). Decay and release stages have a curve which is faster than linear, and it seems to match \"well enough\" with a multiplicatively decreasing curve. The step size should be close to \\(\\mu = \\exp \\left( - \\frac{8.0}{t \\times s} \\right)\\) where \\(t\\) is the decay duration in seconds, and \\(s\\) is the sample rate in Hertz. The envelope \\(x_{n+1}\\) at index \\(n+1\\) is thus computed as \\(x_{n+1} = \\mu \\times x_{n}\\) . Here is a screenshot of a file output using Sforzando, showing the ampeg_envelope shape and its stages.","title":"ampeg attack onccN"},{"location":"opcodes/ampeg_attack_onccN/#examples","text":"ampeg_attack=1.2 fileg_attack=0.1","title":"Examples"},{"location":"opcodes/ampeg_attack_onccN/#practical-considerations","text":"These are very frequently used, especially with amplifier envelopes. ampeg_attack is the standard \"A\" in the basic ADSR volume envelope. fileg_attack is key to 303-style basses. In ARIA, the SFZ1 envelopes have linear attack (for pitcheg and fileg , probably linear in cents, which won't translate into linear in Hertz). Decay and release stages have a curve which is faster than linear, and it seems to match \"well enough\" with a multiplicatively decreasing curve. The step size should be close to \\(\\mu = \\exp \\left( - \\frac{8.0}{t \\times s} \\right)\\) where \\(t\\) is the decay duration in seconds, and \\(s\\) is the sample rate in Hertz. The envelope \\(x_{n+1}\\) at index \\(n+1\\) is thus computed as \\(x_{n+1} = \\mu \\times x_{n}\\) . Here is a screenshot of a file output using Sforzando, showing the ampeg_envelope shape and its stages.","title":"Practical Considerations"},{"location":"opcodes/ampeg_attack_shape/","text":"0 is linear. Positive values are slower curves (that means the envelope will initially not fade in much, and most of the fade in will happen towards the end of the attack period) and negative values faster (quick initial fade in with the latter part of the attack stage fading in less). Past 10 or -10, there's little difference - at that point, the envelope is practically a horizontal line and a vertical line (if positive) or a vertical line followed by a horizontal line (if negative). Examples ampeg_attack_shape=2.1 ampeg_attack_shape=-3.8 Graphical representations As aid to estimate what the values will do, here some examples. All curves were made at 120bpm with ampeg_attack=1 , note held for 2 seconds. Each vertical line represents 0.5 seconds.","title":"Ampeg attack shape"},{"location":"opcodes/ampeg_attack_shape/#examples","text":"ampeg_attack_shape=2.1 ampeg_attack_shape=-3.8","title":"Examples"},{"location":"opcodes/ampeg_attack_shape/#graphical-representations","text":"As aid to estimate what the values will do, here some examples. All curves were made at 120bpm with ampeg_attack=1 , note held for 2 seconds. Each vertical line represents 0.5 seconds.","title":"Graphical representations"},{"location":"opcodes/ampeg_attackccN/","text":"Examples ampeg_attack=1.2 fileg_attack=0.1 Practical Considerations These are very frequently used, especially with amplifier envelopes. ampeg_attack is the standard \"A\" in the basic ADSR volume envelope. fileg_attack is key to 303-style basses. In ARIA, the SFZ1 envelopes have linear attack (for pitcheg and fileg , probably linear in cents, which won't translate into linear in Hertz). Decay and release stages have a curve which is faster than linear, and it seems to match \"well enough\" with a multiplicatively decreasing curve. The step size should be close to \\(\\mu = \\exp \\left( - \\frac{8.0}{t \\times s} \\right)\\) where \\(t\\) is the decay duration in seconds, and \\(s\\) is the sample rate in Hertz. The envelope \\(x_{n+1}\\) at index \\(n+1\\) is thus computed as \\(x_{n+1} = \\mu \\times x_{n}\\) . Here is a screenshot of a file output using Sforzando, showing the ampeg_envelope shape and its stages.","title":"ampeg attackccN"},{"location":"opcodes/ampeg_attackccN/#examples","text":"ampeg_attack=1.2 fileg_attack=0.1","title":"Examples"},{"location":"opcodes/ampeg_attackccN/#practical-considerations","text":"These are very frequently used, especially with amplifier envelopes. ampeg_attack is the standard \"A\" in the basic ADSR volume envelope. fileg_attack is key to 303-style basses. In ARIA, the SFZ1 envelopes have linear attack (for pitcheg and fileg , probably linear in cents, which won't translate into linear in Hertz). Decay and release stages have a curve which is faster than linear, and it seems to match \"well enough\" with a multiplicatively decreasing curve. The step size should be close to \\(\\mu = \\exp \\left( - \\frac{8.0}{t \\times s} \\right)\\) where \\(t\\) is the decay duration in seconds, and \\(s\\) is the sample rate in Hertz. The envelope \\(x_{n+1}\\) at index \\(n+1\\) is thus computed as \\(x_{n+1} = \\mu \\times x_{n}\\) . Here is a screenshot of a file output using Sforzando, showing the ampeg_envelope shape and its stages.","title":"Practical Considerations"},{"location":"opcodes/ampeg_decay/","text":"Examples ampeg_decay=1.5 fileg_decay=0.5 This should normally not be shorter than the corresponding envelope's release time.","title":"Ampeg decay"},{"location":"opcodes/ampeg_decay/#examples","text":"ampeg_decay=1.5 fileg_decay=0.5 This should normally not be shorter than the corresponding envelope's release time.","title":"Examples"},{"location":"opcodes/ampeg_decay_curveccN/","text":"Examples ampeg_decay=1.5 fileg_decay=0.5 This should normally not be shorter than the corresponding envelope's release time.","title":"ampeg decay curveccN"},{"location":"opcodes/ampeg_decay_curveccN/#examples","text":"ampeg_decay=1.5 fileg_decay=0.5 This should normally not be shorter than the corresponding envelope's release time.","title":"Examples"},{"location":"opcodes/ampeg_decay_onccN/","text":"Examples ampeg_decay=1.5 fileg_decay=0.5 This should normally not be shorter than the corresponding envelope's release time.","title":"ampeg decay onccN"},{"location":"opcodes/ampeg_decay_onccN/#examples","text":"ampeg_decay=1.5 fileg_decay=0.5 This should normally not be shorter than the corresponding envelope's release time.","title":"Examples"},{"location":"opcodes/ampeg_decay_shape/","text":"0 is linear, positive values are slower curves (that means the envelope will initially not decay out much, and most of the decay will happen towards the end of the decay period) and negative values faster (quick initial decay with quiet tail decaying more slowly). Examples ampeg_decay_shape=2.1 ampeg_decay_shape=-3.8 Graphical representations As aid to estimate what the values will do, here some examples. All curves were made at 120bpm with ampeg_decay=1 and ampeg_sustain=1 , note held for 2 seconds. Each vertical line represents 0.5 seconds.","title":"Ampeg decay shape"},{"location":"opcodes/ampeg_decay_shape/#examples","text":"ampeg_decay_shape=2.1 ampeg_decay_shape=-3.8","title":"Examples"},{"location":"opcodes/ampeg_decay_shape/#graphical-representations","text":"As aid to estimate what the values will do, here some examples. All curves were made at 120bpm with ampeg_decay=1 and ampeg_sustain=1 , note held for 2 seconds. Each vertical line represents 0.5 seconds.","title":"Graphical representations"},{"location":"opcodes/ampeg_decay_zero/","text":"When 1, indicates decay time is the time it would take to get from 0dBs to -oo, NOT the time to reach current sustain (as when 0). 1 and 0 must be used, true/false or on/off don't appear to be supported. In other words, under default behavior, the decay slope is fixed, and the higher the sustain level of the envelope, the less time the decay stage will actually take. Changing ampeg_sustain will change the actual duration of the decay stage as well, up to a maximum of the full ampeg_decay value at ampeg_sustain equal to 0. Setting this to 0 will make the decay always happen during the entire time period specified by ampeg_decay , regardless of the current ampeg_sustain level. Examples ampeg_decay_zero=0 ampeg_decay_zero=1","title":"Ampeg decay zero"},{"location":"opcodes/ampeg_decay_zero/#examples","text":"ampeg_decay_zero=0 ampeg_decay_zero=1","title":"Examples"},{"location":"opcodes/ampeg_decayccN/","text":"Examples ampeg_decay=1.5 fileg_decay=0.5 This should normally not be shorter than the corresponding envelope's release time.","title":"ampeg decayccN"},{"location":"opcodes/ampeg_decayccN/#examples","text":"ampeg_decay=1.5 fileg_decay=0.5 This should normally not be shorter than the corresponding envelope's release time.","title":"Examples"},{"location":"opcodes/ampeg_delay/","text":"This is the time elapsed from note on to the start of the Attack stage. If both envelope delay and the general delay or delay_random are used in the same region, the envelope delays start after delay and delay_random have both completed their duration. Examples fileg_delay=0.004 ampeg_delay=0.05","title":"Ampeg delay"},{"location":"opcodes/ampeg_delay/#examples","text":"fileg_delay=0.004 ampeg_delay=0.05","title":"Examples"},{"location":"opcodes/ampeg_delay_curveccN/","text":"This is the time elapsed from note on to the start of the Attack stage. If both envelope delay and the general delay or delay_random are used in the same region, the envelope delays start after delay and delay_random have both completed their duration. Examples fileg_delay=0.004 ampeg_delay=0.05","title":"ampeg delay curveccN"},{"location":"opcodes/ampeg_delay_curveccN/#examples","text":"fileg_delay=0.004 ampeg_delay=0.05","title":"Examples"},{"location":"opcodes/ampeg_delay_onccN/","text":"This is the time elapsed from note on to the start of the Attack stage. If both envelope delay and the general delay or delay_random are used in the same region, the envelope delays start after delay and delay_random have both completed their duration. Examples fileg_delay=0.004 ampeg_delay=0.05","title":"ampeg delay onccN"},{"location":"opcodes/ampeg_delay_onccN/#examples","text":"fileg_delay=0.004 ampeg_delay=0.05","title":"Examples"},{"location":"opcodes/ampeg_delayccN/","text":"This is the time elapsed from note on to the start of the Attack stage. If both envelope delay and the general delay or delay_random are used in the same region, the envelope delays start after delay and delay_random have both completed their duration. Examples fileg_delay=0.004 ampeg_delay=0.05","title":"ampeg delayccN"},{"location":"opcodes/ampeg_delayccN/#examples","text":"fileg_delay=0.004 ampeg_delay=0.05","title":"Examples"},{"location":"opcodes/ampeg_dynamic/","text":"When 1, causes envelope segment durations and sustain level to be recalculated when a MIDI CC message modulating those envelopes is received. When 0, envelope segment durations and sustain level are calculated only at the start of the particular envelope segment. Examples ampeg_dynamic=1 ampeg_dynamic=0","title":"Ampeg dynamic"},{"location":"opcodes/ampeg_dynamic/#examples","text":"ampeg_dynamic=1 ampeg_dynamic=0","title":"Examples"},{"location":"opcodes/ampeg_hold/","text":"During the hold stage, EG output will remain at its maximum value. Examples ampeg_hold=1.5 fileg_hold=0.1","title":"Ampeg hold"},{"location":"opcodes/ampeg_hold/#examples","text":"ampeg_hold=1.5 fileg_hold=0.1","title":"Examples"},{"location":"opcodes/ampeg_hold_curveccN/","text":"During the hold stage, EG output will remain at its maximum value. Examples ampeg_hold=1.5 fileg_hold=0.1","title":"ampeg hold curveccN"},{"location":"opcodes/ampeg_hold_curveccN/#examples","text":"ampeg_hold=1.5 fileg_hold=0.1","title":"Examples"},{"location":"opcodes/ampeg_hold_onccN/","text":"During the hold stage, EG output will remain at its maximum value. Examples ampeg_hold=1.5 fileg_hold=0.1","title":"ampeg hold onccN"},{"location":"opcodes/ampeg_hold_onccN/#examples","text":"ampeg_hold=1.5 fileg_hold=0.1","title":"Examples"},{"location":"opcodes/ampeg_holdccN/","text":"During the hold stage, EG output will remain at its maximum value. Examples ampeg_hold=1.5 fileg_hold=0.1","title":"ampeg holdccN"},{"location":"opcodes/ampeg_holdccN/#examples","text":"ampeg_hold=1.5 fileg_hold=0.1","title":"Examples"},{"location":"opcodes/ampeg_release/","text":"Examples ampeg_release=1.34 fileg_release=0.2 In many instruments, ampeg_release will need to be set to avoid the sound cutting off unrealistically quickly when a note ends (unless the instrument uses loop_mode set to one_shot , in which case the entire sample will always play) even if amplifier envelopes are not used otherwise to shape the sound. Also, ampeg_release is used when off_mode is set to normal. Although the spec default is 0.001, ARIA uses a default of 0.03 for smoother default cutoffs. Cakewalk products use 0.001.","title":"Ampeg release"},{"location":"opcodes/ampeg_release/#examples","text":"ampeg_release=1.34 fileg_release=0.2 In many instruments, ampeg_release will need to be set to avoid the sound cutting off unrealistically quickly when a note ends (unless the instrument uses loop_mode set to one_shot , in which case the entire sample will always play) even if amplifier envelopes are not used otherwise to shape the sound. Also, ampeg_release is used when off_mode is set to normal. Although the spec default is 0.001, ARIA uses a default of 0.03 for smoother default cutoffs. Cakewalk products use 0.001.","title":"Examples"},{"location":"opcodes/ampeg_release_curveccN/","text":"Examples ampeg_release=1.34 fileg_release=0.2 In many instruments, ampeg_release will need to be set to avoid the sound cutting off unrealistically quickly when a note ends (unless the instrument uses loop_mode set to one_shot , in which case the entire sample will always play) even if amplifier envelopes are not used otherwise to shape the sound. Also, ampeg_release is used when off_mode is set to normal. Although the spec default is 0.001, ARIA uses a default of 0.03 for smoother default cutoffs. Cakewalk products use 0.001.","title":"ampeg release curveccN"},{"location":"opcodes/ampeg_release_curveccN/#examples","text":"ampeg_release=1.34 fileg_release=0.2 In many instruments, ampeg_release will need to be set to avoid the sound cutting off unrealistically quickly when a note ends (unless the instrument uses loop_mode set to one_shot , in which case the entire sample will always play) even if amplifier envelopes are not used otherwise to shape the sound. Also, ampeg_release is used when off_mode is set to normal. Although the spec default is 0.001, ARIA uses a default of 0.03 for smoother default cutoffs. Cakewalk products use 0.001.","title":"Examples"},{"location":"opcodes/ampeg_release_onccN/","text":"Examples ampeg_release=1.34 fileg_release=0.2 In many instruments, ampeg_release will need to be set to avoid the sound cutting off unrealistically quickly when a note ends (unless the instrument uses loop_mode set to one_shot , in which case the entire sample will always play) even if amplifier envelopes are not used otherwise to shape the sound. Also, ampeg_release is used when off_mode is set to normal. Although the spec default is 0.001, ARIA uses a default of 0.03 for smoother default cutoffs. Cakewalk products use 0.001.","title":"ampeg release onccN"},{"location":"opcodes/ampeg_release_onccN/#examples","text":"ampeg_release=1.34 fileg_release=0.2 In many instruments, ampeg_release will need to be set to avoid the sound cutting off unrealistically quickly when a note ends (unless the instrument uses loop_mode set to one_shot , in which case the entire sample will always play) even if amplifier envelopes are not used otherwise to shape the sound. Also, ampeg_release is used when off_mode is set to normal. Although the spec default is 0.001, ARIA uses a default of 0.03 for smoother default cutoffs. Cakewalk products use 0.001.","title":"Examples"},{"location":"opcodes/ampeg_release_shape/","text":"0 is linear, positive values are slower curves (that means the envelope will initially not fade out much, and most of the fade will happen towards the end of the release period) and negative values faster (quick initial fadeout with quiet tail fading out more slowly). Examples ampeg_release_shape=2.1 ampeg_release_shape=-3.8","title":"Ampeg release shape"},{"location":"opcodes/ampeg_release_shape/#examples","text":"ampeg_release_shape=2.1 ampeg_release_shape=-3.8","title":"Examples"},{"location":"opcodes/ampeg_release_zero/","text":"When 1, indicates release time is the time it would take to get from 0dBs to -oo (actually -90 dB as implemented in ARIA), NOT the time to get from the current sustain to zero. In other words, under default behavior, the release time is fixed, while setting this to 1 makes the release slope fixed but time will be shorter when sustain level is lower. Examples ampeg_release_zero=1 ampeg_release_zero=0","title":"Ampeg release zero"},{"location":"opcodes/ampeg_release_zero/#examples","text":"ampeg_release_zero=1 ampeg_release_zero=0","title":"Examples"},{"location":"opcodes/ampeg_releaseccN/","text":"Examples ampeg_release=1.34 fileg_release=0.2 In many instruments, ampeg_release will need to be set to avoid the sound cutting off unrealistically quickly when a note ends (unless the instrument uses loop_mode set to one_shot , in which case the entire sample will always play) even if amplifier envelopes are not used otherwise to shape the sound. Also, ampeg_release is used when off_mode is set to normal. Although the spec default is 0.001, ARIA uses a default of 0.03 for smoother default cutoffs. Cakewalk products use 0.001.","title":"ampeg releaseccN"},{"location":"opcodes/ampeg_releaseccN/#examples","text":"ampeg_release=1.34 fileg_release=0.2 In many instruments, ampeg_release will need to be set to avoid the sound cutting off unrealistically quickly when a note ends (unless the instrument uses loop_mode set to one_shot , in which case the entire sample will always play) even if amplifier envelopes are not used otherwise to shape the sound. Also, ampeg_release is used when off_mode is set to normal. Although the spec default is 0.001, ARIA uses a default of 0.03 for smoother default cutoffs. Cakewalk products use 0.001.","title":"Examples"},{"location":"opcodes/ampeg_start/","text":"Examples ampeg_start=20 fileg_start=100 Setting this to 100 should have the same effect as setting the attack time to 0, and adding the attack time to the hold time. Note that in some cases (when the sample starts playing from a point which is not near zero), setting this to a non-zero value for ampeg_start may result in sample playback starting with an audible click.","title":"Ampeg start"},{"location":"opcodes/ampeg_start/#examples","text":"ampeg_start=20 fileg_start=100 Setting this to 100 should have the same effect as setting the attack time to 0, and adding the attack time to the hold time. Note that in some cases (when the sample starts playing from a point which is not near zero), setting this to a non-zero value for ampeg_start may result in sample playback starting with an audible click.","title":"Examples"},{"location":"opcodes/ampeg_start_curveccN/","text":"Examples ampeg_start=20 fileg_start=100 Setting this to 100 should have the same effect as setting the attack time to 0, and adding the attack time to the hold time. Note that in some cases (when the sample starts playing from a point which is not near zero), setting this to a non-zero value for ampeg_start may result in sample playback starting with an audible click.","title":"ampeg start curveccN"},{"location":"opcodes/ampeg_start_curveccN/#examples","text":"ampeg_start=20 fileg_start=100 Setting this to 100 should have the same effect as setting the attack time to 0, and adding the attack time to the hold time. Note that in some cases (when the sample starts playing from a point which is not near zero), setting this to a non-zero value for ampeg_start may result in sample playback starting with an audible click.","title":"Examples"},{"location":"opcodes/ampeg_start_onccN/","text":"Examples ampeg_start=20 fileg_start=100 Setting this to 100 should have the same effect as setting the attack time to 0, and adding the attack time to the hold time. Note that in some cases (when the sample starts playing from a point which is not near zero), setting this to a non-zero value for ampeg_start may result in sample playback starting with an audible click.","title":"ampeg start onccN"},{"location":"opcodes/ampeg_start_onccN/#examples","text":"ampeg_start=20 fileg_start=100 Setting this to 100 should have the same effect as setting the attack time to 0, and adding the attack time to the hold time. Note that in some cases (when the sample starts playing from a point which is not near zero), setting this to a non-zero value for ampeg_start may result in sample playback starting with an audible click.","title":"Examples"},{"location":"opcodes/ampeg_startccN/","text":"Examples ampeg_start=20 fileg_start=100 Setting this to 100 should have the same effect as setting the attack time to 0, and adding the attack time to the hold time. Note that in some cases (when the sample starts playing from a point which is not near zero), setting this to a non-zero value for ampeg_start may result in sample playback starting with an audible click.","title":"ampeg startccN"},{"location":"opcodes/ampeg_startccN/#examples","text":"ampeg_start=20 fileg_start=100 Setting this to 100 should have the same effect as setting the attack time to 0, and adding the attack time to the hold time. Note that in some cases (when the sample starts playing from a point which is not near zero), setting this to a non-zero value for ampeg_start may result in sample playback starting with an audible click.","title":"Examples"},{"location":"opcodes/ampeg_sustain/","text":"Examples ampeg_sustain=40.34 pitcheg_sustain=10(eg type)_sustain","title":"Ampeg sustain"},{"location":"opcodes/ampeg_sustain/#examples","text":"ampeg_sustain=40.34 pitcheg_sustain=10(eg type)_sustain","title":"Examples"},{"location":"opcodes/ampeg_sustain_curveccN/","text":"Examples ampeg_sustain=40.34 pitcheg_sustain=10(eg type)_sustain","title":"ampeg sustain curveccN"},{"location":"opcodes/ampeg_sustain_curveccN/#examples","text":"ampeg_sustain=40.34 pitcheg_sustain=10(eg type)_sustain","title":"Examples"},{"location":"opcodes/ampeg_sustain_onccN/","text":"Examples ampeg_sustain=40.34 pitcheg_sustain=10(eg type)_sustain","title":"ampeg sustain onccN"},{"location":"opcodes/ampeg_sustain_onccN/#examples","text":"ampeg_sustain=40.34 pitcheg_sustain=10(eg type)_sustain","title":"Examples"},{"location":"opcodes/ampeg_sustainccN/","text":"Examples ampeg_sustain=40.34 pitcheg_sustain=10(eg type)_sustain","title":"ampeg sustainccN"},{"location":"opcodes/ampeg_sustainccN/#examples","text":"ampeg_sustain=40.34 pitcheg_sustain=10(eg type)_sustain","title":"Examples"},{"location":"opcodes/ampeg_vel2attack/","text":"Examples ampeg_attack=1.2 fileg_attack=0.1 Practical Considerations These are very frequently used, especially with amplifier envelopes. ampeg_attack is the standard \"A\" in the basic ADSR volume envelope. fileg_attack is key to 303-style basses. In ARIA, the SFZ1 envelopes have linear attack (for pitcheg and fileg , probably linear in cents, which won't translate into linear in Hertz). Decay and release stages have a curve which is faster than linear, and it seems to match \"well enough\" with a multiplicatively decreasing curve. The step size should be close to \\(\\mu = \\exp \\left( - \\frac{8.0}{t \\times s} \\right)\\) where \\(t\\) is the decay duration in seconds, and \\(s\\) is the sample rate in Hertz. The envelope \\(x_{n+1}\\) at index \\(n+1\\) is thus computed as \\(x_{n+1} = \\mu \\times x_{n}\\) . Here is a screenshot of a file output using Sforzando, showing the ampeg_envelope shape and its stages.","title":"Ampeg vel2attack"},{"location":"opcodes/ampeg_vel2attack/#examples","text":"ampeg_attack=1.2 fileg_attack=0.1","title":"Examples"},{"location":"opcodes/ampeg_vel2attack/#practical-considerations","text":"These are very frequently used, especially with amplifier envelopes. ampeg_attack is the standard \"A\" in the basic ADSR volume envelope. fileg_attack is key to 303-style basses. In ARIA, the SFZ1 envelopes have linear attack (for pitcheg and fileg , probably linear in cents, which won't translate into linear in Hertz). Decay and release stages have a curve which is faster than linear, and it seems to match \"well enough\" with a multiplicatively decreasing curve. The step size should be close to \\(\\mu = \\exp \\left( - \\frac{8.0}{t \\times s} \\right)\\) where \\(t\\) is the decay duration in seconds, and \\(s\\) is the sample rate in Hertz. The envelope \\(x_{n+1}\\) at index \\(n+1\\) is thus computed as \\(x_{n+1} = \\mu \\times x_{n}\\) . Here is a screenshot of a file output using Sforzando, showing the ampeg_envelope shape and its stages.","title":"Practical Considerations"},{"location":"opcodes/ampeg_vel2decay/","text":"Examples ampeg_decay=1.5 fileg_decay=0.5 This should normally not be shorter than the corresponding envelope's release time.","title":"Ampeg vel2decay"},{"location":"opcodes/ampeg_vel2decay/#examples","text":"ampeg_decay=1.5 fileg_decay=0.5 This should normally not be shorter than the corresponding envelope's release time.","title":"Examples"},{"location":"opcodes/ampeg_vel2delay/","text":"This is the time elapsed from note on to the start of the Attack stage. If both envelope delay and the general delay or delay_random are used in the same region, the envelope delays start after delay and delay_random have both completed their duration. Examples fileg_delay=0.004 ampeg_delay=0.05","title":"Ampeg vel2delay"},{"location":"opcodes/ampeg_vel2delay/#examples","text":"fileg_delay=0.004 ampeg_delay=0.05","title":"Examples"},{"location":"opcodes/ampeg_vel2hold/","text":"During the hold stage, EG output will remain at its maximum value. Examples ampeg_hold=1.5 fileg_hold=0.1","title":"Ampeg vel2hold"},{"location":"opcodes/ampeg_vel2hold/#examples","text":"ampeg_hold=1.5 fileg_hold=0.1","title":"Examples"},{"location":"opcodes/ampeg_vel2release/","text":"Examples ampeg_release=1.34 fileg_release=0.2 In many instruments, ampeg_release will need to be set to avoid the sound cutting off unrealistically quickly when a note ends (unless the instrument uses loop_mode set to one_shot , in which case the entire sample will always play) even if amplifier envelopes are not used otherwise to shape the sound. Also, ampeg_release is used when off_mode is set to normal. Although the spec default is 0.001, ARIA uses a default of 0.03 for smoother default cutoffs. Cakewalk products use 0.001.","title":"Ampeg vel2release"},{"location":"opcodes/ampeg_vel2release/#examples","text":"ampeg_release=1.34 fileg_release=0.2 In many instruments, ampeg_release will need to be set to avoid the sound cutting off unrealistically quickly when a note ends (unless the instrument uses loop_mode set to one_shot , in which case the entire sample will always play) even if amplifier envelopes are not used otherwise to shape the sound. Also, ampeg_release is used when off_mode is set to normal. Although the spec default is 0.001, ARIA uses a default of 0.03 for smoother default cutoffs. Cakewalk products use 0.001.","title":"Examples"},{"location":"opcodes/ampeg_vel2sustain/","text":"Examples ampeg_sustain=40.34 pitcheg_sustain=10(eg type)_sustain","title":"Ampeg vel2sustain"},{"location":"opcodes/ampeg_vel2sustain/#examples","text":"ampeg_sustain=40.34 pitcheg_sustain=10(eg type)_sustain","title":"Examples"},{"location":"opcodes/amplfo_delay/","text":"Examples pitchlfo_delay=1 amplfo_delay=0.4 This is very useful, as many instruments and vocals don't trigger vibrato immediately when a note starts, but slightly later.","title":"Amplfo delay"},{"location":"opcodes/amplfo_delay/#examples","text":"pitchlfo_delay=1 amplfo_delay=0.4 This is very useful, as many instruments and vocals don't trigger vibrato immediately when a note starts, but slightly later.","title":"Examples"},{"location":"opcodes/amplfo_depth/","text":"Examples amplfo_depth=1 pitchlfo_depth=40 For amplifier LFO, this is measured in decibels and can range from -10 to 10. For pitch and filter LFO, this is measured in cents and can range from -1200 to 1200. Whether these values are negative or positive, the LFO will oscillate both up and down around the center value of the amplitude, pitch or filter cutoff - a negative sign for depth only inverts the phase. For cases where an LFO needs to oscillate only in one direction from the normal value (for example: typical guitar vibrato which only bends the pitch upwards, or saxophone vibrato which only bends the pitch down), an offset to the center pitch value will need to be added using the appropriate opcode such as tune. In SFZ2 LFOs add the ability to set the starting phase, making this much easier.","title":"Amplfo depth"},{"location":"opcodes/amplfo_depth/#examples","text":"amplfo_depth=1 pitchlfo_depth=40 For amplifier LFO, this is measured in decibels and can range from -10 to 10. For pitch and filter LFO, this is measured in cents and can range from -1200 to 1200. Whether these values are negative or positive, the LFO will oscillate both up and down around the center value of the amplitude, pitch or filter cutoff - a negative sign for depth only inverts the phase. For cases where an LFO needs to oscillate only in one direction from the normal value (for example: typical guitar vibrato which only bends the pitch upwards, or saxophone vibrato which only bends the pitch down), an offset to the center pitch value will need to be added using the appropriate opcode such as tune. In SFZ2 LFOs add the ability to set the starting phase, making this much easier.","title":"Examples"},{"location":"opcodes/amplfo_depth_onccN/","text":"Examples amplfo_depth=1 pitchlfo_depth=40 For amplifier LFO, this is measured in decibels and can range from -10 to 10. For pitch and filter LFO, this is measured in cents and can range from -1200 to 1200. Whether these values are negative or positive, the LFO will oscillate both up and down around the center value of the amplitude, pitch or filter cutoff - a negative sign for depth only inverts the phase. For cases where an LFO needs to oscillate only in one direction from the normal value (for example: typical guitar vibrato which only bends the pitch upwards, or saxophone vibrato which only bends the pitch down), an offset to the center pitch value will need to be added using the appropriate opcode such as tune. In SFZ2 LFOs add the ability to set the starting phase, making this much easier.","title":"amplfo depth onccN"},{"location":"opcodes/amplfo_depth_onccN/#examples","text":"amplfo_depth=1 pitchlfo_depth=40 For amplifier LFO, this is measured in decibels and can range from -10 to 10. For pitch and filter LFO, this is measured in cents and can range from -1200 to 1200. Whether these values are negative or positive, the LFO will oscillate both up and down around the center value of the amplitude, pitch or filter cutoff - a negative sign for depth only inverts the phase. For cases where an LFO needs to oscillate only in one direction from the normal value (for example: typical guitar vibrato which only bends the pitch upwards, or saxophone vibrato which only bends the pitch down), an offset to the center pitch value will need to be added using the appropriate opcode such as tune. In SFZ2 LFOs add the ability to set the starting phase, making this much easier.","title":"Examples"},{"location":"opcodes/amplfo_depthccN/","text":"Examples amplfo_depth=1 pitchlfo_depth=40 For amplifier LFO, this is measured in decibels and can range from -10 to 10. For pitch and filter LFO, this is measured in cents and can range from -1200 to 1200. Whether these values are negative or positive, the LFO will oscillate both up and down around the center value of the amplitude, pitch or filter cutoff - a negative sign for depth only inverts the phase. For cases where an LFO needs to oscillate only in one direction from the normal value (for example: typical guitar vibrato which only bends the pitch upwards, or saxophone vibrato which only bends the pitch down), an offset to the center pitch value will need to be added using the appropriate opcode such as tune. In SFZ2 LFOs add the ability to set the starting phase, making this much easier.","title":"amplfo depthccN"},{"location":"opcodes/amplfo_depthccN/#examples","text":"amplfo_depth=1 pitchlfo_depth=40 For amplifier LFO, this is measured in decibels and can range from -10 to 10. For pitch and filter LFO, this is measured in cents and can range from -1200 to 1200. Whether these values are negative or positive, the LFO will oscillate both up and down around the center value of the amplitude, pitch or filter cutoff - a negative sign for depth only inverts the phase. For cases where an LFO needs to oscillate only in one direction from the normal value (for example: typical guitar vibrato which only bends the pitch upwards, or saxophone vibrato which only bends the pitch down), an offset to the center pitch value will need to be added using the appropriate opcode such as tune. In SFZ2 LFOs add the ability to set the starting phase, making this much easier.","title":"Examples"},{"location":"opcodes/amplfo_depthchanaft/","text":"Examples amplfo_depth=1 pitchlfo_depth=40 For amplifier LFO, this is measured in decibels and can range from -10 to 10. For pitch and filter LFO, this is measured in cents and can range from -1200 to 1200. Whether these values are negative or positive, the LFO will oscillate both up and down around the center value of the amplitude, pitch or filter cutoff - a negative sign for depth only inverts the phase. For cases where an LFO needs to oscillate only in one direction from the normal value (for example: typical guitar vibrato which only bends the pitch upwards, or saxophone vibrato which only bends the pitch down), an offset to the center pitch value will need to be added using the appropriate opcode such as tune. In SFZ2 LFOs add the ability to set the starting phase, making this much easier.","title":"Amplfo depthchanaft"},{"location":"opcodes/amplfo_depthchanaft/#examples","text":"amplfo_depth=1 pitchlfo_depth=40 For amplifier LFO, this is measured in decibels and can range from -10 to 10. For pitch and filter LFO, this is measured in cents and can range from -1200 to 1200. Whether these values are negative or positive, the LFO will oscillate both up and down around the center value of the amplitude, pitch or filter cutoff - a negative sign for depth only inverts the phase. For cases where an LFO needs to oscillate only in one direction from the normal value (for example: typical guitar vibrato which only bends the pitch upwards, or saxophone vibrato which only bends the pitch down), an offset to the center pitch value will need to be added using the appropriate opcode such as tune. In SFZ2 LFOs add the ability to set the starting phase, making this much easier.","title":"Examples"},{"location":"opcodes/amplfo_depthpolyaft/","text":"Examples amplfo_depth=1 pitchlfo_depth=40 For amplifier LFO, this is measured in decibels and can range from -10 to 10. For pitch and filter LFO, this is measured in cents and can range from -1200 to 1200. Whether these values are negative or positive, the LFO will oscillate both up and down around the center value of the amplitude, pitch or filter cutoff - a negative sign for depth only inverts the phase. For cases where an LFO needs to oscillate only in one direction from the normal value (for example: typical guitar vibrato which only bends the pitch upwards, or saxophone vibrato which only bends the pitch down), an offset to the center pitch value will need to be added using the appropriate opcode such as tune. In SFZ2 LFOs add the ability to set the starting phase, making this much easier.","title":"Amplfo depthpolyaft"},{"location":"opcodes/amplfo_depthpolyaft/#examples","text":"amplfo_depth=1 pitchlfo_depth=40 For amplifier LFO, this is measured in decibels and can range from -10 to 10. For pitch and filter LFO, this is measured in cents and can range from -1200 to 1200. Whether these values are negative or positive, the LFO will oscillate both up and down around the center value of the amplitude, pitch or filter cutoff - a negative sign for depth only inverts the phase. For cases where an LFO needs to oscillate only in one direction from the normal value (for example: typical guitar vibrato which only bends the pitch upwards, or saxophone vibrato which only bends the pitch down), an offset to the center pitch value will need to be added using the appropriate opcode such as tune. In SFZ2 LFOs add the ability to set the starting phase, making this much easier.","title":"Examples"},{"location":"opcodes/amplfo_fade/","text":"Examples amplfo_fade=1 pitchlfo_fade=0.4 Useful for vibrato which grows in intensity gradually, as commonly performed by bowed string players.","title":"Amplfo fade"},{"location":"opcodes/amplfo_fade/#examples","text":"amplfo_fade=1 pitchlfo_fade=0.4 Useful for vibrato which grows in intensity gradually, as commonly performed by bowed string players.","title":"Examples"},{"location":"opcodes/amplfo_freq/","text":"Examples amplfo_freq=0.4 amplfo_freq=10 Range is 0 to 20 Hertz, according to the SFZ spec, which means audio-rate LFOs, similar to what is found in some classic hardware synthesizers, are not possible. Some players may in fact be able to utilize higher rates, but 20 Hz is the upper limit required by the SFZ specification.","title":"Amplfo freq"},{"location":"opcodes/amplfo_freq/#examples","text":"amplfo_freq=0.4 amplfo_freq=10 Range is 0 to 20 Hertz, according to the SFZ spec, which means audio-rate LFOs, similar to what is found in some classic hardware synthesizers, are not possible. Some players may in fact be able to utilize higher rates, but 20 Hz is the upper limit required by the SFZ specification.","title":"Examples"},{"location":"opcodes/amplfo_freqccN/","text":"Examples amplfo_freq=0.4 amplfo_freq=10 Range is 0 to 20 Hertz, according to the SFZ spec, which means audio-rate LFOs, similar to what is found in some classic hardware synthesizers, are not possible. Some players may in fact be able to utilize higher rates, but 20 Hz is the upper limit required by the SFZ specification.","title":"amplfo freqccN"},{"location":"opcodes/amplfo_freqccN/#examples","text":"amplfo_freq=0.4 amplfo_freq=10 Range is 0 to 20 Hertz, according to the SFZ spec, which means audio-rate LFOs, similar to what is found in some classic hardware synthesizers, are not possible. Some players may in fact be able to utilize higher rates, but 20 Hz is the upper limit required by the SFZ specification.","title":"Examples"},{"location":"opcodes/amplfo_freqchanaft/","text":"Examples amplfo_freq=0.4 amplfo_freq=10 Range is 0 to 20 Hertz, according to the SFZ spec, which means audio-rate LFOs, similar to what is found in some classic hardware synthesizers, are not possible. Some players may in fact be able to utilize higher rates, but 20 Hz is the upper limit required by the SFZ specification.","title":"Amplfo freqchanaft"},{"location":"opcodes/amplfo_freqchanaft/#examples","text":"amplfo_freq=0.4 amplfo_freq=10 Range is 0 to 20 Hertz, according to the SFZ spec, which means audio-rate LFOs, similar to what is found in some classic hardware synthesizers, are not possible. Some players may in fact be able to utilize higher rates, but 20 Hz is the upper limit required by the SFZ specification.","title":"Examples"},{"location":"opcodes/amplfo_freqpolyaft/","text":"Examples amplfo_freq=0.4 amplfo_freq=10 Range is 0 to 20 Hertz, according to the SFZ spec, which means audio-rate LFOs, similar to what is found in some classic hardware synthesizers, are not possible. Some players may in fact be able to utilize higher rates, but 20 Hz is the upper limit required by the SFZ specification.","title":"Amplfo freqpolyaft"},{"location":"opcodes/amplfo_freqpolyaft/#examples","text":"amplfo_freq=0.4 amplfo_freq=10 Range is 0 to 20 Hertz, according to the SFZ spec, which means audio-rate LFOs, similar to what is found in some classic hardware synthesizers, are not possible. Some players may in fact be able to utilize higher rates, but 20 Hz is the upper limit required by the SFZ specification.","title":"Examples"},{"location":"opcodes/amplitude/","text":"100% amplitude meaning no volume change is applied to the sample when played. Can be modulated with MIDI CC. Note: Range in the table below is 0 to 100, but some players such as Aria/Sforazando do not clamp the range. Negative values invert the signal. Examples amplitude=12 amplitude=40 amplitude_oncc108=100 amplitude_oncc50=35 When modulated by MIDI CC, this is a very convenient way to set up a volume control which goes from silence to full volume. See also the \u2039curve\u203a header example.","title":"Amplitude"},{"location":"opcodes/amplitude/#examples","text":"amplitude=12 amplitude=40 amplitude_oncc108=100 amplitude_oncc50=35 When modulated by MIDI CC, this is a very convenient way to set up a volume control which goes from silence to full volume. See also the \u2039curve\u203a header example.","title":"Examples"},{"location":"opcodes/amplitude_ccN/","text":"100% amplitude meaning no volume change is applied to the sample when played. Can be modulated with MIDI CC. Note: Range in the table below is 0 to 100, but some players such as Aria/Sforazando do not clamp the range. Negative values invert the signal. Examples amplitude=12 amplitude=40 amplitude_oncc108=100 amplitude_oncc50=35 When modulated by MIDI CC, this is a very convenient way to set up a volume control which goes from silence to full volume. See also the \u2039curve\u203a header example.","title":"amplitude ccN"},{"location":"opcodes/amplitude_ccN/#examples","text":"amplitude=12 amplitude=40 amplitude_oncc108=100 amplitude_oncc50=35 When modulated by MIDI CC, this is a very convenient way to set up a volume control which goes from silence to full volume. See also the \u2039curve\u203a header example.","title":"Examples"},{"location":"opcodes/amplitude_curveccN/","text":"100% amplitude meaning no volume change is applied to the sample when played. Can be modulated with MIDI CC. Note: Range in the table below is 0 to 100, but some players such as Aria/Sforazando do not clamp the range. Negative values invert the signal. Examples amplitude=12 amplitude=40 amplitude_oncc108=100 amplitude_oncc50=35 When modulated by MIDI CC, this is a very convenient way to set up a volume control which goes from silence to full volume. See also the \u2039curve\u203a header example.","title":"amplitude curveccN"},{"location":"opcodes/amplitude_curveccN/#examples","text":"amplitude=12 amplitude=40 amplitude_oncc108=100 amplitude_oncc50=35 When modulated by MIDI CC, this is a very convenient way to set up a volume control which goes from silence to full volume. See also the \u2039curve\u203a header example.","title":"Examples"},{"location":"opcodes/amplitude_onccN/","text":"100% amplitude meaning no volume change is applied to the sample when played. Can be modulated with MIDI CC. Note: Range in the table below is 0 to 100, but some players such as Aria/Sforazando do not clamp the range. Negative values invert the signal. Examples amplitude=12 amplitude=40 amplitude_oncc108=100 amplitude_oncc50=35 When modulated by MIDI CC, this is a very convenient way to set up a volume control which goes from silence to full volume. See also the \u2039curve\u203a header example.","title":"amplitude onccN"},{"location":"opcodes/amplitude_onccN/#examples","text":"amplitude=12 amplitude=40 amplitude_oncc108=100 amplitude_oncc50=35 When modulated by MIDI CC, this is a very convenient way to set up a volume control which goes from silence to full volume. See also the \u2039curve\u203a header example.","title":"Examples"},{"location":"opcodes/amplitude_smoothccN/","text":"100% amplitude meaning no volume change is applied to the sample when played. Can be modulated with MIDI CC. Note: Range in the table below is 0 to 100, but some players such as Aria/Sforazando do not clamp the range. Negative values invert the signal. Examples amplitude=12 amplitude=40 amplitude_oncc108=100 amplitude_oncc50=35 When modulated by MIDI CC, this is a very convenient way to set up a volume control which goes from silence to full volume. See also the \u2039curve\u203a header example.","title":"amplitude smoothccN"},{"location":"opcodes/amplitude_smoothccN/#examples","text":"amplitude=12 amplitude=40 amplitude_oncc108=100 amplitude_oncc50=35 When modulated by MIDI CC, this is a very convenient way to set up a volume control which goes from silence to full volume. See also the \u2039curve\u203a header example.","title":"Examples"},{"location":"opcodes/apan_depth/","text":"Used under the \u2039effect\u203a header, with type = apan .","title":"Apan depth"},{"location":"opcodes/apan_depth_onccN/","text":"Used under the \u2039effect\u203a header, with type = apan .","title":"apan depth onccN"},{"location":"opcodes/apan_dry/","text":"Used under the \u2039effect\u203a header, with type = apan .","title":"Apan dry"},{"location":"opcodes/apan_dry_onccN/","text":"Used under the \u2039effect\u203a header, with type = apan .","title":"apan dry onccN"},{"location":"opcodes/apan_freq/","text":"Used under the \u2039effect\u203a header, with type = apan .","title":"Apan freq"},{"location":"opcodes/apan_freq_onccN/","text":"Used under the \u2039effect\u203a header, with type = apan .","title":"apan freq onccN"},{"location":"opcodes/apan_phase/","text":"Used under the \u2039effect\u203a header, with type = apan .","title":"Apan phase"},{"location":"opcodes/apan_phase_onccN/","text":"Used under the \u2039effect\u203a header, with type = apan .","title":"apan phase onccN"},{"location":"opcodes/apan_waveform/","text":"Used under the \u2039effect\u203a header, with type = apan .","title":"Apan waveform"},{"location":"opcodes/apan_wet/","text":"Used under the \u2039effect\u203a header, with type = apan .","title":"Apan wet"},{"location":"opcodes/apan_wet_onccN/","text":"Used under the \u2039effect\u203a header, with type = apan .","title":"apan wet onccN"},{"location":"opcodes/bend_down/","text":"If bend_up is set to a positive value, then moving the pitch wheel down will cause the pitch to move up. Examples bend_down=1200 bend_down=100 Positive values of bend_down can be useful with instruments such as zithers or guitars, whose construction makes it practical to bend the pitch of notes up, but not down - this way, moving the pitch wheel in either direction will result in a realistic-sounding upwards bend.","title":"Bend down"},{"location":"opcodes/bend_down/#examples","text":"bend_down=1200 bend_down=100 Positive values of bend_down can be useful with instruments such as zithers or guitars, whose construction makes it practical to bend the pitch of notes up, but not down - this way, moving the pitch wheel in either direction will result in a realistic-sounding upwards bend.","title":"Examples"},{"location":"opcodes/bend_smooth/","text":"Sets the smoothness for pitch bend in milliseconds. Adds inertia to the bends, so fast movements of the controller will have a delayed, smoothed effect, similar to smoothccN . Examples bend_smooth=50 bend_smooth=10","title":"Bend smooth"},{"location":"opcodes/bend_smooth/#examples","text":"bend_smooth=50 bend_smooth=10","title":"Examples"},{"location":"opcodes/bend_step/","text":"Examples bend_step=100 // glissando in semitones bend_step=200 // glissando in whole tones bend_step=1200 // leap an entire octave at a time","title":"Bend step"},{"location":"opcodes/bend_step/#examples","text":"bend_step=100 // glissando in semitones bend_step=200 // glissando in whole tones bend_step=1200 // leap an entire octave at a time","title":"Examples"},{"location":"opcodes/bend_stepdown/","text":"Examples bend_stepdown=100 // glissando in semitones bend_stepdown=200 // glissando in whole tones bend_stepdown=1200 //leap an entire octave at a time","title":"Bend stepdown"},{"location":"opcodes/bend_stepdown/#examples","text":"bend_stepdown=100 // glissando in semitones bend_stepdown=200 // glissando in whole tones bend_stepdown=1200 //leap an entire octave at a time","title":"Examples"},{"location":"opcodes/bend_stepup/","text":"If this is set to the same value as bend_stepdown , the result is the same as using bend_step . Examples bend_stepup=100 // glissando in semitones bend_stepup=200 // glissando in whole tones bend_stepup=1200 //leap an entire octave at a time","title":"Bend stepup"},{"location":"opcodes/bend_stepup/#examples","text":"bend_stepup=100 // glissando in semitones bend_stepup=200 // glissando in whole tones bend_stepup=1200 //leap an entire octave at a time","title":"Examples"},{"location":"opcodes/bend_up/","text":"If bend_up is negative, then moving the pitch wheel up will cause the pitch to move down. Examples bend_up=1200 bend_up=100","title":"Bend up"},{"location":"opcodes/bend_up/#examples","text":"bend_up=1200 bend_up=100","title":"Examples"},{"location":"opcodes/benddown/","text":"If bend_up is set to a positive value, then moving the pitch wheel down will cause the pitch to move up. Examples bend_down=1200 bend_down=100 Positive values of bend_down can be useful with instruments such as zithers or guitars, whose construction makes it practical to bend the pitch of notes up, but not down - this way, moving the pitch wheel in either direction will result in a realistic-sounding upwards bend.","title":"Benddown"},{"location":"opcodes/benddown/#examples","text":"bend_down=1200 bend_down=100 Positive values of bend_down can be useful with instruments such as zithers or guitars, whose construction makes it practical to bend the pitch of notes up, but not down - this way, moving the pitch wheel in either direction will result in a realistic-sounding upwards bend.","title":"Examples"},{"location":"opcodes/bendstep/","text":"Examples bend_step=100 // glissando in semitones bend_step=200 // glissando in whole tones bend_step=1200 // leap an entire octave at a time","title":"Bendstep"},{"location":"opcodes/bendstep/#examples","text":"bend_step=100 // glissando in semitones bend_step=200 // glissando in whole tones bend_step=1200 // leap an entire octave at a time","title":"Examples"},{"location":"opcodes/bendup/","text":"If bend_up is negative, then moving the pitch wheel up will cause the pitch to move down. Examples bend_up=1200 bend_up=100","title":"Bendup"},{"location":"opcodes/bendup/#examples","text":"bend_up=1200 bend_up=100","title":"Examples"},{"location":"opcodes/bitred/","text":"Used under the \u2039effect\u203a header, with type = lofi .","title":"Bitred"},{"location":"opcodes/bitred_curveccN/","text":"Used under the \u2039effect\u203a header, with type = lofi .","title":"bitred curveccN"},{"location":"opcodes/bitred_onccN/","text":"Used under the \u2039effect\u203a header, with type = lofi .","title":"bitred onccN"},{"location":"opcodes/bitred_smoothccN/","text":"Used under the \u2039effect\u203a header, with type = lofi .","title":"bitred smoothccN"},{"location":"opcodes/bitred_stepccN/","text":"Used under the \u2039effect\u203a header, with type = lofi .","title":"bitred stepccN"},{"location":"opcodes/bus/","text":"If not set, or any other value is set, this goes to the main output. Possibly main is the default value. See also: midi ARIA extension header","title":"Bus"},{"location":"opcodes/bypass_onccN/","text":"When the MIDI CC value (0-127) is >= a threshold, the effect plays, otherwise it's disabled. The threshold is determined according to this expression: 64.0 / BypassValue where BypassValue is the opcode's value, strictly positive, interpreted as real number. At BypassValue=1, without doubt the most useful, the effect is off at CC<64 and on at CC>=64.","title":"bypass onccN"},{"location":"opcodes/comp_attack/","text":"Used under the \u2039effect\u203a header, with type = comp .","title":"Comp attack"},{"location":"opcodes/comp_gain/","text":"Used under the \u2039effect\u203a header, with type = comp .","title":"Comp gain"},{"location":"opcodes/comp_ratio/","text":"Used under the \u2039effect\u203a header, with type = comp .","title":"Comp ratio"},{"location":"opcodes/comp_release/","text":"Used under the \u2039effect\u203a header, with type = comp .","title":"Comp release"},{"location":"opcodes/comp_stlink/","text":"Used under the \u2039effect\u203a header, with type = comp .","title":"Comp stlink"},{"location":"opcodes/comp_threshold/","text":"Used under the \u2039effect\u203a header, with type = comp .","title":"Comp threshold"},{"location":"opcodes/count/","text":"If this opcode is specified, the sample will play as many times as defined. Envelope generators will not be retriggered on sample restart. When this opcode is defined, loop_mode is automatically set to one_shot . count=1 will play the sample once, so it's effectively the same as setting loop_mode=one_shot. Examples count=3 count=2 Practical Considerations count=0 behaves differently in different SFZ players. ARIA and sfz.dll treat this the same as if count was not set, and respect loop_mode settings. However, in Rapture and DropZone and possibly other Cakewalk products, count=0 will have the same effect as count=1 - essentially set loop_mode to one_shot and cause the sample to be played once.","title":"Count"},{"location":"opcodes/count/#examples","text":"count=3 count=2","title":"Examples"},{"location":"opcodes/count/#practical-considerations","text":"count=0 behaves differently in different SFZ players. ARIA and sfz.dll treat this the same as if count was not set, and respect loop_mode settings. However, in Rapture and DropZone and possibly other Cakewalk products, count=0 will have the same effect as count=1 - essentially set loop_mode to one_shot and cause the sample to be played once.","title":"Practical Considerations"},{"location":"opcodes/curve_index/","text":"One curve header is used to define each curve. The values for various points along the curve can then be set, from v000 to v127 . The default is v000=0 and v127=1 . Any points along the curve not defined explicitly will be interpolated linearly between points which are defined. There are default built-in curves in ARIA. If no curve is specified for a modulation, curve 0 is used. The built-in ARIA curves are: Default curve (number 0). linear, from 0 to 1 1. bipolar, from -1 to 1 (useful for things such as tuning and panning, used by CC10 panning by default) 2. linear inverted, from 1 to 0 3. bipolar inverted, from 1 to -1 4. concave (used for CC7 volume tracking and amp_veltrack) 5. Xfin power curve 6. Xfout power curve These can be overwritten, but as they are used by the engine for their normal functions, it's safer to use curve_index numbers of 7 and above for custom curves. Curve_index in ARIA can be any integer from 0 to 255. Examples <curve>curve_index=17 v000=0 v095=1 v127=1 <curve>curve_index=18 v000=0 v095=0.5 v127=1 Here's a scenario using one MIDI CC to control the amplitude of two samples along two different curves. <region> amplitude_oncc110=100 amplitude_curvecc110=9 sample=bigger.wav <region> amplitude_oncc110=100 amplitude_curvecc110=10 sample=smaller.wav //The curves for the room ambiences - bigger room first <curve>curve_index=9 v000=0 v063=0 v127=1 <curve>curve_index=10 v000=0 v063=1 v127=0.1 And how to use the default curve 1 to create a tuning control which goes down and up, with the pitch unmodulated when the control is in the middle. pitch_oncc27=100 pitch_curvecc27=1","title":"\u2039curve\u203a"},{"location":"opcodes/curve_index/#examples","text":"<curve>curve_index=17 v000=0 v095=1 v127=1 <curve>curve_index=18 v000=0 v095=0.5 v127=1 Here's a scenario using one MIDI CC to control the amplitude of two samples along two different curves. <region> amplitude_oncc110=100 amplitude_curvecc110=9 sample=bigger.wav <region> amplitude_oncc110=100 amplitude_curvecc110=10 sample=smaller.wav //The curves for the room ambiences - bigger room first <curve>curve_index=9 v000=0 v063=0 v127=1 <curve>curve_index=10 v000=0 v063=1 v127=0.1 And how to use the default curve 1 to create a tuning control which goes down and up, with the pitch unmodulated when the control is in the middle. pitch_oncc27=100 pitch_curvecc27=1","title":"Examples"},{"location":"opcodes/cutoff/","text":"Note that while this is specified in Hertz, filter LFO depths in the SFZ 1 spec are in cents. There are two filters in series - the cutoff frequency of one is controlled by cutoff, that of the second by cutoff2. Examples cutoff=343 cutoff2=1200 cutoff_cc1=1200 cutoff2_chanaft=1200 cutoff2_polyaft=1200 Both filters can be used be used to have both a high-pass and a low-pass filter, like this: cutoff=1200 resonance=6 fil2_type=hpf_2p cutoff2=250 resonance2=3 Practical Considerations Setting cutoff to 0 behaves differently in diffrent players. ARIA/sforzando : filter disabled, oncc disabled rgc sfz : filter off, oncc working Dimension Pro and Rapture : lowest cutoff value, oncc working sfizz : no sound BassMidi : filter off, no oncc support yet","title":"cutoff / cutoff2"},{"location":"opcodes/cutoff/#examples","text":"cutoff=343 cutoff2=1200 cutoff_cc1=1200 cutoff2_chanaft=1200 cutoff2_polyaft=1200 Both filters can be used be used to have both a high-pass and a low-pass filter, like this: cutoff=1200 resonance=6 fil2_type=hpf_2p cutoff2=250 resonance2=3","title":"Examples"},{"location":"opcodes/cutoff/#practical-considerations","text":"Setting cutoff to 0 behaves differently in diffrent players. ARIA/sforzando : filter disabled, oncc disabled rgc sfz : filter off, oncc working Dimension Pro and Rapture : lowest cutoff value, oncc working sfizz : no sound BassMidi : filter off, no oncc support yet","title":"Practical Considerations"},{"location":"opcodes/cutoff2/","text":"Note that while this is specified in Hertz, filter LFO depths in the SFZ 1 spec are in cents. There are two filters in series - the cutoff frequency of one is controlled by cutoff, that of the second by cutoff2. Examples cutoff=343 cutoff2=1200 cutoff_cc1=1200 cutoff2_chanaft=1200 cutoff2_polyaft=1200 Both filters can be used be used to have both a high-pass and a low-pass filter, like this: cutoff=1200 resonance=6 fil2_type=hpf_2p cutoff2=250 resonance2=3 Practical Considerations Setting cutoff to 0 behaves differently in diffrent players. ARIA/sforzando : filter disabled, oncc disabled rgc sfz : filter off, oncc working Dimension Pro and Rapture : lowest cutoff value, oncc working sfizz : no sound BassMidi : filter off, no oncc support yet","title":"cutoff / cutoff2"},{"location":"opcodes/cutoff2/#examples","text":"cutoff=343 cutoff2=1200 cutoff_cc1=1200 cutoff2_chanaft=1200 cutoff2_polyaft=1200 Both filters can be used be used to have both a high-pass and a low-pass filter, like this: cutoff=1200 resonance=6 fil2_type=hpf_2p cutoff2=250 resonance2=3","title":"Examples"},{"location":"opcodes/cutoff2/#practical-considerations","text":"Setting cutoff to 0 behaves differently in diffrent players. ARIA/sforzando : filter disabled, oncc disabled rgc sfz : filter off, oncc working Dimension Pro and Rapture : lowest cutoff value, oncc working sfizz : no sound BassMidi : filter off, no oncc support yet","title":"Practical Considerations"},{"location":"opcodes/cutoff2_ccN/","text":"Note that while this is specified in Hertz, filter LFO depths in the SFZ 1 spec are in cents. There are two filters in series - the cutoff frequency of one is controlled by cutoff, that of the second by cutoff2. Examples cutoff=343 cutoff2=1200 cutoff_cc1=1200 cutoff2_chanaft=1200 cutoff2_polyaft=1200 Both filters can be used be used to have both a high-pass and a low-pass filter, like this: cutoff=1200 resonance=6 fil2_type=hpf_2p cutoff2=250 resonance2=3 Practical Considerations Setting cutoff to 0 behaves differently in diffrent players. ARIA/sforzando : filter disabled, oncc disabled rgc sfz : filter off, oncc working Dimension Pro and Rapture : lowest cutoff value, oncc working sfizz : no sound BassMidi : filter off, no oncc support yet","title":"cutoff / cutoff2"},{"location":"opcodes/cutoff2_ccN/#examples","text":"cutoff=343 cutoff2=1200 cutoff_cc1=1200 cutoff2_chanaft=1200 cutoff2_polyaft=1200 Both filters can be used be used to have both a high-pass and a low-pass filter, like this: cutoff=1200 resonance=6 fil2_type=hpf_2p cutoff2=250 resonance2=3","title":"Examples"},{"location":"opcodes/cutoff2_ccN/#practical-considerations","text":"Setting cutoff to 0 behaves differently in diffrent players. ARIA/sforzando : filter disabled, oncc disabled rgc sfz : filter off, oncc working Dimension Pro and Rapture : lowest cutoff value, oncc working sfizz : no sound BassMidi : filter off, no oncc support yet","title":"Practical Considerations"},{"location":"opcodes/cutoff2_chanaft/","text":"Note that while this is specified in Hertz, filter LFO depths in the SFZ 1 spec are in cents. There are two filters in series - the cutoff frequency of one is controlled by cutoff, that of the second by cutoff2. Examples cutoff=343 cutoff2=1200 cutoff_cc1=1200 cutoff2_chanaft=1200 cutoff2_polyaft=1200 Both filters can be used be used to have both a high-pass and a low-pass filter, like this: cutoff=1200 resonance=6 fil2_type=hpf_2p cutoff2=250 resonance2=3 Practical Considerations Setting cutoff to 0 behaves differently in diffrent players. ARIA/sforzando : filter disabled, oncc disabled rgc sfz : filter off, oncc working Dimension Pro and Rapture : lowest cutoff value, oncc working sfizz : no sound BassMidi : filter off, no oncc support yet","title":"cutoff / cutoff2"},{"location":"opcodes/cutoff2_chanaft/#examples","text":"cutoff=343 cutoff2=1200 cutoff_cc1=1200 cutoff2_chanaft=1200 cutoff2_polyaft=1200 Both filters can be used be used to have both a high-pass and a low-pass filter, like this: cutoff=1200 resonance=6 fil2_type=hpf_2p cutoff2=250 resonance2=3","title":"Examples"},{"location":"opcodes/cutoff2_chanaft/#practical-considerations","text":"Setting cutoff to 0 behaves differently in diffrent players. ARIA/sforzando : filter disabled, oncc disabled rgc sfz : filter off, oncc working Dimension Pro and Rapture : lowest cutoff value, oncc working sfizz : no sound BassMidi : filter off, no oncc support yet","title":"Practical Considerations"},{"location":"opcodes/cutoff2_curveccN/","text":"Note that while this is specified in Hertz, filter LFO depths in the SFZ 1 spec are in cents. There are two filters in series - the cutoff frequency of one is controlled by cutoff, that of the second by cutoff2. Examples cutoff=343 cutoff2=1200 cutoff_cc1=1200 cutoff2_chanaft=1200 cutoff2_polyaft=1200 Both filters can be used be used to have both a high-pass and a low-pass filter, like this: cutoff=1200 resonance=6 fil2_type=hpf_2p cutoff2=250 resonance2=3 Practical Considerations Setting cutoff to 0 behaves differently in diffrent players. ARIA/sforzando : filter disabled, oncc disabled rgc sfz : filter off, oncc working Dimension Pro and Rapture : lowest cutoff value, oncc working sfizz : no sound BassMidi : filter off, no oncc support yet","title":"cutoff / cutoff2"},{"location":"opcodes/cutoff2_curveccN/#examples","text":"cutoff=343 cutoff2=1200 cutoff_cc1=1200 cutoff2_chanaft=1200 cutoff2_polyaft=1200 Both filters can be used be used to have both a high-pass and a low-pass filter, like this: cutoff=1200 resonance=6 fil2_type=hpf_2p cutoff2=250 resonance2=3","title":"Examples"},{"location":"opcodes/cutoff2_curveccN/#practical-considerations","text":"Setting cutoff to 0 behaves differently in diffrent players. ARIA/sforzando : filter disabled, oncc disabled rgc sfz : filter off, oncc working Dimension Pro and Rapture : lowest cutoff value, oncc working sfizz : no sound BassMidi : filter off, no oncc support yet","title":"Practical Considerations"},{"location":"opcodes/cutoff2_onccN/","text":"Note that while this is specified in Hertz, filter LFO depths in the SFZ 1 spec are in cents. There are two filters in series - the cutoff frequency of one is controlled by cutoff, that of the second by cutoff2. Examples cutoff=343 cutoff2=1200 cutoff_cc1=1200 cutoff2_chanaft=1200 cutoff2_polyaft=1200 Both filters can be used be used to have both a high-pass and a low-pass filter, like this: cutoff=1200 resonance=6 fil2_type=hpf_2p cutoff2=250 resonance2=3 Practical Considerations Setting cutoff to 0 behaves differently in diffrent players. ARIA/sforzando : filter disabled, oncc disabled rgc sfz : filter off, oncc working Dimension Pro and Rapture : lowest cutoff value, oncc working sfizz : no sound BassMidi : filter off, no oncc support yet","title":"cutoff / cutoff2"},{"location":"opcodes/cutoff2_onccN/#examples","text":"cutoff=343 cutoff2=1200 cutoff_cc1=1200 cutoff2_chanaft=1200 cutoff2_polyaft=1200 Both filters can be used be used to have both a high-pass and a low-pass filter, like this: cutoff=1200 resonance=6 fil2_type=hpf_2p cutoff2=250 resonance2=3","title":"Examples"},{"location":"opcodes/cutoff2_onccN/#practical-considerations","text":"Setting cutoff to 0 behaves differently in diffrent players. ARIA/sforzando : filter disabled, oncc disabled rgc sfz : filter off, oncc working Dimension Pro and Rapture : lowest cutoff value, oncc working sfizz : no sound BassMidi : filter off, no oncc support yet","title":"Practical Considerations"},{"location":"opcodes/cutoff2_polyaft/","text":"Note that while this is specified in Hertz, filter LFO depths in the SFZ 1 spec are in cents. There are two filters in series - the cutoff frequency of one is controlled by cutoff, that of the second by cutoff2. Examples cutoff=343 cutoff2=1200 cutoff_cc1=1200 cutoff2_chanaft=1200 cutoff2_polyaft=1200 Both filters can be used be used to have both a high-pass and a low-pass filter, like this: cutoff=1200 resonance=6 fil2_type=hpf_2p cutoff2=250 resonance2=3 Practical Considerations Setting cutoff to 0 behaves differently in diffrent players. ARIA/sforzando : filter disabled, oncc disabled rgc sfz : filter off, oncc working Dimension Pro and Rapture : lowest cutoff value, oncc working sfizz : no sound BassMidi : filter off, no oncc support yet","title":"cutoff / cutoff2"},{"location":"opcodes/cutoff2_polyaft/#examples","text":"cutoff=343 cutoff2=1200 cutoff_cc1=1200 cutoff2_chanaft=1200 cutoff2_polyaft=1200 Both filters can be used be used to have both a high-pass and a low-pass filter, like this: cutoff=1200 resonance=6 fil2_type=hpf_2p cutoff2=250 resonance2=3","title":"Examples"},{"location":"opcodes/cutoff2_polyaft/#practical-considerations","text":"Setting cutoff to 0 behaves differently in diffrent players. ARIA/sforzando : filter disabled, oncc disabled rgc sfz : filter off, oncc working Dimension Pro and Rapture : lowest cutoff value, oncc working sfizz : no sound BassMidi : filter off, no oncc support yet","title":"Practical Considerations"},{"location":"opcodes/cutoff2_random/","text":"Computed when the note is triggered, remains the same for that region for as long as the region plays. Examples fil_random=100 fil_random=400 Practical Considerations In ARIA, this is unipolar. In rcg sfz and Cakewalk, this is bipolar.","title":"Cutoff2 random"},{"location":"opcodes/cutoff2_random/#examples","text":"fil_random=100 fil_random=400","title":"Examples"},{"location":"opcodes/cutoff2_random/#practical-considerations","text":"In ARIA, this is unipolar. In rcg sfz and Cakewalk, this is bipolar.","title":"Practical Considerations"},{"location":"opcodes/cutoff2_smoothccN/","text":"Note that while this is specified in Hertz, filter LFO depths in the SFZ 1 spec are in cents. There are two filters in series - the cutoff frequency of one is controlled by cutoff, that of the second by cutoff2. Examples cutoff=343 cutoff2=1200 cutoff_cc1=1200 cutoff2_chanaft=1200 cutoff2_polyaft=1200 Both filters can be used be used to have both a high-pass and a low-pass filter, like this: cutoff=1200 resonance=6 fil2_type=hpf_2p cutoff2=250 resonance2=3 Practical Considerations Setting cutoff to 0 behaves differently in diffrent players. ARIA/sforzando : filter disabled, oncc disabled rgc sfz : filter off, oncc working Dimension Pro and Rapture : lowest cutoff value, oncc working sfizz : no sound BassMidi : filter off, no oncc support yet","title":"cutoff / cutoff2"},{"location":"opcodes/cutoff2_smoothccN/#examples","text":"cutoff=343 cutoff2=1200 cutoff_cc1=1200 cutoff2_chanaft=1200 cutoff2_polyaft=1200 Both filters can be used be used to have both a high-pass and a low-pass filter, like this: cutoff=1200 resonance=6 fil2_type=hpf_2p cutoff2=250 resonance2=3","title":"Examples"},{"location":"opcodes/cutoff2_smoothccN/#practical-considerations","text":"Setting cutoff to 0 behaves differently in diffrent players. ARIA/sforzando : filter disabled, oncc disabled rgc sfz : filter off, oncc working Dimension Pro and Rapture : lowest cutoff value, oncc working sfizz : no sound BassMidi : filter off, no oncc support yet","title":"Practical Considerations"},{"location":"opcodes/cutoff2_stepccN/","text":"Note that while this is specified in Hertz, filter LFO depths in the SFZ 1 spec are in cents. There are two filters in series - the cutoff frequency of one is controlled by cutoff, that of the second by cutoff2. Examples cutoff=343 cutoff2=1200 cutoff_cc1=1200 cutoff2_chanaft=1200 cutoff2_polyaft=1200 Both filters can be used be used to have both a high-pass and a low-pass filter, like this: cutoff=1200 resonance=6 fil2_type=hpf_2p cutoff2=250 resonance2=3 Practical Considerations Setting cutoff to 0 behaves differently in diffrent players. ARIA/sforzando : filter disabled, oncc disabled rgc sfz : filter off, oncc working Dimension Pro and Rapture : lowest cutoff value, oncc working sfizz : no sound BassMidi : filter off, no oncc support yet","title":"cutoff / cutoff2"},{"location":"opcodes/cutoff2_stepccN/#examples","text":"cutoff=343 cutoff2=1200 cutoff_cc1=1200 cutoff2_chanaft=1200 cutoff2_polyaft=1200 Both filters can be used be used to have both a high-pass and a low-pass filter, like this: cutoff=1200 resonance=6 fil2_type=hpf_2p cutoff2=250 resonance2=3","title":"Examples"},{"location":"opcodes/cutoff2_stepccN/#practical-considerations","text":"Setting cutoff to 0 behaves differently in diffrent players. ARIA/sforzando : filter disabled, oncc disabled rgc sfz : filter off, oncc working Dimension Pro and Rapture : lowest cutoff value, oncc working sfizz : no sound BassMidi : filter off, no oncc support yet","title":"Practical Considerations"},{"location":"opcodes/cutoff_ccN/","text":"Note that while this is specified in Hertz, filter LFO depths in the SFZ 1 spec are in cents. There are two filters in series - the cutoff frequency of one is controlled by cutoff, that of the second by cutoff2. Examples cutoff=343 cutoff2=1200 cutoff_cc1=1200 cutoff2_chanaft=1200 cutoff2_polyaft=1200 Both filters can be used be used to have both a high-pass and a low-pass filter, like this: cutoff=1200 resonance=6 fil2_type=hpf_2p cutoff2=250 resonance2=3 Practical Considerations Setting cutoff to 0 behaves differently in diffrent players. ARIA/sforzando : filter disabled, oncc disabled rgc sfz : filter off, oncc working Dimension Pro and Rapture : lowest cutoff value, oncc working sfizz : no sound BassMidi : filter off, no oncc support yet","title":"cutoff / cutoff2"},{"location":"opcodes/cutoff_ccN/#examples","text":"cutoff=343 cutoff2=1200 cutoff_cc1=1200 cutoff2_chanaft=1200 cutoff2_polyaft=1200 Both filters can be used be used to have both a high-pass and a low-pass filter, like this: cutoff=1200 resonance=6 fil2_type=hpf_2p cutoff2=250 resonance2=3","title":"Examples"},{"location":"opcodes/cutoff_ccN/#practical-considerations","text":"Setting cutoff to 0 behaves differently in diffrent players. ARIA/sforzando : filter disabled, oncc disabled rgc sfz : filter off, oncc working Dimension Pro and Rapture : lowest cutoff value, oncc working sfizz : no sound BassMidi : filter off, no oncc support yet","title":"Practical Considerations"},{"location":"opcodes/cutoff_chanaft/","text":"Note that while this is specified in Hertz, filter LFO depths in the SFZ 1 spec are in cents. There are two filters in series - the cutoff frequency of one is controlled by cutoff, that of the second by cutoff2. Examples cutoff=343 cutoff2=1200 cutoff_cc1=1200 cutoff2_chanaft=1200 cutoff2_polyaft=1200 Both filters can be used be used to have both a high-pass and a low-pass filter, like this: cutoff=1200 resonance=6 fil2_type=hpf_2p cutoff2=250 resonance2=3 Practical Considerations Setting cutoff to 0 behaves differently in diffrent players. ARIA/sforzando : filter disabled, oncc disabled rgc sfz : filter off, oncc working Dimension Pro and Rapture : lowest cutoff value, oncc working sfizz : no sound BassMidi : filter off, no oncc support yet","title":"cutoff / cutoff2"},{"location":"opcodes/cutoff_chanaft/#examples","text":"cutoff=343 cutoff2=1200 cutoff_cc1=1200 cutoff2_chanaft=1200 cutoff2_polyaft=1200 Both filters can be used be used to have both a high-pass and a low-pass filter, like this: cutoff=1200 resonance=6 fil2_type=hpf_2p cutoff2=250 resonance2=3","title":"Examples"},{"location":"opcodes/cutoff_chanaft/#practical-considerations","text":"Setting cutoff to 0 behaves differently in diffrent players. ARIA/sforzando : filter disabled, oncc disabled rgc sfz : filter off, oncc working Dimension Pro and Rapture : lowest cutoff value, oncc working sfizz : no sound BassMidi : filter off, no oncc support yet","title":"Practical Considerations"},{"location":"opcodes/cutoff_curveccN/","text":"Note that while this is specified in Hertz, filter LFO depths in the SFZ 1 spec are in cents. There are two filters in series - the cutoff frequency of one is controlled by cutoff, that of the second by cutoff2. Examples cutoff=343 cutoff2=1200 cutoff_cc1=1200 cutoff2_chanaft=1200 cutoff2_polyaft=1200 Both filters can be used be used to have both a high-pass and a low-pass filter, like this: cutoff=1200 resonance=6 fil2_type=hpf_2p cutoff2=250 resonance2=3 Practical Considerations Setting cutoff to 0 behaves differently in diffrent players. ARIA/sforzando : filter disabled, oncc disabled rgc sfz : filter off, oncc working Dimension Pro and Rapture : lowest cutoff value, oncc working sfizz : no sound BassMidi : filter off, no oncc support yet","title":"cutoff / cutoff2"},{"location":"opcodes/cutoff_curveccN/#examples","text":"cutoff=343 cutoff2=1200 cutoff_cc1=1200 cutoff2_chanaft=1200 cutoff2_polyaft=1200 Both filters can be used be used to have both a high-pass and a low-pass filter, like this: cutoff=1200 resonance=6 fil2_type=hpf_2p cutoff2=250 resonance2=3","title":"Examples"},{"location":"opcodes/cutoff_curveccN/#practical-considerations","text":"Setting cutoff to 0 behaves differently in diffrent players. ARIA/sforzando : filter disabled, oncc disabled rgc sfz : filter off, oncc working Dimension Pro and Rapture : lowest cutoff value, oncc working sfizz : no sound BassMidi : filter off, no oncc support yet","title":"Practical Considerations"},{"location":"opcodes/cutoff_onccN/","text":"Note that while this is specified in Hertz, filter LFO depths in the SFZ 1 spec are in cents. There are two filters in series - the cutoff frequency of one is controlled by cutoff, that of the second by cutoff2. Examples cutoff=343 cutoff2=1200 cutoff_cc1=1200 cutoff2_chanaft=1200 cutoff2_polyaft=1200 Both filters can be used be used to have both a high-pass and a low-pass filter, like this: cutoff=1200 resonance=6 fil2_type=hpf_2p cutoff2=250 resonance2=3 Practical Considerations Setting cutoff to 0 behaves differently in diffrent players. ARIA/sforzando : filter disabled, oncc disabled rgc sfz : filter off, oncc working Dimension Pro and Rapture : lowest cutoff value, oncc working sfizz : no sound BassMidi : filter off, no oncc support yet","title":"cutoff / cutoff2"},{"location":"opcodes/cutoff_onccN/#examples","text":"cutoff=343 cutoff2=1200 cutoff_cc1=1200 cutoff2_chanaft=1200 cutoff2_polyaft=1200 Both filters can be used be used to have both a high-pass and a low-pass filter, like this: cutoff=1200 resonance=6 fil2_type=hpf_2p cutoff2=250 resonance2=3","title":"Examples"},{"location":"opcodes/cutoff_onccN/#practical-considerations","text":"Setting cutoff to 0 behaves differently in diffrent players. ARIA/sforzando : filter disabled, oncc disabled rgc sfz : filter off, oncc working Dimension Pro and Rapture : lowest cutoff value, oncc working sfizz : no sound BassMidi : filter off, no oncc support yet","title":"Practical Considerations"},{"location":"opcodes/cutoff_polyaft/","text":"Note that while this is specified in Hertz, filter LFO depths in the SFZ 1 spec are in cents. There are two filters in series - the cutoff frequency of one is controlled by cutoff, that of the second by cutoff2. Examples cutoff=343 cutoff2=1200 cutoff_cc1=1200 cutoff2_chanaft=1200 cutoff2_polyaft=1200 Both filters can be used be used to have both a high-pass and a low-pass filter, like this: cutoff=1200 resonance=6 fil2_type=hpf_2p cutoff2=250 resonance2=3 Practical Considerations Setting cutoff to 0 behaves differently in diffrent players. ARIA/sforzando : filter disabled, oncc disabled rgc sfz : filter off, oncc working Dimension Pro and Rapture : lowest cutoff value, oncc working sfizz : no sound BassMidi : filter off, no oncc support yet","title":"cutoff / cutoff2"},{"location":"opcodes/cutoff_polyaft/#examples","text":"cutoff=343 cutoff2=1200 cutoff_cc1=1200 cutoff2_chanaft=1200 cutoff2_polyaft=1200 Both filters can be used be used to have both a high-pass and a low-pass filter, like this: cutoff=1200 resonance=6 fil2_type=hpf_2p cutoff2=250 resonance2=3","title":"Examples"},{"location":"opcodes/cutoff_polyaft/#practical-considerations","text":"Setting cutoff to 0 behaves differently in diffrent players. ARIA/sforzando : filter disabled, oncc disabled rgc sfz : filter off, oncc working Dimension Pro and Rapture : lowest cutoff value, oncc working sfizz : no sound BassMidi : filter off, no oncc support yet","title":"Practical Considerations"},{"location":"opcodes/cutoff_random/","text":"Computed when the note is triggered, remains the same for that region for as long as the region plays. Examples fil_random=100 fil_random=400 Practical Considerations In ARIA, this is unipolar. In rcg sfz and Cakewalk, this is bipolar.","title":"Cutoff random"},{"location":"opcodes/cutoff_random/#examples","text":"fil_random=100 fil_random=400","title":"Examples"},{"location":"opcodes/cutoff_random/#practical-considerations","text":"In ARIA, this is unipolar. In rcg sfz and Cakewalk, this is bipolar.","title":"Practical Considerations"},{"location":"opcodes/cutoff_smoothccN/","text":"Note that while this is specified in Hertz, filter LFO depths in the SFZ 1 spec are in cents. There are two filters in series - the cutoff frequency of one is controlled by cutoff, that of the second by cutoff2. Examples cutoff=343 cutoff2=1200 cutoff_cc1=1200 cutoff2_chanaft=1200 cutoff2_polyaft=1200 Both filters can be used be used to have both a high-pass and a low-pass filter, like this: cutoff=1200 resonance=6 fil2_type=hpf_2p cutoff2=250 resonance2=3 Practical Considerations Setting cutoff to 0 behaves differently in diffrent players. ARIA/sforzando : filter disabled, oncc disabled rgc sfz : filter off, oncc working Dimension Pro and Rapture : lowest cutoff value, oncc working sfizz : no sound BassMidi : filter off, no oncc support yet","title":"cutoff / cutoff2"},{"location":"opcodes/cutoff_smoothccN/#examples","text":"cutoff=343 cutoff2=1200 cutoff_cc1=1200 cutoff2_chanaft=1200 cutoff2_polyaft=1200 Both filters can be used be used to have both a high-pass and a low-pass filter, like this: cutoff=1200 resonance=6 fil2_type=hpf_2p cutoff2=250 resonance2=3","title":"Examples"},{"location":"opcodes/cutoff_smoothccN/#practical-considerations","text":"Setting cutoff to 0 behaves differently in diffrent players. ARIA/sforzando : filter disabled, oncc disabled rgc sfz : filter off, oncc working Dimension Pro and Rapture : lowest cutoff value, oncc working sfizz : no sound BassMidi : filter off, no oncc support yet","title":"Practical Considerations"},{"location":"opcodes/cutoff_stepccN/","text":"Note that while this is specified in Hertz, filter LFO depths in the SFZ 1 spec are in cents. There are two filters in series - the cutoff frequency of one is controlled by cutoff, that of the second by cutoff2. Examples cutoff=343 cutoff2=1200 cutoff_cc1=1200 cutoff2_chanaft=1200 cutoff2_polyaft=1200 Both filters can be used be used to have both a high-pass and a low-pass filter, like this: cutoff=1200 resonance=6 fil2_type=hpf_2p cutoff2=250 resonance2=3 Practical Considerations Setting cutoff to 0 behaves differently in diffrent players. ARIA/sforzando : filter disabled, oncc disabled rgc sfz : filter off, oncc working Dimension Pro and Rapture : lowest cutoff value, oncc working sfizz : no sound BassMidi : filter off, no oncc support yet","title":"cutoff / cutoff2"},{"location":"opcodes/cutoff_stepccN/#examples","text":"cutoff=343 cutoff2=1200 cutoff_cc1=1200 cutoff2_chanaft=1200 cutoff2_polyaft=1200 Both filters can be used be used to have both a high-pass and a low-pass filter, like this: cutoff=1200 resonance=6 fil2_type=hpf_2p cutoff2=250 resonance2=3","title":"Examples"},{"location":"opcodes/cutoff_stepccN/#practical-considerations","text":"Setting cutoff to 0 behaves differently in diffrent players. ARIA/sforzando : filter disabled, oncc disabled rgc sfz : filter off, oncc working Dimension Pro and Rapture : lowest cutoff value, oncc working sfizz : no sound BassMidi : filter off, no oncc support yet","title":"Practical Considerations"},{"location":"opcodes/decim/","text":"Used under the \u2039effect\u203a header, with type = lofi .","title":"Decim"},{"location":"opcodes/decim_curveccN/","text":"Used under the \u2039effect\u203a header, with type = lofi .","title":"decim curveccN"},{"location":"opcodes/decim_onccN/","text":"Used under the \u2039effect\u203a header, with type = lofi .","title":"decim onccN"},{"location":"opcodes/decim_smoothccN/","text":"Used under the \u2039effect\u203a header, with type = lofi .","title":"decim smoothccN"},{"location":"opcodes/decim_stepccN/","text":"Used under the \u2039effect\u203a header, with type = lofi .","title":"decim stepccN"},{"location":"opcodes/default_path/","text":"Default path under which the samples should be found. Can also be used as a general prefix for samples, not just a path prefix. At least in ARIA this is combined with the path given in the sample opcode, so either default_path should have a trailing slash, or sample should have a leading slash so when concatenated they will become a valid file path. Cakewalk products only allow relative path. ARIA, Bassmidi and sfizz allow either absolute or relative paths. Used under the \u2039 control \u203a header. In Cakewalk products, a new control header does not reset the path. In ARIA default_path gets reset by a new control header. Whether settings other than default_path should also be reset by a new control header is not entirely clear. As implemented in ARIA, a new control header resets default_path only and not other control settings, and this does not seem unreasonable. Examples default_path=../Samples/ default_path=D:/TEST/Count_0_10/","title":"Default path"},{"location":"opcodes/default_path/#examples","text":"default_path=../Samples/ default_path=D:/TEST/Count_0_10/","title":"Examples"},{"location":"opcodes/define/","text":"Variable names start with the $ character. Example #define $KICKKEY 36 #define $LOWEBENDT 507 The defined variables can then be used like this: <control> #define $KICKKEY 36 #define $SNAREKEY 38 #define $HATKEY 42 <region>key=$KICKKEY sample=kick.wav <region>key=$SNAREKEY sample=snare.wav <region>key=$HATKEY sample=closedhat.wav This can be used to make an instrument easier to configure - for example, to change key maps, MIDI CC assignments, pitch bend ranges etc. which can then be used repeatedly in the SFZ file, but can be easily changed just by editing their #define value in one place. Using #define as a constant with a single value thorughout an instrument works easily. Defining the same variable to have multiple values at different points in the same instrument, however, requires care. The following does not work well in ARIA/Sforzando, assuming that B.sfz uses MYVAR : #define $MYVAR cc12 #include B.sfz #define $MYVAR cc13 #include B.sfz However, a workaround there is to use #include to put each set of #define statement with different values in a separate file. In simple tests, that has been successful.","title":"Define"},{"location":"opcodes/define/#example","text":"#define $KICKKEY 36 #define $LOWEBENDT 507 The defined variables can then be used like this: <control> #define $KICKKEY 36 #define $SNAREKEY 38 #define $HATKEY 42 <region>key=$KICKKEY sample=kick.wav <region>key=$SNAREKEY sample=snare.wav <region>key=$HATKEY sample=closedhat.wav This can be used to make an instrument easier to configure - for example, to change key maps, MIDI CC assignments, pitch bend ranges etc. which can then be used repeatedly in the SFZ file, but can be easily changed just by editing their #define value in one place. Using #define as a constant with a single value thorughout an instrument works easily. Defining the same variable to have multiple values at different points in the same instrument, however, requires care. The following does not work well in ARIA/Sforzando, assuming that B.sfz uses MYVAR : #define $MYVAR cc12 #include B.sfz #define $MYVAR cc13 #include B.sfz However, a workaround there is to use #include to put each set of #define statement with different values in a separate file. In simple tests, that has been successful.","title":"Example"},{"location":"opcodes/delay/","text":"If a delay value is specified, the region playback will be postponed for the specified time. If the region receives a note-off message before delay time, the region won't play. Sample playback and all envelope generators' delay stage will start counting after region delay time - this is the core difference between this and ampeg_delay . Examples delay=1 delay=0.2 Example uses: delaying some regions in a strum or a flam; delaying regions to emulate more distant microphone positions. Practical Considerations In ARIA, if loop_mode is set to one_shot , the region will play regardless of whether a note-off message is received or not.","title":"Delay"},{"location":"opcodes/delay/#examples","text":"delay=1 delay=0.2 Example uses: delaying some regions in a strum or a flam; delaying regions to emulate more distant microphone positions.","title":"Examples"},{"location":"opcodes/delay/#practical-considerations","text":"In ARIA, if loop_mode is set to one_shot , the region will play regardless of whether a note-off message is received or not.","title":"Practical Considerations"},{"location":"opcodes/delay_beats/","text":"Used in Cakewalk Dimension Pro and DropZone, alongside stop_beats , to play slices of loops at specific points in the bar. Examples delay_beats=1 delay_beats=2.25 stop_beats=3 delay_beats=25.9922 stop_beats=26.0964 Practical Considerations In ARIA this opcode can be used, but every region uses up a polyphony voice, and therefore raising polyphony to MAX is recommended for sequences beyond a very short length.","title":"Delay beats"},{"location":"opcodes/delay_beats/#examples","text":"delay_beats=1 delay_beats=2.25 stop_beats=3 delay_beats=25.9922 stop_beats=26.0964","title":"Examples"},{"location":"opcodes/delay_beats/#practical-considerations","text":"In ARIA this opcode can be used, but every region uses up a polyphony voice, and therefore raising polyphony to MAX is recommended for sequences beyond a very short length.","title":"Practical Considerations"},{"location":"opcodes/delay_beats_curveccN/","text":"Used in Cakewalk Dimension Pro and DropZone, alongside stop_beats , to play slices of loops at specific points in the bar. Examples delay_beats=1 delay_beats=2.25 stop_beats=3 delay_beats=25.9922 stop_beats=26.0964 Practical Considerations In ARIA this opcode can be used, but every region uses up a polyphony voice, and therefore raising polyphony to MAX is recommended for sequences beyond a very short length.","title":"delay beats curveccN"},{"location":"opcodes/delay_beats_curveccN/#examples","text":"delay_beats=1 delay_beats=2.25 stop_beats=3 delay_beats=25.9922 stop_beats=26.0964","title":"Examples"},{"location":"opcodes/delay_beats_curveccN/#practical-considerations","text":"In ARIA this opcode can be used, but every region uses up a polyphony voice, and therefore raising polyphony to MAX is recommended for sequences beyond a very short length.","title":"Practical Considerations"},{"location":"opcodes/delay_beats_onccN/","text":"Used in Cakewalk Dimension Pro and DropZone, alongside stop_beats , to play slices of loops at specific points in the bar. Examples delay_beats=1 delay_beats=2.25 stop_beats=3 delay_beats=25.9922 stop_beats=26.0964 Practical Considerations In ARIA this opcode can be used, but every region uses up a polyphony voice, and therefore raising polyphony to MAX is recommended for sequences beyond a very short length.","title":"delay beats onccN"},{"location":"opcodes/delay_beats_onccN/#examples","text":"delay_beats=1 delay_beats=2.25 stop_beats=3 delay_beats=25.9922 stop_beats=26.0964","title":"Examples"},{"location":"opcodes/delay_beats_onccN/#practical-considerations","text":"In ARIA this opcode can be used, but every region uses up a polyphony voice, and therefore raising polyphony to MAX is recommended for sequences beyond a very short length.","title":"Practical Considerations"},{"location":"opcodes/delay_beats_random/","text":"","title":"Delay beats random"},{"location":"opcodes/delay_ccN/","text":"If a delay value is specified, the region playback will be postponed for the specified time. If the region receives a note-off message before delay time, the region won't play. Sample playback and all envelope generators' delay stage will start counting after region delay time - this is the core difference between this and ampeg_delay . Examples delay=1 delay=0.2 Example uses: delaying some regions in a strum or a flam; delaying regions to emulate more distant microphone positions. Practical Considerations In ARIA, if loop_mode is set to one_shot , the region will play regardless of whether a note-off message is received or not.","title":"delay ccN"},{"location":"opcodes/delay_ccN/#examples","text":"delay=1 delay=0.2 Example uses: delaying some regions in a strum or a flam; delaying regions to emulate more distant microphone positions.","title":"Examples"},{"location":"opcodes/delay_ccN/#practical-considerations","text":"In ARIA, if loop_mode is set to one_shot , the region will play regardless of whether a note-off message is received or not.","title":"Practical Considerations"},{"location":"opcodes/delay_curveccN/","text":"If a delay value is specified, the region playback will be postponed for the specified time. If the region receives a note-off message before delay time, the region won't play. Sample playback and all envelope generators' delay stage will start counting after region delay time - this is the core difference between this and ampeg_delay . Examples delay=1 delay=0.2 Example uses: delaying some regions in a strum or a flam; delaying regions to emulate more distant microphone positions. Practical Considerations In ARIA, if loop_mode is set to one_shot , the region will play regardless of whether a note-off message is received or not.","title":"delay curveccN"},{"location":"opcodes/delay_curveccN/#examples","text":"delay=1 delay=0.2 Example uses: delaying some regions in a strum or a flam; delaying regions to emulate more distant microphone positions.","title":"Examples"},{"location":"opcodes/delay_curveccN/#practical-considerations","text":"In ARIA, if loop_mode is set to one_shot , the region will play regardless of whether a note-off message is received or not.","title":"Practical Considerations"},{"location":"opcodes/delay_cutoff/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"Delay cutoff"},{"location":"opcodes/delay_cutoff_onccN/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"delay cutoff onccN"},{"location":"opcodes/delay_damphi/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"delay_damplo / delay_damphi"},{"location":"opcodes/delay_damphi_onccN/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"delay_damplo / delay_damphi"},{"location":"opcodes/delay_damplo/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"delay_damplo / delay_damphi"},{"location":"opcodes/delay_damplo_onccN/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"delay_damplo / delay_damphi"},{"location":"opcodes/delay_dry/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"Delay dry"},{"location":"opcodes/delay_dry_onccN/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"delay dry onccN"},{"location":"opcodes/delay_feedback/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"Delay feedback"},{"location":"opcodes/delay_feedback_onccN/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"delay feedback onccN"},{"location":"opcodes/delay_filter/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"Delay filter"},{"location":"opcodes/delay_input/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"Delay input"},{"location":"opcodes/delay_input_onccN/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"delay input onccN"},{"location":"opcodes/delay_levelc/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"Delay levelc"},{"location":"opcodes/delay_levell/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"Delay levell"},{"location":"opcodes/delay_levelr/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"Delay levelr"},{"location":"opcodes/delay_lfofreq/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"Delay lfofreq"},{"location":"opcodes/delay_lfofreq_onccN/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"delay lfofreq onccN"},{"location":"opcodes/delay_moddepth/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"Delay moddepth"},{"location":"opcodes/delay_moddepth_onccN/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"delay moddepth onccN"},{"location":"opcodes/delay_mode/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"Delay mode"},{"location":"opcodes/delay_onccN/","text":"If a delay value is specified, the region playback will be postponed for the specified time. If the region receives a note-off message before delay time, the region won't play. Sample playback and all envelope generators' delay stage will start counting after region delay time - this is the core difference between this and ampeg_delay . Examples delay=1 delay=0.2 Example uses: delaying some regions in a strum or a flam; delaying regions to emulate more distant microphone positions. Practical Considerations In ARIA, if loop_mode is set to one_shot , the region will play regardless of whether a note-off message is received or not.","title":"delay onccN"},{"location":"opcodes/delay_onccN/#examples","text":"delay=1 delay=0.2 Example uses: delaying some regions in a strum or a flam; delaying regions to emulate more distant microphone positions.","title":"Examples"},{"location":"opcodes/delay_onccN/#practical-considerations","text":"In ARIA, if loop_mode is set to one_shot , the region will play regardless of whether a note-off message is received or not.","title":"Practical Considerations"},{"location":"opcodes/delay_panc/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"Delay panc"},{"location":"opcodes/delay_panc_onccN/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"delay panc onccN"},{"location":"opcodes/delay_panl/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"Delay panl"},{"location":"opcodes/delay_panl_onccN/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"delay panl onccN"},{"location":"opcodes/delay_panr/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"Delay panr"},{"location":"opcodes/delay_panr_onccN/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"delay panr onccN"},{"location":"opcodes/delay_random/","text":"If the region receives a note-off message before delay time, the region won't play, unless loop_mode is set to one_shot , which will play the region in ARIA. Similar to delay in general. Computed when the note is triggered. Examples delay_random=1 delay_random=0.2 Practical Considerations In ARIA, Cakewalk and rcg sfz, this is unipolar.","title":"Delay random"},{"location":"opcodes/delay_random/#examples","text":"delay_random=1 delay_random=0.2","title":"Examples"},{"location":"opcodes/delay_random/#practical-considerations","text":"In ARIA, Cakewalk and rcg sfz, this is unipolar.","title":"Practical Considerations"},{"location":"opcodes/delay_resonance/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"Delay resonance"},{"location":"opcodes/delay_resonance_onccN/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"delay resonance onccN"},{"location":"opcodes/delay_samples/","text":"If the region receives a note-off message before delay time, the region won\u2019t play. Similar to delay , but measured in samples rather than seconds.","title":"Delay samples"},{"location":"opcodes/delay_samples_onccN/","text":"If the region receives a note-off message before delay time, the region won\u2019t play. Similar to delay , but measured in samples rather than seconds.","title":"delay samples onccN"},{"location":"opcodes/delay_spread/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"Delay spread"},{"location":"opcodes/delay_spread_onccN/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"delay spread onccN"},{"location":"opcodes/delay_syncc_onccN/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"delay syncc onccN"},{"location":"opcodes/delay_syncl_onccN/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"delay syncl onccN"},{"location":"opcodes/delay_syncr_onccN/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"delay syncr onccN"},{"location":"opcodes/delay_time_tap/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"Delay time tap"},{"location":"opcodes/delay_timec/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"Delay timec"},{"location":"opcodes/delay_timec_onccN/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"delay timec onccN"},{"location":"opcodes/delay_timel/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"Delay timel"},{"location":"opcodes/delay_timel_onccN/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"delay timel onccN"},{"location":"opcodes/delay_timer/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"Delay timer"},{"location":"opcodes/delay_timer_onccN/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"delay timer onccN"},{"location":"opcodes/delay_wet/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"Delay wet"},{"location":"opcodes/delay_wet_onccN/","text":"Used under the \u2039effect\u203a header, with type = delay .","title":"delay wet onccN"},{"location":"opcodes/direction/","text":"This is similar to loop_type but affects the entire sample, not just the defined loop regions. Example direction=reverse Practical Considerations At least in ARIA, direction=reverse doesn't always work as expected. However, it seems to work if the sample= opcode is specified for every region. Specifying the sample at the group header level and then specifying direction under the region doesn't seem to work at least in cases where one region has the sample playing forward, and another region has the same sample playing backwards.","title":"Direction"},{"location":"opcodes/direction/#example","text":"direction=reverse","title":"Example"},{"location":"opcodes/direction/#practical-considerations","text":"At least in ARIA, direction=reverse doesn't always work as expected. However, it seems to work if the sample= opcode is specified for every region. Specifying the sample at the group header level and then specifying direction under the region doesn't seem to work at least in cases where one region has the sample playing forward, and another region has the same sample playing backwards.","title":"Practical Considerations"},{"location":"opcodes/directtomain/","text":"Global, can be set under any \u2039effect\u203a header for identical result, see routing graph. Translates from % into a linear gain 0-1.","title":"Directtomain"},{"location":"opcodes/disto_depth/","text":"Used under the \u2039effect\u203a header, with type = disto .","title":"Disto depth"},{"location":"opcodes/disto_depth_onccN/","text":"Used under the \u2039effect\u203a header, with type = disto .","title":"disto depth onccN"},{"location":"opcodes/disto_dry/","text":"Used under the \u2039effect\u203a header, with type = disto .","title":"Disto dry"},{"location":"opcodes/disto_dry_onccN/","text":"Used under the \u2039effect\u203a header, with type = disto .","title":"disto dry onccN"},{"location":"opcodes/disto_stages/","text":"Used under the \u2039effect\u203a header, with type = disto .","title":"Disto stages"},{"location":"opcodes/disto_tone/","text":"Used under the \u2039effect\u203a header, with type = disto .","title":"Disto tone"},{"location":"opcodes/disto_tone_onccN/","text":"Used under the \u2039effect\u203a header, with type = disto .","title":"disto tone onccN"},{"location":"opcodes/disto_wet/","text":"Used under the \u2039effect\u203a header, with type = disto .","title":"Disto wet"},{"location":"opcodes/disto_wet_onccN/","text":"Used under the \u2039effect\u203a header, with type = disto .","title":"disto wet onccN"},{"location":"opcodes/dsp_order/","text":"","title":"Dsp order"},{"location":"opcodes/effect1/","text":"Effects handling varies across SFZ versions. In SFZ v1 only effect1 and effect2 opcodes were available and only at \u2039region\u203a level. In SFZ v2 the \u2039effect\u203a header was added, and effect3 and effect4 . ARIA uses the effect header as well, with the MDA effects built in and the possibility to support vendor-specific effects as well. Example effect1=100","title":"Effect1"},{"location":"opcodes/effect1/#example","text":"effect1=100","title":"Example"},{"location":"opcodes/effect2/","text":"Effects handling varies across SFZ versions. In SFZ v1 only effect1 and effect2 opcodes were available and only at \u2039region\u203a level. In SFZ v2 the \u2039effect\u203a header was added, and effect3 and effect4 . ARIA uses the effect header as well, with the MDA effects built in and the possibility to support vendor-specific effects as well. Example effect2=40","title":"Effect2"},{"location":"opcodes/effect2/#example","text":"effect2=40","title":"Example"},{"location":"opcodes/effect3/","text":"Effects handling varies across SFZ versions. In SFZ v1 only effect1 and effect2 opcodes were available and only at \u2039region\u203a level. In SFZ v2 the \u2039effect\u203a header was added, and effect3 and effect4 . ARIA uses the effect header as well, with the MDA effects built in and the possibility to support vendor-specific effects as well. The below example should work in Cakewalk Rapture. Example <group> sample=../samples/soundfx.wav ... <region> ... effect3=75 <effect> type=delay bus=fx3 ...","title":"Effect3"},{"location":"opcodes/effect3/#example","text":"<group> sample=../samples/soundfx.wav ... <region> ... effect3=75 <effect> type=delay bus=fx3 ...","title":"Example"},{"location":"opcodes/effect4/","text":"Effects handling varies across SFZ versions. In SFZ v1 only effect1 and effect2 opcodes were available and only at \u2039region\u203a level. In SFZ v2 the \u2039effect\u203a header was added, and effect3 and effect4 . ARIA uses the effect header as well, with the MDA effects built in and the possibility to support vendor-specific effects as well. The below example should work in Cakewalk Rapture. Example <group> sample=../samples/soundfx.wav ... <region> ... effect4=50 <effect> type=filter bus=fx4 ...","title":"Effect4"},{"location":"opcodes/effect4/#example","text":"<group> sample=../samples/soundfx.wav ... <region> ... effect4=50 <effect> type=filter bus=fx4 ...","title":"Example"},{"location":"opcodes/egN_ampeg/","text":"Examples Generate a standard ADSR shape FlexEG envelope <region> sample=*sine eg1_time1=1 eg1_level1=1 eg1_time2=1 eg1_level2=.5 eg1_sustain=2 eg1_time3=1 eg1_level3=0 eg1_ampeg=1 //ARIA boolean value, 1=true, 0=false Practical Considerations egN_ampeg allows the regions envelope to be controlled by the FlexEG: egN completely. This is only needed for the amplitude envelope, and is a special case. There is no egN_pitcheg or egN_fileg , using egN_pitch & egN_cutoffX is enough. The FlexEG can also work with the standard ampeg envelope, to achieve this add: egN_amplitude= The total envelope will be calculated as: egN * ampeg It is also possible to use CC modulation: egN_amplitude_onccX= In order to allow MIDI Note-On velocity to modulate the envelope level, use cc 131: eg1_amplitude_oncc131=100","title":"egN ampeg"},{"location":"opcodes/egN_ampeg/#examples","text":"Generate a standard ADSR shape FlexEG envelope <region> sample=*sine eg1_time1=1 eg1_level1=1 eg1_time2=1 eg1_level2=.5 eg1_sustain=2 eg1_time3=1 eg1_level3=0 eg1_ampeg=1 //ARIA boolean value, 1=true, 0=false","title":"Examples"},{"location":"opcodes/egN_ampeg/#practical-considerations","text":"egN_ampeg allows the regions envelope to be controlled by the FlexEG: egN completely. This is only needed for the amplitude envelope, and is a special case. There is no egN_pitcheg or egN_fileg , using egN_pitch & egN_cutoffX is enough. The FlexEG can also work with the standard ampeg envelope, to achieve this add: egN_amplitude= The total envelope will be calculated as: egN * ampeg It is also possible to use CC modulation: egN_amplitude_onccX= In order to allow MIDI Note-On velocity to modulate the envelope level, use cc 131: eg1_amplitude_oncc131=100","title":"Practical Considerations"},{"location":"opcodes/egN_amplitude/","text":"","title":"egN amplitude"},{"location":"opcodes/egN_amplitude_onccX/","text":"","title":"egN amplitude onccX"},{"location":"opcodes/egN_bitred/","text":"","title":"egN bitred"},{"location":"opcodes/egN_bitred_onccX/","text":"","title":"egN bitred onccX"},{"location":"opcodes/egN_curveX/","text":"Example eg01_curve1=10 eg01_curve2=11","title":"egN curveX"},{"location":"opcodes/egN_curveX/#example","text":"eg01_curve1=10 eg01_curve2=11","title":"Example"},{"location":"opcodes/egN_cutoff/","text":"","title":"egN cutoff"},{"location":"opcodes/egN_cutoff2/","text":"","title":"egN cutoff2"},{"location":"opcodes/egN_cutoff2_onccX/","text":"","title":"egN cutoff2 onccX"},{"location":"opcodes/egN_cutoff_onccX/","text":"","title":"egN cutoff onccX"},{"location":"opcodes/egN_decim/","text":"","title":"egN decim"},{"location":"opcodes/egN_decim_onccX/","text":"","title":"egN decim onccX"},{"location":"opcodes/egN_depth_lfoX/","text":"Examples Modulate the scale of lfo1's effect on cutoff and pan, from 0% to 200%, over the course of 4 seconds: <region> sample=*saw cutoff=800 lfo1_freq=2 lfo1_cutoff=1200 // will be modulated from 0 to 2400 (200%) lfo1_pan=50 // will be modulated from 0 to 100 (200%) eg1_level0=0 eg1_time1=4 eg1_level1=1 eg1_sustain=1 eg1_depth_lfo1=200 //..as eg1's move from 0 to 1 scales lfo1's effect from 0 to 200% NB. Tested with Aria/Sforzando","title":"egN depth lfoX"},{"location":"opcodes/egN_depth_lfoX/#examples","text":"Modulate the scale of lfo1's effect on cutoff and pan, from 0% to 200%, over the course of 4 seconds: <region> sample=*saw cutoff=800 lfo1_freq=2 lfo1_cutoff=1200 // will be modulated from 0 to 2400 (200%) lfo1_pan=50 // will be modulated from 0 to 100 (200%) eg1_level0=0 eg1_time1=4 eg1_level1=1 eg1_sustain=1 eg1_depth_lfo1=200 //..as eg1's move from 0 to 1 scales lfo1's effect from 0 to 200% NB. Tested with Aria/Sforzando","title":"Examples"},{"location":"opcodes/egN_depthadd_lfoX/","text":"","title":"egN depthadd lfoX"},{"location":"opcodes/egN_driveshape/","text":"","title":"egN driveshape"},{"location":"opcodes/egN_driveshape_onccX/","text":"","title":"egN driveshape onccX"},{"location":"opcodes/egN_dynamic/","text":"When 1, causes envelope segment durations and levels to be recalculated when a MIDI CC message modulating those envelopes is received. When 0, envelope segment durations and levels are calculated only at the start of the particular envelope segment. Examples <region> sample=*saw eg1_ampeg=1 // Create envelope to control amplitude.. eg1_sustain=1 eg1_level1=1 eg1_level2=0 eg1_time2=4 // ..with a release time of 4 seconds eg1_time2_oncc1=-8 // assign modwheel to modulate release time eg1_dynamic=1 // 1 = modulation will affect all notes immediately, or 0 (default) = new segments only","title":"egN dynamic"},{"location":"opcodes/egN_dynamic/#examples","text":"<region> sample=*saw eg1_ampeg=1 // Create envelope to control amplitude.. eg1_sustain=1 eg1_level1=1 eg1_level2=0 eg1_time2=4 // ..with a release time of 4 seconds eg1_time2_oncc1=-8 // assign modwheel to modulate release time eg1_dynamic=1 // 1 = modulation will affect all notes immediately, or 0 (default) = new segments only","title":"Examples"},{"location":"opcodes/egN_eqXbw/","text":"","title":"egN eqXbw"},{"location":"opcodes/egN_eqXbw_onccY/","text":"","title":"egN eqXbw onccY"},{"location":"opcodes/egN_eqXfreq/","text":"","title":"egN eqXfreq"},{"location":"opcodes/egN_eqXfreq_onccY/","text":"","title":"egN eqXfreq onccY"},{"location":"opcodes/egN_eqXgain/","text":"","title":"egN eqXgain"},{"location":"opcodes/egN_eqXgain_onccY/","text":"","title":"egN eqXgain onccY"},{"location":"opcodes/egN_freq_lfoX/","text":"","title":"egN freq lfoX"},{"location":"opcodes/egN_levelX/","text":"Examples eg01_level0=-1 eg02_level1=0.3 eg03_level2=0.5 eg03_level2_oncc51=0.5","title":"egN levelX"},{"location":"opcodes/egN_levelX/#examples","text":"eg01_level0=-1 eg02_level1=0.3 eg03_level2=0.5 eg03_level2_oncc51=0.5","title":"Examples"},{"location":"opcodes/egN_levelX_onccY/","text":"Examples eg01_level0=-1 eg02_level1=0.3 eg03_level2=0.5 eg03_level2_oncc51=0.5","title":"egN levelX onccY"},{"location":"opcodes/egN_levelX_onccY/#examples","text":"eg01_level0=-1 eg02_level1=0.3 eg03_level2=0.5 eg03_level2_oncc51=0.5","title":"Examples"},{"location":"opcodes/egN_loop/","text":"Specifies which envelope node is the loop node. Example eg01_loop=2 eg01_loop_shape=1 eg01_loop_count=8 Practical Considerations This is either not implemented in ARIA or sfizz, or our testing was not able to discover how it works. The relevant opcodes are egN_loop , egN_loop_count and possibly egN_loop_shape . In the existing test examples, egN_loop_shape is always set to 1.","title":"egN loop"},{"location":"opcodes/egN_loop/#example","text":"eg01_loop=2 eg01_loop_shape=1 eg01_loop_count=8","title":"Example"},{"location":"opcodes/egN_loop/#practical-considerations","text":"This is either not implemented in ARIA or sfizz, or our testing was not able to discover how it works. The relevant opcodes are egN_loop , egN_loop_count and possibly egN_loop_shape . In the existing test examples, egN_loop_shape is always set to 1.","title":"Practical Considerations"},{"location":"opcodes/egN_loop_count/","text":"Specifies how many times the loop for envelope N is to repeat. Example eg01_loop=2 eg01_loop_shape=1 eg01_loop_count=8 Practical Considerations This is either not implemented in ARIA or sfizz, or our testing was not able to discover how it works. The relevant opcodes are egN_loop , egN_loop_count and possibly egN_loop_shape . In the existing test examples, egN_loop_shape is always set to 1.","title":"egN loop count"},{"location":"opcodes/egN_loop_count/#example","text":"eg01_loop=2 eg01_loop_shape=1 eg01_loop_count=8","title":"Example"},{"location":"opcodes/egN_loop_count/#practical-considerations","text":"This is either not implemented in ARIA or sfizz, or our testing was not able to discover how it works. The relevant opcodes are egN_loop , egN_loop_count and possibly egN_loop_shape . In the existing test examples, egN_loop_shape is always set to 1.","title":"Practical Considerations"},{"location":"opcodes/egN_noiselevel/","text":"","title":"egN noiselevel"},{"location":"opcodes/egN_noiselevel_onccX/","text":"","title":"egN noiselevel onccX"},{"location":"opcodes/egN_noisestep/","text":"","title":"egN noisestep"},{"location":"opcodes/egN_noisestep_onccX/","text":"","title":"egN noisestep onccX"},{"location":"opcodes/egN_noisetone/","text":"","title":"egN noisetone"},{"location":"opcodes/egN_noisetone_onccX/","text":"","title":"egN noisetone onccX"},{"location":"opcodes/egN_pan/","text":"","title":"egN pan"},{"location":"opcodes/egN_pan_curve/","text":"","title":"egN pan curve"},{"location":"opcodes/egN_pan_curveccX/","text":"","title":"egN pan curveccX"},{"location":"opcodes/egN_pan_onccX/","text":"","title":"egN pan onccX"},{"location":"opcodes/egN_pitch/","text":"","title":"egN pitch"},{"location":"opcodes/egN_pitch_onccX/","text":"","title":"egN pitch onccX"},{"location":"opcodes/egN_points/","text":"Sets the number of points in envelope number N. The level of the envelope at those points can then be set with egN_levelX . When a region begins playing, the envelope starts at point number 0, and therefore an envelope with 4 points will have points numbered 0 through 3, not 1 through 4. Examples eg01_points=3 eg01_sustain=2 eg01_level0=0 eg01_time0=0 eg01_level1=1 eg01_time1=1 eg01_level2=1 eg01_time2=1 eg01_points=7 eg01_sustain=5 eg01_level0=0 eg01_time0=0 eg01_level1=1 eg01_time1=0.5 eg01_level2=0.7 eg01_time2=0.5 eg01_level3=1 eg01_time3=0.5 eg01_level4=0.7 eg01_time4=0.5 eg01_level5=0.1 eg01_time5=0.5 eg01_level6=0 eg01_time6=1 Practical Considerations At least in ARIA, it's not necessary to define egN_points as the parser will calculate how many points the envelope has from the number of points defined using egN_level and egN_time for the specific number N. If egN_points is set to a lower value than the number of points defined for the envelope, the entire envelope will be used, and it will not be truncated at the number set usign egN_points - so in effect, in ARIA this opcode appears to do nothing. It may be necessary to specify this in Cakewalk players, however.","title":"egN points"},{"location":"opcodes/egN_points/#examples","text":"eg01_points=3 eg01_sustain=2 eg01_level0=0 eg01_time0=0 eg01_level1=1 eg01_time1=1 eg01_level2=1 eg01_time2=1 eg01_points=7 eg01_sustain=5 eg01_level0=0 eg01_time0=0 eg01_level1=1 eg01_time1=0.5 eg01_level2=0.7 eg01_time2=0.5 eg01_level3=1 eg01_time3=0.5 eg01_level4=0.7 eg01_time4=0.5 eg01_level5=0.1 eg01_time5=0.5 eg01_level6=0 eg01_time6=1","title":"Examples"},{"location":"opcodes/egN_points/#practical-considerations","text":"At least in ARIA, it's not necessary to define egN_points as the parser will calculate how many points the envelope has from the number of points defined using egN_level and egN_time for the specific number N. If egN_points is set to a lower value than the number of points defined for the envelope, the entire envelope will be used, and it will not be truncated at the number set usign egN_points - so in effect, in ARIA this opcode appears to do nothing. It may be necessary to specify this in Cakewalk players, however.","title":"Practical Considerations"},{"location":"opcodes/egN_rectify/","text":"","title":"egN rectify"},{"location":"opcodes/egN_rectify_onccX/","text":"","title":"egN rectify onccX"},{"location":"opcodes/egN_resonance/","text":"","title":"egN resonance"},{"location":"opcodes/egN_resonance2/","text":"","title":"egN resonance2"},{"location":"opcodes/egN_resonance2_onccX/","text":"","title":"egN resonance2 onccX"},{"location":"opcodes/egN_resonance_onccX/","text":"","title":"egN resonance onccX"},{"location":"opcodes/egN_ringmod/","text":"","title":"egN ringmod"},{"location":"opcodes/egN_ringmod_onccX/","text":"","title":"egN ringmod onccX"},{"location":"opcodes/egN_sample_dyn_paramX/","text":"","title":"egN sample dyn paramX"},{"location":"opcodes/egN_sample_dyn_paramX_onccY/","text":"","title":"egN sample dyn paramX onccY"},{"location":"opcodes/egN_shapeX/","text":"Curve shape before the specified envelope point in envelope N. 0 is linear, positive values are slower and negative values faster. Past 10 or -10, there's little difference - at that point, the envelope is practically a horizontal line and a vertical line (if positive) or a vertical line followed by a horizontal line (if negative). Shapes values can also be applied to \"regular\" ampeg, pitch and cutoff envelopes. Examples eg01_shape1=5.2 eg02_shape2=-3.5 ampeg_attack_shape=3.8 ampeg_decay_shape=-1.4","title":"egN shapeX"},{"location":"opcodes/egN_shapeX/#examples","text":"eg01_shape1=5.2 eg02_shape2=-3.5 ampeg_attack_shape=3.8 ampeg_decay_shape=-1.4","title":"Examples"},{"location":"opcodes/egN_sustain/","text":"Defines which envelope point is used for the sustain level. The part of the specified envelope before that point will be triggered on note attack, and the part after that point will be triggered on note release. While the note sustains, the envelope will be at the level set by the same numbered egN_level opcode. Example eg01_sustain=5","title":"egN sustain"},{"location":"opcodes/egN_sustain/#example","text":"eg01_sustain=5","title":"Example"},{"location":"opcodes/egN_timeX/","text":"The time duration from an envelope point to another, in seconds. Can also be modulated with MIDI CC. Examples eg01_time1=0.5 eg01_time2_oncc50=1 eg02_time1=1","title":"egN timeX"},{"location":"opcodes/egN_timeX/#examples","text":"eg01_time1=0.5 eg01_time2_oncc50=1 eg02_time1=1","title":"Examples"},{"location":"opcodes/egN_timeX_onccY/","text":"The time duration from an envelope point to another, in seconds. Can also be modulated with MIDI CC. Examples eg01_time1=0.5 eg01_time2_oncc50=1 eg02_time1=1","title":"egN timeX onccY"},{"location":"opcodes/egN_timeX_onccY/#examples","text":"eg01_time1=0.5 eg01_time2_oncc50=1 eg02_time1=1","title":"Examples"},{"location":"opcodes/egN_volume/","text":"","title":"egN volume"},{"location":"opcodes/egN_volume_onccX/","text":"","title":"egN volume onccX"},{"location":"opcodes/egN_width/","text":"","title":"egN width"},{"location":"opcodes/egN_width_onccX/","text":"","title":"egN width onccX"},{"location":"opcodes/end/","text":"end is inclusive, so if set to 133000, the sample will play all samples up to and including 133000. The player will reproduce the whole sample if end is not specified. In other words, in most cases, this does not need to be set. If end value is -1, the sample will not play. Marking a region end with -1 can be used to use a silent region to turn off other regions by using the group and off_by opcodes. In certain cases, possibly due to ill-formed WAV files, setting end to -1 can cause errors, but setting loop_mode to no_loop or one_shot seems to be a workaround. A region which does not play is still triggered, however, which means it can mute other regions. When using sample =*silence it is very useful to set end =-1 (or a zero-duration volume envelope with zero sutain) so the silence region does not continue to play and does not use up a polyphony voice. Another way to accomplish the same thing is to use an ampeg envelope wiht zero ampeg_attack , ampeg_decay and ampeg_sustain . Examples end=133000 end=4432425 end=-1","title":"End"},{"location":"opcodes/end/#examples","text":"end=133000 end=4432425 end=-1","title":"Examples"},{"location":"opcodes/eqN_bw/","text":"Examples eq1_bw=1 eq2_bw=0.4 eq3_bw=1.4 Note While 0.001 is the minimum value in the SFZ specification, many SFZ players use CPU-efficient EQ algorithms and any values below 1 may yield unexpected results.","title":"eqN bw"},{"location":"opcodes/eqN_bw/#examples","text":"eq1_bw=1 eq2_bw=0.4 eq3_bw=1.4","title":"Examples"},{"location":"opcodes/eqN_bw/#note","text":"While 0.001 is the minimum value in the SFZ specification, many SFZ players use CPU-efficient EQ algorithms and any values below 1 may yield unexpected results.","title":"Note"},{"location":"opcodes/eqN_bw_onccX/","text":"Examples eq1_bw=1 eq2_bw=0.4 eq3_bw=1.4 Note While 0.001 is the minimum value in the SFZ specification, many SFZ players use CPU-efficient EQ algorithms and any values below 1 may yield unexpected results.","title":"eqN bw onccX"},{"location":"opcodes/eqN_bw_onccX/#examples","text":"eq1_bw=1 eq2_bw=0.4 eq3_bw=1.4","title":"Examples"},{"location":"opcodes/eqN_bw_onccX/#note","text":"While 0.001 is the minimum value in the SFZ specification, many SFZ players use CPU-efficient EQ algorithms and any values below 1 may yield unexpected results.","title":"Note"},{"location":"opcodes/eqN_bwccX/","text":"Examples eq1_bw=1 eq2_bw=0.4 eq3_bw=1.4 Note While 0.001 is the minimum value in the SFZ specification, many SFZ players use CPU-efficient EQ algorithms and any values below 1 may yield unexpected results.","title":"eqN bwccX"},{"location":"opcodes/eqN_bwccX/#examples","text":"eq1_bw=1 eq2_bw=0.4 eq3_bw=1.4","title":"Examples"},{"location":"opcodes/eqN_bwccX/#note","text":"While 0.001 is the minimum value in the SFZ specification, many SFZ players use CPU-efficient EQ algorithms and any values below 1 may yield unexpected results.","title":"Note"},{"location":"opcodes/eqN_freq/","text":"The SFZ specification has three EQ bands, with this opcode setting the center frequency of band N. There are three parametric bands: eq1, eq2 and eq3. If more than three bands are needed, ARIA allows fil_type to be set to lsh, hsh or peq to use one or both filters as additional EQ bands, including low shelf and high shelf. Examples eq1_freq=80 eq2_freq=1000 eq3_freq=4500 eq2_freq_oncc30=2500","title":"eqN freq"},{"location":"opcodes/eqN_freq/#examples","text":"eq1_freq=80 eq2_freq=1000 eq3_freq=4500 eq2_freq_oncc30=2500","title":"Examples"},{"location":"opcodes/eqN_freq_onccX/","text":"The SFZ specification has three EQ bands, with this opcode setting the center frequency of band N. There are three parametric bands: eq1, eq2 and eq3. If more than three bands are needed, ARIA allows fil_type to be set to lsh, hsh or peq to use one or both filters as additional EQ bands, including low shelf and high shelf. Examples eq1_freq=80 eq2_freq=1000 eq3_freq=4500 eq2_freq_oncc30=2500","title":"eqN freq onccX"},{"location":"opcodes/eqN_freq_onccX/#examples","text":"eq1_freq=80 eq2_freq=1000 eq3_freq=4500 eq2_freq_oncc30=2500","title":"Examples"},{"location":"opcodes/eqN_freqccX/","text":"The SFZ specification has three EQ bands, with this opcode setting the center frequency of band N. There are three parametric bands: eq1, eq2 and eq3. If more than three bands are needed, ARIA allows fil_type to be set to lsh, hsh or peq to use one or both filters as additional EQ bands, including low shelf and high shelf. Examples eq1_freq=80 eq2_freq=1000 eq3_freq=4500 eq2_freq_oncc30=2500","title":"eqN freqccX"},{"location":"opcodes/eqN_freqccX/#examples","text":"eq1_freq=80 eq2_freq=1000 eq3_freq=4500 eq2_freq_oncc30=2500","title":"Examples"},{"location":"opcodes/eqN_gain/","text":"Examples eq1_gain=-3 eq2_gain=6 eq3_gain=-6 eq1_gain_oncc23=-12 Notes When emulating timbral changes when there are not enough dynamic level samples available, and modulating EQ bands with MIDI CC, this will often be a negative value for the lowest band, and a positive value for the two higher bands.","title":"eqN gain"},{"location":"opcodes/eqN_gain/#examples","text":"eq1_gain=-3 eq2_gain=6 eq3_gain=-6 eq1_gain_oncc23=-12","title":"Examples"},{"location":"opcodes/eqN_gain/#notes","text":"When emulating timbral changes when there are not enough dynamic level samples available, and modulating EQ bands with MIDI CC, this will often be a negative value for the lowest band, and a positive value for the two higher bands.","title":"Notes"},{"location":"opcodes/eqN_gain_onccX/","text":"Examples eq1_gain=-3 eq2_gain=6 eq3_gain=-6 eq1_gain_oncc23=-12 Notes When emulating timbral changes when there are not enough dynamic level samples available, and modulating EQ bands with MIDI CC, this will often be a negative value for the lowest band, and a positive value for the two higher bands.","title":"eqN gain onccX"},{"location":"opcodes/eqN_gain_onccX/#examples","text":"eq1_gain=-3 eq2_gain=6 eq3_gain=-6 eq1_gain_oncc23=-12","title":"Examples"},{"location":"opcodes/eqN_gain_onccX/#notes","text":"When emulating timbral changes when there are not enough dynamic level samples available, and modulating EQ bands with MIDI CC, this will often be a negative value for the lowest band, and a positive value for the two higher bands.","title":"Notes"},{"location":"opcodes/eqN_gainccX/","text":"Examples eq1_gain=-3 eq2_gain=6 eq3_gain=-6 eq1_gain_oncc23=-12 Notes When emulating timbral changes when there are not enough dynamic level samples available, and modulating EQ bands with MIDI CC, this will often be a negative value for the lowest band, and a positive value for the two higher bands.","title":"eqN gainccX"},{"location":"opcodes/eqN_gainccX/#examples","text":"eq1_gain=-3 eq2_gain=6 eq3_gain=-6 eq1_gain_oncc23=-12","title":"Examples"},{"location":"opcodes/eqN_gainccX/#notes","text":"When emulating timbral changes when there are not enough dynamic level samples available, and modulating EQ bands with MIDI CC, this will often be a negative value for the lowest band, and a positive value for the two higher bands.","title":"Notes"},{"location":"opcodes/eqN_type/","text":"Example In some Cakewalk plugins it's possible to have shelving EQ by \"borrows\" from the three EQ bands. Allowed values are lshelf (low shelf), hshelf (high shelf) and peak (the default EQ band behavior). In ARIA, low-shelf or high-shelf EQ \"borrows\" one of the filters instead, as documented under the fil_gain opcode. <region> eq1_gain=20 eq1_freq=10000 eq1_bw=1 eq1_type=lshelf","title":"eqN type"},{"location":"opcodes/eqN_type/#example","text":"In some Cakewalk plugins it's possible to have shelving EQ by \"borrows\" from the three EQ bands. Allowed values are lshelf (low shelf), hshelf (high shelf) and peak (the default EQ band behavior). In ARIA, low-shelf or high-shelf EQ \"borrows\" one of the filters instead, as documented under the fil_gain opcode. <region> eq1_gain=20 eq1_freq=10000 eq1_bw=1 eq1_type=lshelf","title":"Example"},{"location":"opcodes/eqN_vel2freq/","text":"The SFZ specification has three EQ bands, with this opcode setting the center frequency of band N. There are three parametric bands: eq1, eq2 and eq3. If more than three bands are needed, ARIA allows fil_type to be set to lsh, hsh or peq to use one or both filters as additional EQ bands, including low shelf and high shelf. Examples eq1_freq=80 eq2_freq=1000 eq3_freq=4500 eq2_freq_oncc30=2500","title":"eqN vel2freq"},{"location":"opcodes/eqN_vel2freq/#examples","text":"eq1_freq=80 eq2_freq=1000 eq3_freq=4500 eq2_freq_oncc30=2500","title":"Examples"},{"location":"opcodes/eqN_vel2gain/","text":"Examples eq1_gain=-3 eq2_gain=6 eq3_gain=-6 eq1_gain_oncc23=-12 Notes When emulating timbral changes when there are not enough dynamic level samples available, and modulating EQ bands with MIDI CC, this will often be a negative value for the lowest band, and a positive value for the two higher bands.","title":"eqN vel2gain"},{"location":"opcodes/eqN_vel2gain/#examples","text":"eq1_gain=-3 eq2_gain=6 eq3_gain=-6 eq1_gain_oncc23=-12","title":"Examples"},{"location":"opcodes/eqN_vel2gain/#notes","text":"When emulating timbral changes when there are not enough dynamic level samples available, and modulating EQ bands with MIDI CC, this will often be a negative value for the lowest band, and a positive value for the two higher bands.","title":"Notes"},{"location":"opcodes/eq_bw/","text":"Used under the \u2039effect\u203a header, with type = eq .","title":"Eq bw"},{"location":"opcodes/eq_bw_onccN/","text":"Used under the \u2039effect\u203a header, with type = eq .","title":"eq bw onccN"},{"location":"opcodes/eq_freq/","text":"Used under the \u2039effect\u203a header, with type = eq .","title":"Eq freq"},{"location":"opcodes/eq_freq_onccN/","text":"Used under the \u2039effect\u203a header, with type = eq .","title":"eq freq onccN"},{"location":"opcodes/eq_gain/","text":"Used under the \u2039effect\u203a header, with type = eq .","title":"Eq gain"},{"location":"opcodes/eq_gain_onccN/","text":"Used under the \u2039effect\u203a header, with type = eq .","title":"eq gain onccN"},{"location":"opcodes/eq_type/","text":"Used under the \u2039effect\u203a header, with type = eq .","title":"Eq type"},{"location":"opcodes/fil2_gain/","text":"fil_gain and fil2_gain are used by the additional ARIA extension filter types lsh (low shelf), hsh (high shelf) and peq (parametric EQ). This allows the two filters to instead be used as additional EQ bands, on top of SFZ's regular three bands. It also allows shelving EQ. In ARIA, low-shelf or high-shelf EQ \"borrows\" one of the filters, while in some Cakewalk plugins it's also possible to have shelf EQ but it \"borrows\" from the three EQ bands rather than the two filters, and uses the eqN_type opcode. Examples fil_type=lsh cutoff=150 fil_gain=-6 fil2_type=hsh cutoff2=80000 fil2_gain=3","title":"fil_gain / fil2_gain"},{"location":"opcodes/fil2_gain/#examples","text":"fil_type=lsh cutoff=150 fil_gain=-6 fil2_type=hsh cutoff2=80000 fil2_gain=3","title":"Examples"},{"location":"opcodes/fil2_gain_onccN/","text":"fil_gain and fil2_gain are used by the additional ARIA extension filter types lsh (low shelf), hsh (high shelf) and peq (parametric EQ). This allows the two filters to instead be used as additional EQ bands, on top of SFZ's regular three bands. It also allows shelving EQ. In ARIA, low-shelf or high-shelf EQ \"borrows\" one of the filters, while in some Cakewalk plugins it's also possible to have shelf EQ but it \"borrows\" from the three EQ bands rather than the two filters, and uses the eqN_type opcode. Examples fil_type=lsh cutoff=150 fil_gain=-6 fil2_type=hsh cutoff2=80000 fil2_gain=3","title":"fil_gain / fil2_gain"},{"location":"opcodes/fil2_gain_onccN/#examples","text":"fil_type=lsh cutoff=150 fil_gain=-6 fil2_type=hsh cutoff2=80000 fil2_gain=3","title":"Examples"},{"location":"opcodes/fil2_keycenter/","text":"In this key, the filter keyboard tracking will have no effect. Examples fil_keycenter=60 fil_keycenter=E3","title":"fil_keycenter / fil2_keycenter"},{"location":"opcodes/fil2_keycenter/#examples","text":"fil_keycenter=60 fil_keycenter=E3","title":"Examples"},{"location":"opcodes/fil2_keytrack/","text":"A value of 100 means 100 cents per half-step. Examples fil_keytrack=100 fil_keytrack=0 The center key for this is specified by fil_keycenter - for keys below this key, the change in filter cutoff will be negative, and above this key, it will be positive. Sforzando accepts and honours negative values.","title":"fil_keytrack / fil2_keytrack"},{"location":"opcodes/fil2_keytrack/#examples","text":"fil_keytrack=100 fil_keytrack=0 The center key for this is specified by fil_keycenter - for keys below this key, the change in filter cutoff will be negative, and above this key, it will be positive. Sforzando accepts and honours negative values.","title":"Examples"},{"location":"opcodes/fil2_type/","text":"Allows you to choose which type of filter you use if not specified (ie.: only cutoff and resonance in the SFZ). fil_type was created in SFZ v1, so under that specification level only the v1 filters listed below are supported. fil2_type was added later in SFZ v2 as a second filter to be used in series, so under the v2 specification level both opcodes include both v1 and v2 filters. ARIA adds three more possible values for both opcodes. Examples fil_type=lpf_2p fil_type=hpf_1p Passive tone controls in guitars are one-pole low pass filters. Typical subtractive synthesizer filters are two-pole filters. fil2_type=hpf_2p The combination of fil and fil2 can be used to have, for example, both a high-pass and a low-pass filter, like this. In the below example, the first filter does not have a type set explicitly, so fil_type defaults to lpf_2p, making it a lowpass filter. The second filter is set to be a highpass filter. cutoff=1200 resonance=6 fil2_type=hpf_2p cutoff2=250 resonance2=3 Practical Considerations lsh , hsh and peq are ARIA extensions, allowing filters to be used as low-shelf, high-shelf or up to two additional parametric EQ bands, in addition to the default three eqN bands. Filters of these three types use fil_gain or fil2_gain to set the gain of the shelf or band.","title":"fil_type / fil2_type"},{"location":"opcodes/fil2_type/#examples","text":"fil_type=lpf_2p fil_type=hpf_1p Passive tone controls in guitars are one-pole low pass filters. Typical subtractive synthesizer filters are two-pole filters. fil2_type=hpf_2p The combination of fil and fil2 can be used to have, for example, both a high-pass and a low-pass filter, like this. In the below example, the first filter does not have a type set explicitly, so fil_type defaults to lpf_2p, making it a lowpass filter. The second filter is set to be a highpass filter. cutoff=1200 resonance=6 fil2_type=hpf_2p cutoff2=250 resonance2=3","title":"Examples"},{"location":"opcodes/fil2_type/#practical-considerations","text":"lsh , hsh and peq are ARIA extensions, allowing filters to be used as low-shelf, high-shelf or up to two additional parametric EQ bands, in addition to the default three eqN bands. Filters of these three types use fil_gain or fil2_gain to set the gain of the shelf or band.","title":"Practical Considerations"},{"location":"opcodes/fil2_veltrack/","text":"Examples fil_veltrack=0 fil_veltrack=1200","title":"fil_veltrack / fil2_veltrack"},{"location":"opcodes/fil2_veltrack/#examples","text":"fil_veltrack=0 fil_veltrack=1200","title":"Examples"},{"location":"opcodes/fil_attack/","text":"Examples ampeg_attack=1.2 fileg_attack=0.1 These are very frequently used, especially with amplifier envelopes. ampeg_attack is the standard \"A\" in the basic ADSR volume envelope. fileg_attack is key to 303-style basses.","title":"Fil attack"},{"location":"opcodes/fil_attack/#examples","text":"ampeg_attack=1.2 fileg_attack=0.1 These are very frequently used, especially with amplifier envelopes. ampeg_attack is the standard \"A\" in the basic ADSR volume envelope. fileg_attack is key to 303-style basses.","title":"Examples"},{"location":"opcodes/fil_decay/","text":"Examples ampeg_decay=1.5 fileg_decay=0.5 This should normally not be shorter than the corresponding envelope's release time.","title":"Fil decay"},{"location":"opcodes/fil_decay/#examples","text":"ampeg_decay=1.5 fileg_decay=0.5 This should normally not be shorter than the corresponding envelope's release time.","title":"Examples"},{"location":"opcodes/fil_delay/","text":"This is the time elapsed from note on to the start of the Attack stage. If both envelope delay and the general delay or delay_random are used in the same region, the envelope delays start after delay and delay_random have both completed their duration. Examples fileg_delay=0.004 ampeg_delay=0.05","title":"Fil delay"},{"location":"opcodes/fil_delay/#examples","text":"fileg_delay=0.004 ampeg_delay=0.05","title":"Examples"},{"location":"opcodes/fil_depth/","text":"For pitcheg and fileg, this is in cents, and can range from -12000 to 12000. -12000 cents is 10 octaves. For ampeg, this should not normally be used. Examples fileg_depth=1200 pitcheg_depth=-100","title":"Fil depth"},{"location":"opcodes/fil_depth/#examples","text":"fileg_depth=1200 pitcheg_depth=-100","title":"Examples"},{"location":"opcodes/fil_gain/","text":"fil_gain and fil2_gain are used by the additional ARIA extension filter types lsh (low shelf), hsh (high shelf) and peq (parametric EQ). This allows the two filters to instead be used as additional EQ bands, on top of SFZ's regular three bands. It also allows shelving EQ. In ARIA, low-shelf or high-shelf EQ \"borrows\" one of the filters, while in some Cakewalk plugins it's also possible to have shelf EQ but it \"borrows\" from the three EQ bands rather than the two filters, and uses the eqN_type opcode. Examples fil_type=lsh cutoff=150 fil_gain=-6 fil2_type=hsh cutoff2=80000 fil2_gain=3","title":"fil_gain / fil2_gain"},{"location":"opcodes/fil_gain/#examples","text":"fil_type=lsh cutoff=150 fil_gain=-6 fil2_type=hsh cutoff2=80000 fil2_gain=3","title":"Examples"},{"location":"opcodes/fil_gain_onccN/","text":"fil_gain and fil2_gain are used by the additional ARIA extension filter types lsh (low shelf), hsh (high shelf) and peq (parametric EQ). This allows the two filters to instead be used as additional EQ bands, on top of SFZ's regular three bands. It also allows shelving EQ. In ARIA, low-shelf or high-shelf EQ \"borrows\" one of the filters, while in some Cakewalk plugins it's also possible to have shelf EQ but it \"borrows\" from the three EQ bands rather than the two filters, and uses the eqN_type opcode. Examples fil_type=lsh cutoff=150 fil_gain=-6 fil2_type=hsh cutoff2=80000 fil2_gain=3","title":"fil_gain / fil2_gain"},{"location":"opcodes/fil_gain_onccN/#examples","text":"fil_type=lsh cutoff=150 fil_gain=-6 fil2_type=hsh cutoff2=80000 fil2_gain=3","title":"Examples"},{"location":"opcodes/fil_hold/","text":"During the hold stage, EG output will remain at its maximum value. Examples ampeg_hold=1.5 fileg_hold=0.1","title":"Fil hold"},{"location":"opcodes/fil_hold/#examples","text":"ampeg_hold=1.5 fileg_hold=0.1","title":"Examples"},{"location":"opcodes/fil_keycenter/","text":"In this key, the filter keyboard tracking will have no effect. Examples fil_keycenter=60 fil_keycenter=E3","title":"fil_keycenter / fil2_keycenter"},{"location":"opcodes/fil_keycenter/#examples","text":"fil_keycenter=60 fil_keycenter=E3","title":"Examples"},{"location":"opcodes/fil_keytrack/","text":"A value of 100 means 100 cents per half-step. Examples fil_keytrack=100 fil_keytrack=0 The center key for this is specified by fil_keycenter - for keys below this key, the change in filter cutoff will be negative, and above this key, it will be positive. Sforzando accepts and honours negative values.","title":"fil_keytrack / fil2_keytrack"},{"location":"opcodes/fil_keytrack/#examples","text":"fil_keytrack=100 fil_keytrack=0 The center key for this is specified by fil_keycenter - for keys below this key, the change in filter cutoff will be negative, and above this key, it will be positive. Sforzando accepts and honours negative values.","title":"Examples"},{"location":"opcodes/fil_random/","text":"Computed when the note is triggered, remains the same for that region for as long as the region plays. Examples fil_random=100 fil_random=400 Practical Considerations In ARIA, this is unipolar. In rcg sfz and Cakewalk, this is bipolar.","title":"Fil random"},{"location":"opcodes/fil_random/#examples","text":"fil_random=100 fil_random=400","title":"Examples"},{"location":"opcodes/fil_random/#practical-considerations","text":"In ARIA, this is unipolar. In rcg sfz and Cakewalk, this is bipolar.","title":"Practical Considerations"},{"location":"opcodes/fil_release/","text":"Examples ampeg_release=1.34 fileg_release=0.2 In many instruments, ampeg_release will need to be set to avoid the sound cutting off unrealistically quickly when a note ends (unless the instrument uses loop_mode set to one_shot, in which case the entire sample will always play) even if amplifier envelopes are not used otherwise to shape the sound. Also, ampeg_release is used when off_mode is set to normal.","title":"Fil release"},{"location":"opcodes/fil_release/#examples","text":"ampeg_release=1.34 fileg_release=0.2 In many instruments, ampeg_release will need to be set to avoid the sound cutting off unrealistically quickly when a note ends (unless the instrument uses loop_mode set to one_shot, in which case the entire sample will always play) even if amplifier envelopes are not used otherwise to shape the sound. Also, ampeg_release is used when off_mode is set to normal.","title":"Examples"},{"location":"opcodes/fil_sustain/","text":"Examples ampeg_sustain=40.34 pitcheg_sustain=10(eg type)_sustain","title":"Fil sustain"},{"location":"opcodes/fil_sustain/#examples","text":"ampeg_sustain=40.34 pitcheg_sustain=10(eg type)_sustain","title":"Examples"},{"location":"opcodes/fil_type/","text":"Allows you to choose which type of filter you use if not specified (ie.: only cutoff and resonance in the SFZ). fil_type was created in SFZ v1, so under that specification level only the v1 filters listed below are supported. fil2_type was added later in SFZ v2 as a second filter to be used in series, so under the v2 specification level both opcodes include both v1 and v2 filters. ARIA adds three more possible values for both opcodes. Examples fil_type=lpf_2p fil_type=hpf_1p Passive tone controls in guitars are one-pole low pass filters. Typical subtractive synthesizer filters are two-pole filters. fil2_type=hpf_2p The combination of fil and fil2 can be used to have, for example, both a high-pass and a low-pass filter, like this. In the below example, the first filter does not have a type set explicitly, so fil_type defaults to lpf_2p, making it a lowpass filter. The second filter is set to be a highpass filter. cutoff=1200 resonance=6 fil2_type=hpf_2p cutoff2=250 resonance2=3 Practical Considerations lsh , hsh and peq are ARIA extensions, allowing filters to be used as low-shelf, high-shelf or up to two additional parametric EQ bands, in addition to the default three eqN bands. Filters of these three types use fil_gain or fil2_gain to set the gain of the shelf or band.","title":"fil_type / fil2_type"},{"location":"opcodes/fil_type/#examples","text":"fil_type=lpf_2p fil_type=hpf_1p Passive tone controls in guitars are one-pole low pass filters. Typical subtractive synthesizer filters are two-pole filters. fil2_type=hpf_2p The combination of fil and fil2 can be used to have, for example, both a high-pass and a low-pass filter, like this. In the below example, the first filter does not have a type set explicitly, so fil_type defaults to lpf_2p, making it a lowpass filter. The second filter is set to be a highpass filter. cutoff=1200 resonance=6 fil2_type=hpf_2p cutoff2=250 resonance2=3","title":"Examples"},{"location":"opcodes/fil_type/#practical-considerations","text":"lsh , hsh and peq are ARIA extensions, allowing filters to be used as low-shelf, high-shelf or up to two additional parametric EQ bands, in addition to the default three eqN bands. Filters of these three types use fil_gain or fil2_gain to set the gain of the shelf or band.","title":"Practical Considerations"},{"location":"opcodes/fil_vel2attack/","text":"Examples ampeg_attack=1.2 fileg_attack=0.1 These are very frequently used, especially with amplifier envelopes. ampeg_attack is the standard \"A\" in the basic ADSR volume envelope. fileg_attack is key to 303-style basses.","title":"Fil vel2attack"},{"location":"opcodes/fil_vel2attack/#examples","text":"ampeg_attack=1.2 fileg_attack=0.1 These are very frequently used, especially with amplifier envelopes. ampeg_attack is the standard \"A\" in the basic ADSR volume envelope. fileg_attack is key to 303-style basses.","title":"Examples"},{"location":"opcodes/fil_vel2decay/","text":"Examples ampeg_decay=1.5 fileg_decay=0.5 This should normally not be shorter than the corresponding envelope's release time.","title":"Fil vel2decay"},{"location":"opcodes/fil_vel2decay/#examples","text":"ampeg_decay=1.5 fileg_decay=0.5 This should normally not be shorter than the corresponding envelope's release time.","title":"Examples"},{"location":"opcodes/fil_vel2delay/","text":"This is the time elapsed from note on to the start of the Attack stage. If both envelope delay and the general delay or delay_random are used in the same region, the envelope delays start after delay and delay_random have both completed their duration. Examples fileg_delay=0.004 ampeg_delay=0.05","title":"Fil vel2delay"},{"location":"opcodes/fil_vel2delay/#examples","text":"fileg_delay=0.004 ampeg_delay=0.05","title":"Examples"},{"location":"opcodes/fil_vel2depth/","text":"For pitcheg and fileg, this is in cents, and can range from -12000 to 12000. -12000 cents is 10 octaves. For ampeg, this should not normally be used. Examples fileg_depth=1200 pitcheg_depth=-100","title":"Fil vel2depth"},{"location":"opcodes/fil_vel2depth/#examples","text":"fileg_depth=1200 pitcheg_depth=-100","title":"Examples"},{"location":"opcodes/fil_vel2hold/","text":"During the hold stage, EG output will remain at its maximum value. Examples ampeg_hold=1.5 fileg_hold=0.1","title":"Fil vel2hold"},{"location":"opcodes/fil_vel2hold/#examples","text":"ampeg_hold=1.5 fileg_hold=0.1","title":"Examples"},{"location":"opcodes/fil_vel2release/","text":"Examples ampeg_release=1.34 fileg_release=0.2 In many instruments, ampeg_release will need to be set to avoid the sound cutting off unrealistically quickly when a note ends (unless the instrument uses loop_mode set to one_shot, in which case the entire sample will always play) even if amplifier envelopes are not used otherwise to shape the sound. Also, ampeg_release is used when off_mode is set to normal.","title":"Fil vel2release"},{"location":"opcodes/fil_vel2release/#examples","text":"ampeg_release=1.34 fileg_release=0.2 In many instruments, ampeg_release will need to be set to avoid the sound cutting off unrealistically quickly when a note ends (unless the instrument uses loop_mode set to one_shot, in which case the entire sample will always play) even if amplifier envelopes are not used otherwise to shape the sound. Also, ampeg_release is used when off_mode is set to normal.","title":"Examples"},{"location":"opcodes/fil_vel2sustain/","text":"Examples ampeg_sustain=40.34 pitcheg_sustain=10(eg type)_sustain","title":"Fil vel2sustain"},{"location":"opcodes/fil_vel2sustain/#examples","text":"ampeg_sustain=40.34 pitcheg_sustain=10(eg type)_sustain","title":"Examples"},{"location":"opcodes/fil_veltrack/","text":"Examples fil_veltrack=0 fil_veltrack=1200","title":"fil_veltrack / fil2_veltrack"},{"location":"opcodes/fil_veltrack/#examples","text":"fil_veltrack=0 fil_veltrack=1200","title":"Examples"},{"location":"opcodes/fileg_attack/","text":"Examples ampeg_attack=1.2 fileg_attack=0.1 These are very frequently used, especially with amplifier envelopes. ampeg_attack is the standard \"A\" in the basic ADSR volume envelope. fileg_attack is key to 303-style basses.","title":"Fileg attack"},{"location":"opcodes/fileg_attack/#examples","text":"ampeg_attack=1.2 fileg_attack=0.1 These are very frequently used, especially with amplifier envelopes. ampeg_attack is the standard \"A\" in the basic ADSR volume envelope. fileg_attack is key to 303-style basses.","title":"Examples"},{"location":"opcodes/fileg_attack_curveccN/","text":"Examples ampeg_attack=1.2 fileg_attack=0.1 These are very frequently used, especially with amplifier envelopes. ampeg_attack is the standard \"A\" in the basic ADSR volume envelope. fileg_attack is key to 303-style basses.","title":"fileg attack curveccN"},{"location":"opcodes/fileg_attack_curveccN/#examples","text":"ampeg_attack=1.2 fileg_attack=0.1 These are very frequently used, especially with amplifier envelopes. ampeg_attack is the standard \"A\" in the basic ADSR volume envelope. fileg_attack is key to 303-style basses.","title":"Examples"},{"location":"opcodes/fileg_attack_onccN/","text":"Examples ampeg_attack=1.2 fileg_attack=0.1 These are very frequently used, especially with amplifier envelopes. ampeg_attack is the standard \"A\" in the basic ADSR volume envelope. fileg_attack is key to 303-style basses.","title":"fileg attack onccN"},{"location":"opcodes/fileg_attack_onccN/#examples","text":"ampeg_attack=1.2 fileg_attack=0.1 These are very frequently used, especially with amplifier envelopes. ampeg_attack is the standard \"A\" in the basic ADSR volume envelope. fileg_attack is key to 303-style basses.","title":"Examples"},{"location":"opcodes/fileg_attack_shape/","text":"0 is linear. Positive values are slower curves (that means the envelope will initially not fade in much, and most of the fade in will happen towards the end of the attack period) and negative values faster (quick initial fade in with the latter part of the attack stage fading in less). Past 10 or -10, there's little difference - at that point, the envelope is practically a horizontal line and a vertical line (if positive) or a vertical line followed by a horizontal line (if negative). Examples ampeg_attack_shape=2.1 ampeg_attack_shape=-3.8","title":"Fileg attack shape"},{"location":"opcodes/fileg_attack_shape/#examples","text":"ampeg_attack_shape=2.1 ampeg_attack_shape=-3.8","title":"Examples"},{"location":"opcodes/fileg_attackccN/","text":"Examples ampeg_attack=1.2 fileg_attack=0.1 These are very frequently used, especially with amplifier envelopes. ampeg_attack is the standard \"A\" in the basic ADSR volume envelope. fileg_attack is key to 303-style basses.","title":"fileg attackccN"},{"location":"opcodes/fileg_attackccN/#examples","text":"ampeg_attack=1.2 fileg_attack=0.1 These are very frequently used, especially with amplifier envelopes. ampeg_attack is the standard \"A\" in the basic ADSR volume envelope. fileg_attack is key to 303-style basses.","title":"Examples"},{"location":"opcodes/fileg_decay/","text":"Examples ampeg_decay=1.5 fileg_decay=0.5 This should normally not be shorter than the corresponding envelope's release time.","title":"Fileg decay"},{"location":"opcodes/fileg_decay/#examples","text":"ampeg_decay=1.5 fileg_decay=0.5 This should normally not be shorter than the corresponding envelope's release time.","title":"Examples"},{"location":"opcodes/fileg_decay_curveccN/","text":"Examples ampeg_decay=1.5 fileg_decay=0.5 This should normally not be shorter than the corresponding envelope's release time.","title":"fileg decay curveccN"},{"location":"opcodes/fileg_decay_curveccN/#examples","text":"ampeg_decay=1.5 fileg_decay=0.5 This should normally not be shorter than the corresponding envelope's release time.","title":"Examples"},{"location":"opcodes/fileg_decay_onccN/","text":"Examples ampeg_decay=1.5 fileg_decay=0.5 This should normally not be shorter than the corresponding envelope's release time.","title":"fileg decay onccN"},{"location":"opcodes/fileg_decay_onccN/#examples","text":"ampeg_decay=1.5 fileg_decay=0.5 This should normally not be shorter than the corresponding envelope's release time.","title":"Examples"},{"location":"opcodes/fileg_decay_shape/","text":"0 is linear, positive values are slower curves (that means the envelope will initially not decay out much, and most of the decay will happen towards the end of the decay period) and negative values faster (quick initial decay with quiet tail decaying more slowly). Past 10 or -10, there's little difference - at that point, the envelope is practically a horizontal line and a vertical line (if positive) or a vertical line followed by a horizontal line (if negative). Examples ampeg_decay_shape=2.1 ampeg_decay_shape=-3.8","title":"Fileg decay shape"},{"location":"opcodes/fileg_decay_shape/#examples","text":"ampeg_decay_shape=2.1 ampeg_decay_shape=-3.8","title":"Examples"},{"location":"opcodes/fileg_decay_zero/","text":"When set to 1, the decay slope is fixed, and the higher the sustain level of the envelope, the less time the decay stage will actually take. Changing fileg_sustain will change the actual duration of the decay stage as well, up to a maximum of the full fileg_decay value at fileg_sustain equal to 0. Setting this to 0 will make the decay always happen during the entire time period specified by fileg_decay , regardless of the current fileg_sustain level. Examples fileg_decay_zero=0 fileg_decay_zero=1","title":"Fileg decay zero"},{"location":"opcodes/fileg_decay_zero/#examples","text":"fileg_decay_zero=0 fileg_decay_zero=1","title":"Examples"},{"location":"opcodes/fileg_decayccN/","text":"Examples ampeg_decay=1.5 fileg_decay=0.5 This should normally not be shorter than the corresponding envelope's release time.","title":"fileg decayccN"},{"location":"opcodes/fileg_decayccN/#examples","text":"ampeg_decay=1.5 fileg_decay=0.5 This should normally not be shorter than the corresponding envelope's release time.","title":"Examples"},{"location":"opcodes/fileg_delay/","text":"This is the time elapsed from note on to the start of the Attack stage. If both envelope delay and the general delay or delay_random are used in the same region, the envelope delays start after delay and delay_random have both completed their duration. Examples fileg_delay=0.004 ampeg_delay=0.05","title":"Fileg delay"},{"location":"opcodes/fileg_delay/#examples","text":"fileg_delay=0.004 ampeg_delay=0.05","title":"Examples"},{"location":"opcodes/fileg_delay_curveccN/","text":"This is the time elapsed from note on to the start of the Attack stage. If both envelope delay and the general delay or delay_random are used in the same region, the envelope delays start after delay and delay_random have both completed their duration. Examples fileg_delay=0.004 ampeg_delay=0.05","title":"fileg delay curveccN"},{"location":"opcodes/fileg_delay_curveccN/#examples","text":"fileg_delay=0.004 ampeg_delay=0.05","title":"Examples"},{"location":"opcodes/fileg_delay_onccN/","text":"This is the time elapsed from note on to the start of the Attack stage. If both envelope delay and the general delay or delay_random are used in the same region, the envelope delays start after delay and delay_random have both completed their duration. Examples fileg_delay=0.004 ampeg_delay=0.05","title":"fileg delay onccN"},{"location":"opcodes/fileg_delay_onccN/#examples","text":"fileg_delay=0.004 ampeg_delay=0.05","title":"Examples"},{"location":"opcodes/fileg_delayccN/","text":"This is the time elapsed from note on to the start of the Attack stage. If both envelope delay and the general delay or delay_random are used in the same region, the envelope delays start after delay and delay_random have both completed their duration. Examples fileg_delay=0.004 ampeg_delay=0.05","title":"fileg delayccN"},{"location":"opcodes/fileg_delayccN/#examples","text":"fileg_delay=0.004 ampeg_delay=0.05","title":"Examples"},{"location":"opcodes/fileg_depth/","text":"For pitcheg and fileg, this is in cents, and can range from -12000 to 12000. -12000 cents is 10 octaves. For ampeg, this should not normally be used. Examples fileg_depth=1200 pitcheg_depth=-100","title":"Fileg depth"},{"location":"opcodes/fileg_depth/#examples","text":"fileg_depth=1200 pitcheg_depth=-100","title":"Examples"},{"location":"opcodes/fileg_depth_curveccN/","text":"For pitcheg and fileg, this is in cents, and can range from -12000 to 12000. -12000 cents is 10 octaves. For ampeg, this should not normally be used. Examples fileg_depth=1200 pitcheg_depth=-100","title":"fileg depth curveccN"},{"location":"opcodes/fileg_depth_curveccN/#examples","text":"fileg_depth=1200 pitcheg_depth=-100","title":"Examples"},{"location":"opcodes/fileg_depth_onccN/","text":"For pitcheg and fileg, this is in cents, and can range from -12000 to 12000. -12000 cents is 10 octaves. For ampeg, this should not normally be used. Examples fileg_depth=1200 pitcheg_depth=-100","title":"fileg depth onccN"},{"location":"opcodes/fileg_depth_onccN/#examples","text":"fileg_depth=1200 pitcheg_depth=-100","title":"Examples"},{"location":"opcodes/fileg_depthccN/","text":"For pitcheg and fileg, this is in cents, and can range from -12000 to 12000. -12000 cents is 10 octaves. For ampeg, this should not normally be used. Examples fileg_depth=1200 pitcheg_depth=-100","title":"fileg depthccN"},{"location":"opcodes/fileg_depthccN/#examples","text":"fileg_depth=1200 pitcheg_depth=-100","title":"Examples"},{"location":"opcodes/fileg_dynamic/","text":"When 1, causes envelope segment durations and sustain level to be recalculated when a MIDI CC message modulating those envelopes is received. When 0, envelope segment durations and sustain level are calculated only at the start of the particular envelope segment. Examples fileg_dynamic=1 fileg_dynamic=0","title":"Fileg dynamic"},{"location":"opcodes/fileg_dynamic/#examples","text":"fileg_dynamic=1 fileg_dynamic=0","title":"Examples"},{"location":"opcodes/fileg_hold/","text":"During the hold stage, EG output will remain at its maximum value. Examples ampeg_hold=1.5 fileg_hold=0.1","title":"Fileg hold"},{"location":"opcodes/fileg_hold/#examples","text":"ampeg_hold=1.5 fileg_hold=0.1","title":"Examples"},{"location":"opcodes/fileg_hold_curveccN/","text":"During the hold stage, EG output will remain at its maximum value. Examples ampeg_hold=1.5 fileg_hold=0.1","title":"fileg hold curveccN"},{"location":"opcodes/fileg_hold_curveccN/#examples","text":"ampeg_hold=1.5 fileg_hold=0.1","title":"Examples"},{"location":"opcodes/fileg_hold_onccN/","text":"During the hold stage, EG output will remain at its maximum value. Examples ampeg_hold=1.5 fileg_hold=0.1","title":"fileg hold onccN"},{"location":"opcodes/fileg_hold_onccN/#examples","text":"ampeg_hold=1.5 fileg_hold=0.1","title":"Examples"},{"location":"opcodes/fileg_holdccN/","text":"During the hold stage, EG output will remain at its maximum value. Examples ampeg_hold=1.5 fileg_hold=0.1","title":"fileg holdccN"},{"location":"opcodes/fileg_holdccN/#examples","text":"ampeg_hold=1.5 fileg_hold=0.1","title":"Examples"},{"location":"opcodes/fileg_release/","text":"Examples ampeg_release=1.34 fileg_release=0.2 In many instruments, ampeg_release will need to be set to avoid the sound cutting off unrealistically quickly when a note ends (unless the instrument uses loop_mode set to one_shot, in which case the entire sample will always play) even if amplifier envelopes are not used otherwise to shape the sound. Also, ampeg_release is used when off_mode is set to normal.","title":"Fileg release"},{"location":"opcodes/fileg_release/#examples","text":"ampeg_release=1.34 fileg_release=0.2 In many instruments, ampeg_release will need to be set to avoid the sound cutting off unrealistically quickly when a note ends (unless the instrument uses loop_mode set to one_shot, in which case the entire sample will always play) even if amplifier envelopes are not used otherwise to shape the sound. Also, ampeg_release is used when off_mode is set to normal.","title":"Examples"},{"location":"opcodes/fileg_release_curveccN/","text":"Examples ampeg_release=1.34 fileg_release=0.2 In many instruments, ampeg_release will need to be set to avoid the sound cutting off unrealistically quickly when a note ends (unless the instrument uses loop_mode set to one_shot, in which case the entire sample will always play) even if amplifier envelopes are not used otherwise to shape the sound. Also, ampeg_release is used when off_mode is set to normal.","title":"fileg release curveccN"},{"location":"opcodes/fileg_release_curveccN/#examples","text":"ampeg_release=1.34 fileg_release=0.2 In many instruments, ampeg_release will need to be set to avoid the sound cutting off unrealistically quickly when a note ends (unless the instrument uses loop_mode set to one_shot, in which case the entire sample will always play) even if amplifier envelopes are not used otherwise to shape the sound. Also, ampeg_release is used when off_mode is set to normal.","title":"Examples"},{"location":"opcodes/fileg_release_onccN/","text":"Examples ampeg_release=1.34 fileg_release=0.2 In many instruments, ampeg_release will need to be set to avoid the sound cutting off unrealistically quickly when a note ends (unless the instrument uses loop_mode set to one_shot, in which case the entire sample will always play) even if amplifier envelopes are not used otherwise to shape the sound. Also, ampeg_release is used when off_mode is set to normal.","title":"fileg release onccN"},{"location":"opcodes/fileg_release_onccN/#examples","text":"ampeg_release=1.34 fileg_release=0.2 In many instruments, ampeg_release will need to be set to avoid the sound cutting off unrealistically quickly when a note ends (unless the instrument uses loop_mode set to one_shot, in which case the entire sample will always play) even if amplifier envelopes are not used otherwise to shape the sound. Also, ampeg_release is used when off_mode is set to normal.","title":"Examples"},{"location":"opcodes/fileg_release_shape/","text":"0 is linear, positive values are slower curves (that means the envelope will initially not fade out much, and most of the fade will happen towards the end of the release period) and negative values faster (quick initial fadeout with quiet tail fading out more slowly). Past 10 or -10, there's little difference - at that point, the envelope is practically a horizontal line and a vertical line (if positive) or a vertical line followed by a horizontal line (if negative). Examples ampeg_release_shape=2.1 ampeg_release_shape=-3.8","title":"Fileg release shape"},{"location":"opcodes/fileg_release_shape/#examples","text":"ampeg_release_shape=2.1 ampeg_release_shape=-3.8","title":"Examples"},{"location":"opcodes/fileg_release_zero/","text":"When 1, indicates release time is the time it would take to get from 0dBs to -oo, NOT the time to get from the current sustain to zero. In other words, under default behavior, the release time is fixed, while setting this to 1 makes the release slope fixed but time will be shorter when sustain level is lower. Examples fileg_release_zero=1 fileg_release_zero=0","title":"Fileg release zero"},{"location":"opcodes/fileg_release_zero/#examples","text":"fileg_release_zero=1 fileg_release_zero=0","title":"Examples"},{"location":"opcodes/fileg_releaseccN/","text":"Examples ampeg_release=1.34 fileg_release=0.2 In many instruments, ampeg_release will need to be set to avoid the sound cutting off unrealistically quickly when a note ends (unless the instrument uses loop_mode set to one_shot, in which case the entire sample will always play) even if amplifier envelopes are not used otherwise to shape the sound. Also, ampeg_release is used when off_mode is set to normal.","title":"fileg releaseccN"},{"location":"opcodes/fileg_releaseccN/#examples","text":"ampeg_release=1.34 fileg_release=0.2 In many instruments, ampeg_release will need to be set to avoid the sound cutting off unrealistically quickly when a note ends (unless the instrument uses loop_mode set to one_shot, in which case the entire sample will always play) even if amplifier envelopes are not used otherwise to shape the sound. Also, ampeg_release is used when off_mode is set to normal.","title":"Examples"},{"location":"opcodes/fileg_start/","text":"Examples ampeg_start=20 fileg_start=100 Setting this to 100 should have the same effect as setting the attack time to 0, and adding the attack time to the hold time. Note that in some cases (when the sample starts playing from a point which is not near zero), setting this to a non-zero value for ampeg_start may result in sample playback starting with an audible click.","title":"Fileg start"},{"location":"opcodes/fileg_start/#examples","text":"ampeg_start=20 fileg_start=100 Setting this to 100 should have the same effect as setting the attack time to 0, and adding the attack time to the hold time. Note that in some cases (when the sample starts playing from a point which is not near zero), setting this to a non-zero value for ampeg_start may result in sample playback starting with an audible click.","title":"Examples"},{"location":"opcodes/fileg_start_curveccN/","text":"Examples ampeg_start=20 fileg_start=100 Setting this to 100 should have the same effect as setting the attack time to 0, and adding the attack time to the hold time. Note that in some cases (when the sample starts playing from a point which is not near zero), setting this to a non-zero value for ampeg_start may result in sample playback starting with an audible click.","title":"fileg start curveccN"},{"location":"opcodes/fileg_start_curveccN/#examples","text":"ampeg_start=20 fileg_start=100 Setting this to 100 should have the same effect as setting the attack time to 0, and adding the attack time to the hold time. Note that in some cases (when the sample starts playing from a point which is not near zero), setting this to a non-zero value for ampeg_start may result in sample playback starting with an audible click.","title":"Examples"},{"location":"opcodes/fileg_start_onccN/","text":"Examples ampeg_start=20 fileg_start=100 Setting this to 100 should have the same effect as setting the attack time to 0, and adding the attack time to the hold time. Note that in some cases (when the sample starts playing from a point which is not near zero), setting this to a non-zero value for ampeg_start may result in sample playback starting with an audible click.","title":"fileg start onccN"},{"location":"opcodes/fileg_start_onccN/#examples","text":"ampeg_start=20 fileg_start=100 Setting this to 100 should have the same effect as setting the attack time to 0, and adding the attack time to the hold time. Note that in some cases (when the sample starts playing from a point which is not near zero), setting this to a non-zero value for ampeg_start may result in sample playback starting with an audible click.","title":"Examples"},{"location":"opcodes/fileg_startccN/","text":"Examples ampeg_start=20 fileg_start=100 Setting this to 100 should have the same effect as setting the attack time to 0, and adding the attack time to the hold time. Note that in some cases (when the sample starts playing from a point which is not near zero), setting this to a non-zero value for ampeg_start may result in sample playback starting with an audible click.","title":"fileg startccN"},{"location":"opcodes/fileg_startccN/#examples","text":"ampeg_start=20 fileg_start=100 Setting this to 100 should have the same effect as setting the attack time to 0, and adding the attack time to the hold time. Note that in some cases (when the sample starts playing from a point which is not near zero), setting this to a non-zero value for ampeg_start may result in sample playback starting with an audible click.","title":"Examples"},{"location":"opcodes/fileg_sustain/","text":"Examples ampeg_sustain=40.34 pitcheg_sustain=10(eg type)_sustain","title":"Fileg sustain"},{"location":"opcodes/fileg_sustain/#examples","text":"ampeg_sustain=40.34 pitcheg_sustain=10(eg type)_sustain","title":"Examples"},{"location":"opcodes/fileg_sustain_curveccN/","text":"Examples ampeg_sustain=40.34 pitcheg_sustain=10(eg type)_sustain","title":"fileg sustain curveccN"},{"location":"opcodes/fileg_sustain_curveccN/#examples","text":"ampeg_sustain=40.34 pitcheg_sustain=10(eg type)_sustain","title":"Examples"},{"location":"opcodes/fileg_sustain_onccN/","text":"Examples ampeg_sustain=40.34 pitcheg_sustain=10(eg type)_sustain","title":"fileg sustain onccN"},{"location":"opcodes/fileg_sustain_onccN/#examples","text":"ampeg_sustain=40.34 pitcheg_sustain=10(eg type)_sustain","title":"Examples"},{"location":"opcodes/fileg_sustainccN/","text":"Examples ampeg_sustain=40.34 pitcheg_sustain=10(eg type)_sustain","title":"fileg sustainccN"},{"location":"opcodes/fileg_sustainccN/#examples","text":"ampeg_sustain=40.34 pitcheg_sustain=10(eg type)_sustain","title":"Examples"},{"location":"opcodes/fileg_vel2attack/","text":"Examples ampeg_attack=1.2 fileg_attack=0.1 These are very frequently used, especially with amplifier envelopes. ampeg_attack is the standard \"A\" in the basic ADSR volume envelope. fileg_attack is key to 303-style basses.","title":"Fileg vel2attack"},{"location":"opcodes/fileg_vel2attack/#examples","text":"ampeg_attack=1.2 fileg_attack=0.1 These are very frequently used, especially with amplifier envelopes. ampeg_attack is the standard \"A\" in the basic ADSR volume envelope. fileg_attack is key to 303-style basses.","title":"Examples"},{"location":"opcodes/fileg_vel2decay/","text":"Examples ampeg_decay=1.5 fileg_decay=0.5 This should normally not be shorter than the corresponding envelope's release time.","title":"Fileg vel2decay"},{"location":"opcodes/fileg_vel2decay/#examples","text":"ampeg_decay=1.5 fileg_decay=0.5 This should normally not be shorter than the corresponding envelope's release time.","title":"Examples"},{"location":"opcodes/fileg_vel2delay/","text":"This is the time elapsed from note on to the start of the Attack stage. If both envelope delay and the general delay or delay_random are used in the same region, the envelope delays start after delay and delay_random have both completed their duration. Examples fileg_delay=0.004 ampeg_delay=0.05","title":"Fileg vel2delay"},{"location":"opcodes/fileg_vel2delay/#examples","text":"fileg_delay=0.004 ampeg_delay=0.05","title":"Examples"},{"location":"opcodes/fileg_vel2depth/","text":"For pitcheg and fileg, this is in cents, and can range from -12000 to 12000. -12000 cents is 10 octaves. For ampeg, this should not normally be used. Examples fileg_depth=1200 pitcheg_depth=-100","title":"Fileg vel2depth"},{"location":"opcodes/fileg_vel2depth/#examples","text":"fileg_depth=1200 pitcheg_depth=-100","title":"Examples"},{"location":"opcodes/fileg_vel2hold/","text":"During the hold stage, EG output will remain at its maximum value. Examples ampeg_hold=1.5 fileg_hold=0.1","title":"Fileg vel2hold"},{"location":"opcodes/fileg_vel2hold/#examples","text":"ampeg_hold=1.5 fileg_hold=0.1","title":"Examples"},{"location":"opcodes/fileg_vel2release/","text":"Examples ampeg_release=1.34 fileg_release=0.2 In many instruments, ampeg_release will need to be set to avoid the sound cutting off unrealistically quickly when a note ends (unless the instrument uses loop_mode set to one_shot, in which case the entire sample will always play) even if amplifier envelopes are not used otherwise to shape the sound. Also, ampeg_release is used when off_mode is set to normal.","title":"Fileg vel2release"},{"location":"opcodes/fileg_vel2release/#examples","text":"ampeg_release=1.34 fileg_release=0.2 In many instruments, ampeg_release will need to be set to avoid the sound cutting off unrealistically quickly when a note ends (unless the instrument uses loop_mode set to one_shot, in which case the entire sample will always play) even if amplifier envelopes are not used otherwise to shape the sound. Also, ampeg_release is used when off_mode is set to normal.","title":"Examples"},{"location":"opcodes/fileg_vel2sustain/","text":"Examples ampeg_sustain=40.34 pitcheg_sustain=10(eg type)_sustain","title":"Fileg vel2sustain"},{"location":"opcodes/fileg_vel2sustain/#examples","text":"ampeg_sustain=40.34 pitcheg_sustain=10(eg type)_sustain","title":"Examples"},{"location":"opcodes/fillfo_delay/","text":"Examples pitchlfo_delay=1 amplfo_delay=0.4 This is very useful, as many instruments and vocals don't trigger vibrato immediately when a note starts, but slightly later.","title":"Fillfo delay"},{"location":"opcodes/fillfo_delay/#examples","text":"pitchlfo_delay=1 amplfo_delay=0.4 This is very useful, as many instruments and vocals don't trigger vibrato immediately when a note starts, but slightly later.","title":"Examples"},{"location":"opcodes/fillfo_depth/","text":"Examples amplfo_depth=1 pitchlfo_depth=40 For amplifier LFO, this is measured in decibels and can range from -10 to 10. For pitch and filter LFO, this is measured in cents and can range from -1200 to 1200. Whether these values are negative or positive, the LFO will oscillate both up and down around the center value of the amplitude, pitch or filter cutoff - a negative sign for depth only inverts the phase. For cases where an LFO needs to oscillate only in one direction from the normal value (for example: typical guitar vibrato which only bends the pitch upwards, or saxophone vibrato which only bends the pitch down), an offset to the center pitch value will need to be added using the appropriate opcode such as tune. In SFZ2 LFOs add the ability to set the starting phase, making this much easier.","title":"Fillfo depth"},{"location":"opcodes/fillfo_depth/#examples","text":"amplfo_depth=1 pitchlfo_depth=40 For amplifier LFO, this is measured in decibels and can range from -10 to 10. For pitch and filter LFO, this is measured in cents and can range from -1200 to 1200. Whether these values are negative or positive, the LFO will oscillate both up and down around the center value of the amplitude, pitch or filter cutoff - a negative sign for depth only inverts the phase. For cases where an LFO needs to oscillate only in one direction from the normal value (for example: typical guitar vibrato which only bends the pitch upwards, or saxophone vibrato which only bends the pitch down), an offset to the center pitch value will need to be added using the appropriate opcode such as tune. In SFZ2 LFOs add the ability to set the starting phase, making this much easier.","title":"Examples"},{"location":"opcodes/fillfo_depth_onccN/","text":"Examples amplfo_depth=1 pitchlfo_depth=40 For amplifier LFO, this is measured in decibels and can range from -10 to 10. For pitch and filter LFO, this is measured in cents and can range from -1200 to 1200. Whether these values are negative or positive, the LFO will oscillate both up and down around the center value of the amplitude, pitch or filter cutoff - a negative sign for depth only inverts the phase. For cases where an LFO needs to oscillate only in one direction from the normal value (for example: typical guitar vibrato which only bends the pitch upwards, or saxophone vibrato which only bends the pitch down), an offset to the center pitch value will need to be added using the appropriate opcode such as tune. In SFZ2 LFOs add the ability to set the starting phase, making this much easier.","title":"fillfo depth onccN"},{"location":"opcodes/fillfo_depth_onccN/#examples","text":"amplfo_depth=1 pitchlfo_depth=40 For amplifier LFO, this is measured in decibels and can range from -10 to 10. For pitch and filter LFO, this is measured in cents and can range from -1200 to 1200. Whether these values are negative or positive, the LFO will oscillate both up and down around the center value of the amplitude, pitch or filter cutoff - a negative sign for depth only inverts the phase. For cases where an LFO needs to oscillate only in one direction from the normal value (for example: typical guitar vibrato which only bends the pitch upwards, or saxophone vibrato which only bends the pitch down), an offset to the center pitch value will need to be added using the appropriate opcode such as tune. In SFZ2 LFOs add the ability to set the starting phase, making this much easier.","title":"Examples"},{"location":"opcodes/fillfo_depthccN/","text":"Examples amplfo_depth=1 pitchlfo_depth=40 For amplifier LFO, this is measured in decibels and can range from -10 to 10. For pitch and filter LFO, this is measured in cents and can range from -1200 to 1200. Whether these values are negative or positive, the LFO will oscillate both up and down around the center value of the amplitude, pitch or filter cutoff - a negative sign for depth only inverts the phase. For cases where an LFO needs to oscillate only in one direction from the normal value (for example: typical guitar vibrato which only bends the pitch upwards, or saxophone vibrato which only bends the pitch down), an offset to the center pitch value will need to be added using the appropriate opcode such as tune. In SFZ2 LFOs add the ability to set the starting phase, making this much easier.","title":"fillfo depthccN"},{"location":"opcodes/fillfo_depthccN/#examples","text":"amplfo_depth=1 pitchlfo_depth=40 For amplifier LFO, this is measured in decibels and can range from -10 to 10. For pitch and filter LFO, this is measured in cents and can range from -1200 to 1200. Whether these values are negative or positive, the LFO will oscillate both up and down around the center value of the amplitude, pitch or filter cutoff - a negative sign for depth only inverts the phase. For cases where an LFO needs to oscillate only in one direction from the normal value (for example: typical guitar vibrato which only bends the pitch upwards, or saxophone vibrato which only bends the pitch down), an offset to the center pitch value will need to be added using the appropriate opcode such as tune. In SFZ2 LFOs add the ability to set the starting phase, making this much easier.","title":"Examples"},{"location":"opcodes/fillfo_depthchanaft/","text":"Examples amplfo_depth=1 pitchlfo_depth=40 For amplifier LFO, this is measured in decibels and can range from -10 to 10. For pitch and filter LFO, this is measured in cents and can range from -1200 to 1200. Whether these values are negative or positive, the LFO will oscillate both up and down around the center value of the amplitude, pitch or filter cutoff - a negative sign for depth only inverts the phase. For cases where an LFO needs to oscillate only in one direction from the normal value (for example: typical guitar vibrato which only bends the pitch upwards, or saxophone vibrato which only bends the pitch down), an offset to the center pitch value will need to be added using the appropriate opcode such as tune. In SFZ2 LFOs add the ability to set the starting phase, making this much easier.","title":"Fillfo depthchanaft"},{"location":"opcodes/fillfo_depthchanaft/#examples","text":"amplfo_depth=1 pitchlfo_depth=40 For amplifier LFO, this is measured in decibels and can range from -10 to 10. For pitch and filter LFO, this is measured in cents and can range from -1200 to 1200. Whether these values are negative or positive, the LFO will oscillate both up and down around the center value of the amplitude, pitch or filter cutoff - a negative sign for depth only inverts the phase. For cases where an LFO needs to oscillate only in one direction from the normal value (for example: typical guitar vibrato which only bends the pitch upwards, or saxophone vibrato which only bends the pitch down), an offset to the center pitch value will need to be added using the appropriate opcode such as tune. In SFZ2 LFOs add the ability to set the starting phase, making this much easier.","title":"Examples"},{"location":"opcodes/fillfo_depthpolyaft/","text":"Examples amplfo_depth=1 pitchlfo_depth=40 For amplifier LFO, this is measured in decibels and can range from -10 to 10. For pitch and filter LFO, this is measured in cents and can range from -1200 to 1200. Whether these values are negative or positive, the LFO will oscillate both up and down around the center value of the amplitude, pitch or filter cutoff - a negative sign for depth only inverts the phase. For cases where an LFO needs to oscillate only in one direction from the normal value (for example: typical guitar vibrato which only bends the pitch upwards, or saxophone vibrato which only bends the pitch down), an offset to the center pitch value will need to be added using the appropriate opcode such as tune. In SFZ2 LFOs add the ability to set the starting phase, making this much easier.","title":"Fillfo depthpolyaft"},{"location":"opcodes/fillfo_depthpolyaft/#examples","text":"amplfo_depth=1 pitchlfo_depth=40 For amplifier LFO, this is measured in decibels and can range from -10 to 10. For pitch and filter LFO, this is measured in cents and can range from -1200 to 1200. Whether these values are negative or positive, the LFO will oscillate both up and down around the center value of the amplitude, pitch or filter cutoff - a negative sign for depth only inverts the phase. For cases where an LFO needs to oscillate only in one direction from the normal value (for example: typical guitar vibrato which only bends the pitch upwards, or saxophone vibrato which only bends the pitch down), an offset to the center pitch value will need to be added using the appropriate opcode such as tune. In SFZ2 LFOs add the ability to set the starting phase, making this much easier.","title":"Examples"},{"location":"opcodes/fillfo_fade/","text":"Examples amplfo_fade=1 pitchfo_fade=0.4 Useful for vibrato which grows in intensity gradually, as commonly performed by bowed string players.","title":"Fillfo fade"},{"location":"opcodes/fillfo_fade/#examples","text":"amplfo_fade=1 pitchfo_fade=0.4 Useful for vibrato which grows in intensity gradually, as commonly performed by bowed string players.","title":"Examples"},{"location":"opcodes/fillfo_freq/","text":"Examples amplfo_freq=0.4 amplfo_freq=10 Range is 0 to 20 Hertz, according to the SFZ spec, which means audio-rate LFOs, similar to what is found in some classic hardware synthesizers, are not possible. Some players may in fact be able to utilize higher rates, but 20 Hz is the upper limit required by the SFZ specification.","title":"Fillfo freq"},{"location":"opcodes/fillfo_freq/#examples","text":"amplfo_freq=0.4 amplfo_freq=10 Range is 0 to 20 Hertz, according to the SFZ spec, which means audio-rate LFOs, similar to what is found in some classic hardware synthesizers, are not possible. Some players may in fact be able to utilize higher rates, but 20 Hz is the upper limit required by the SFZ specification.","title":"Examples"},{"location":"opcodes/fillfo_freqccN/","text":"Examples amplfo_freq=0.4 amplfo_freq=10 Range is 0 to 20 Hertz, according to the SFZ spec, which means audio-rate LFOs, similar to what is found in some classic hardware synthesizers, are not possible. Some players may in fact be able to utilize higher rates, but 20 Hz is the upper limit required by the SFZ specification.","title":"fillfo freqccN"},{"location":"opcodes/fillfo_freqccN/#examples","text":"amplfo_freq=0.4 amplfo_freq=10 Range is 0 to 20 Hertz, according to the SFZ spec, which means audio-rate LFOs, similar to what is found in some classic hardware synthesizers, are not possible. Some players may in fact be able to utilize higher rates, but 20 Hz is the upper limit required by the SFZ specification.","title":"Examples"},{"location":"opcodes/fillfo_freqchanaft/","text":"Examples amplfo_freq=0.4 amplfo_freq=10 Range is 0 to 20 Hertz, according to the SFZ spec, which means audio-rate LFOs, similar to what is found in some classic hardware synthesizers, are not possible. Some players may in fact be able to utilize higher rates, but 20 Hz is the upper limit required by the SFZ specification.","title":"Fillfo freqchanaft"},{"location":"opcodes/fillfo_freqchanaft/#examples","text":"amplfo_freq=0.4 amplfo_freq=10 Range is 0 to 20 Hertz, according to the SFZ spec, which means audio-rate LFOs, similar to what is found in some classic hardware synthesizers, are not possible. Some players may in fact be able to utilize higher rates, but 20 Hz is the upper limit required by the SFZ specification.","title":"Examples"},{"location":"opcodes/fillfo_freqpolyaft/","text":"Examples amplfo_freq=0.4 amplfo_freq=10 Range is 0 to 20 Hertz, according to the SFZ spec, which means audio-rate LFOs, similar to what is found in some classic hardware synthesizers, are not possible. Some players may in fact be able to utilize higher rates, but 20 Hz is the upper limit required by the SFZ specification.","title":"Fillfo freqpolyaft"},{"location":"opcodes/fillfo_freqpolyaft/#examples","text":"amplfo_freq=0.4 amplfo_freq=10 Range is 0 to 20 Hertz, according to the SFZ spec, which means audio-rate LFOs, similar to what is found in some classic hardware synthesizers, are not possible. Some players may in fact be able to utilize higher rates, but 20 Hz is the upper limit required by the SFZ specification.","title":"Examples"},{"location":"opcodes/filter_cutoff/","text":"Used under the \u2039effect\u203a header, with type = filter .","title":"Filter cutoff"},{"location":"opcodes/filter_cutoff_onccN/","text":"Used under the \u2039effect\u203a header, with type = filter .","title":"filter cutoff onccN"},{"location":"opcodes/filter_resonance/","text":"Used under the \u2039effect\u203a header, with type = filter .","title":"Filter resonance"},{"location":"opcodes/filter_resonance_onccN/","text":"Used under the \u2039effect\u203a header, with type = filter .","title":"filter resonance onccN"},{"location":"opcodes/filter_type/","text":"Used under the \u2039effect\u203a header, with type = filter .","title":"Filter type"},{"location":"opcodes/filtype/","text":"Allows you to choose which type of filter you use if not specified (ie.: only cutoff and resonance in the SFZ). fil_type was created in SFZ v1, so under that specification level only the v1 filters listed below are supported. fil2_type was added later in SFZ v2 as a second filter to be used in series, so under the v2 specification level both opcodes include both v1 and v2 filters. ARIA adds three more possible values for both opcodes. Examples fil_type=lpf_2p fil_type=hpf_1p Passive tone controls in guitars are one-pole low pass filters. Typical subtractive synthesizer filters are two-pole filters. fil2_type=hpf_2p The combination of fil and fil2 can be used to have, for example, both a high-pass and a low-pass filter, like this. In the below example, the first filter does not have a type set explicitly, so fil_type defaults to lpf_2p, making it a lowpass filter. The second filter is set to be a highpass filter. cutoff=1200 resonance=6 fil2_type=hpf_2p cutoff2=250 resonance2=3 Practical Considerations lsh , hsh and peq are ARIA extensions, allowing filters to be used as low-shelf, high-shelf or up to two additional parametric EQ bands, in addition to the default three eqN bands. Filters of these three types use fil_gain or fil2_gain to set the gain of the shelf or band.","title":"fil_type / fil2_type"},{"location":"opcodes/filtype/#examples","text":"fil_type=lpf_2p fil_type=hpf_1p Passive tone controls in guitars are one-pole low pass filters. Typical subtractive synthesizer filters are two-pole filters. fil2_type=hpf_2p The combination of fil and fil2 can be used to have, for example, both a high-pass and a low-pass filter, like this. In the below example, the first filter does not have a type set explicitly, so fil_type defaults to lpf_2p, making it a lowpass filter. The second filter is set to be a highpass filter. cutoff=1200 resonance=6 fil2_type=hpf_2p cutoff2=250 resonance2=3","title":"Examples"},{"location":"opcodes/filtype/#practical-considerations","text":"lsh , hsh and peq are ARIA extensions, allowing filters to be used as low-shelf, high-shelf or up to two additional parametric EQ bands, in addition to the default three eqN bands. Filters of these three types use fil_gain or fil2_gain to set the gain of the shelf or band.","title":"Practical Considerations"},{"location":"opcodes/fxNtomain/","text":"Global, can be set under any \u2039effect\u203a header for identical result. N: 1-4, see routing graph. Translates from % into a linear gain 0-1.","title":"fxNtomain"},{"location":"opcodes/fxNtomix/","text":"Global, can be set under any [\u2039effect\u203a] header for identical result. N: 1-4, see routing graph. Translates from % into a linear gain 0-1.","title":"fxNtomix"},{"location":"opcodes/gain_ccN/","text":"Range is -144.6 to 6 in the specification, but many SFZ players can utilize values above 6. Sfz.dll, Rapture and Dimension have a +24 dB maximum, and ARIA has an upper limit of at least +144, perhaps even more. Examples volume=-24 volume=0 volume=3.5 gain_cc1=12 This will play the sample at unchanged volume when CC1 is at 0, and apply a 12 dB boost when CC1 is at maximum. gain_ccN / volume_onccN is useful for creating volume controls. In Aria, either gain or volume can be used in modulations; however, gain by itself (for example gain=5) is not valid. For a fixed volume change wihtout modulation, only volume works.","title":"gain ccN"},{"location":"opcodes/gain_ccN/#examples","text":"volume=-24 volume=0 volume=3.5 gain_cc1=12 This will play the sample at unchanged volume when CC1 is at 0, and apply a 12 dB boost when CC1 is at maximum. gain_ccN / volume_onccN is useful for creating volume controls. In Aria, either gain or volume can be used in modulations; however, gain by itself (for example gain=5) is not valid. For a fixed volume change wihtout modulation, only volume works.","title":"Examples"},{"location":"opcodes/gain_onccN/","text":"Range is -144.6 to 6 in the specification, but many SFZ players can utilize values above 6. Sfz.dll, Rapture and Dimension have a +24 dB maximum, and ARIA has an upper limit of at least +144, perhaps even more. Examples volume=-24 volume=0 volume=3.5 gain_cc1=12 This will play the sample at unchanged volume when CC1 is at 0, and apply a 12 dB boost when CC1 is at maximum. gain_ccN / volume_onccN is useful for creating volume controls. In Aria, either gain or volume can be used in modulations; however, gain by itself (for example gain=5) is not valid. For a fixed volume change wihtout modulation, only volume works.","title":"gain onccN"},{"location":"opcodes/gain_onccN/#examples","text":"volume=-24 volume=0 volume=3.5 gain_cc1=12 This will play the sample at unchanged volume when CC1 is at 0, and apply a 12 dB boost when CC1 is at maximum. gain_ccN / volume_onccN is useful for creating volume controls. In Aria, either gain or volume can be used in modulations; however, gain by itself (for example gain=5) is not valid. For a fixed volume change wihtout modulation, only volume works.","title":"Examples"},{"location":"opcodes/gain_random/","text":"Computed when the note is triggered, remains the same for that region for as long as the region plays. Examples amp_random=10 amp_random=3 volume=-3 amp_random=6 Practical Considerations In ARIA and Cakewalk, amp_random is unipolar. To create variation which can be either negative or positive, this needs to be combined with a fixed volume offset for half the negative value that amp_random is set to. In the rgc sfz player, amp_random is bipolar.","title":"Gain random"},{"location":"opcodes/gain_random/#examples","text":"amp_random=10 amp_random=3 volume=-3 amp_random=6","title":"Examples"},{"location":"opcodes/gain_random/#practical-considerations","text":"In ARIA and Cakewalk, amp_random is unipolar. To create variation which can be either negative or positive, this needs to be combined with a fixed volume offset for half the negative value that amp_random is set to. In the rgc sfz player, amp_random is bipolar.","title":"Practical Considerations"},{"location":"opcodes/gate_attack/","text":"Used under the \u2039effect\u203a header, with type = gate .","title":"Gate attack"},{"location":"opcodes/gate_onccN/","text":"Used under the \u2039effect\u203a header, with type = gate .","title":"gate onccN"},{"location":"opcodes/gate_release/","text":"Used under the \u2039effect\u203a header, with type = gate .","title":"Gate release"},{"location":"opcodes/gate_stlink/","text":"Used under the \u2039effect\u203a header, with type = gate .","title":"Gate stlink"},{"location":"opcodes/gate_threshold/","text":"Used under the \u2039effect\u203a header, with type = gate .","title":"Gate threshold"},{"location":"opcodes/global_amplitude/","text":"Example global_amplitude=60","title":"Global amplitude"},{"location":"opcodes/global_amplitude/#example","text":"global_amplitude=60","title":"Example"},{"location":"opcodes/global_label/","text":"Useful for debugging. It can be set anywhere, not just under the \u2039global\u203a header. Examples global_label=Acoustic piano global_label=Test legato patch","title":"Global label"},{"location":"opcodes/global_label/#examples","text":"global_label=Acoustic piano global_label=Test legato patch","title":"Examples"},{"location":"opcodes/global_tune/","text":"","title":"Global tune"},{"location":"opcodes/global_volume/","text":"","title":"Global volume"},{"location":"opcodes/group/","text":"ARIA adds also the polyphony_group alias to reduce the confusion between the group opcode and the \u2039 group \u203a header. Examples group=3 group=334 The group opcode is used together with off_by to make something monophonic. For example, the flute is by nature a monophonic instrument, so if a flute were recorded with one microphone and had one set of samples, it would make sense to set all its samples to have one group. A guitar is polyphonic, but each string is monophonic, so a six-string guitar would naturally be split into six groups - one per string. In these cases, the group number will be equal to the off_by number. This is also commonly used with hi-hats - this is an example of where things can get more sophisticated with a large number of groups involved, as it's possible to set more closed hi-hat sounds mute more open ones, but not vice-versa, and it's also quite possible that there are separate close mic, overhead and room samples. group and off_by can also be used in other contexts where one sound should cause another to stop but enforcing monophony is not the goal - for example, a crash cymbal doesn't need to be monophonic, as allowing the sound to build up is reasonably natural, but if we wanted to implement a cymbal choke, then the crash sounds would be in one group, the choke samples in another. Practical Considerations The actual minimum and maximum values are not currently known. Some players will treat numbers outside a certain range as equivalent to group=0, and ARIA/Sforzando will also do this with text strings. The behavior of non-integer numbers is also currently unknown. This makes it possible to use an extremely large number for one group, but it's obviously not recommended.","title":"Group"},{"location":"opcodes/group/#examples","text":"group=3 group=334 The group opcode is used together with off_by to make something monophonic. For example, the flute is by nature a monophonic instrument, so if a flute were recorded with one microphone and had one set of samples, it would make sense to set all its samples to have one group. A guitar is polyphonic, but each string is monophonic, so a six-string guitar would naturally be split into six groups - one per string. In these cases, the group number will be equal to the off_by number. This is also commonly used with hi-hats - this is an example of where things can get more sophisticated with a large number of groups involved, as it's possible to set more closed hi-hat sounds mute more open ones, but not vice-versa, and it's also quite possible that there are separate close mic, overhead and room samples. group and off_by can also be used in other contexts where one sound should cause another to stop but enforcing monophony is not the goal - for example, a crash cymbal doesn't need to be monophonic, as allowing the sound to build up is reasonably natural, but if we wanted to implement a cymbal choke, then the crash sounds would be in one group, the choke samples in another.","title":"Examples"},{"location":"opcodes/group/#practical-considerations","text":"The actual minimum and maximum values are not currently known. Some players will treat numbers outside a certain range as equivalent to group=0, and ARIA/Sforzando will also do this with text strings. The behavior of non-integer numbers is also currently unknown. This makes it possible to use an extremely large number for one group, but it's obviously not recommended.","title":"Practical Considerations"},{"location":"opcodes/group_amplitude/","text":"Example group_amplitude=60","title":"Group amplitude"},{"location":"opcodes/group_amplitude/#example","text":"group_amplitude=60","title":"Example"},{"location":"opcodes/group_label/","text":"Useful for debugging. It can be set anywhere, not just under the \u2039 group \u203a header. Example group_label=Edge","title":"Group label"},{"location":"opcodes/group_label/#example","text":"group_label=Edge","title":"Example"},{"location":"opcodes/group_tune/","text":"","title":"Group tune"},{"location":"opcodes/group_volume/","text":"","title":"Group volume"},{"location":"opcodes/hibend/","text":"The region will play only if last Pitch Bend message received was in the 0 to 4000 range. Examples lobend=0 hibend=4000","title":"lobend / hibend"},{"location":"opcodes/hibend/#examples","text":"lobend=0 hibend=4000","title":"Examples"},{"location":"opcodes/hibpm/","text":"Host tempo value. The region will play if the host tempo is equal to or higher than lobpm , and lower than hibpm . Examples lobpm=0 hibpm=100 lobpm=100 hibpm=200.5","title":"lobpm / hibpm"},{"location":"opcodes/hibpm/#examples","text":"lobpm=0 hibpm=100 lobpm=100 hibpm=200.5","title":"Examples"},{"location":"opcodes/hiccN/","text":"N will normally be a number from 1 to 127. Examples locc74=30 hicc74=100 The region will play only if last MIDI controller 74 received was in the 30 to 100 range. Allowed range is 0 to 127. The defaults are loccN=0 and hiccN=127. Practical applications include using MIDI CC to switch things on and off - for example, additional voices, release noises, vibrato etc. A common example would be having a hi-hat with various degrees of openness sampled, all of those mapped to the same MIDI note, and hicc/locc used to define the ranges for which each degree of openness should play. A simpler example would be switching between sine, saw and noise waveforms: <region>hicc1=63 sample=*sine <region>locc1=64 hicc=126 sample=*saw <region>locc1=127 sample=*noise This is a \"hard\" switch - if a region is within the locc to hicc range it plays, if it's outside that range it does not play. For smooth fades controlled by CC (such as crossfaded dynamic layers or crossfaded vibrato layers on sustained instruments), other opcodes such as xfin_loccN / xfin_hiccN and xfout_loccN / xfout_hiccN should be used, or perhaps the amplitude_onccN ARIA extension.","title":"loccN / hiccN"},{"location":"opcodes/hiccN/#examples","text":"locc74=30 hicc74=100 The region will play only if last MIDI controller 74 received was in the 30 to 100 range. Allowed range is 0 to 127. The defaults are loccN=0 and hiccN=127. Practical applications include using MIDI CC to switch things on and off - for example, additional voices, release noises, vibrato etc. A common example would be having a hi-hat with various degrees of openness sampled, all of those mapped to the same MIDI note, and hicc/locc used to define the ranges for which each degree of openness should play. A simpler example would be switching between sine, saw and noise waveforms: <region>hicc1=63 sample=*sine <region>locc1=64 hicc=126 sample=*saw <region>locc1=127 sample=*noise This is a \"hard\" switch - if a region is within the locc to hicc range it plays, if it's outside that range it does not play. For smooth fades controlled by CC (such as crossfaded dynamic layers or crossfaded vibrato layers on sustained instruments), other opcodes such as xfin_loccN / xfin_hiccN and xfout_loccN / xfout_hiccN should be used, or perhaps the amplitude_onccN ARIA extension.","title":"Examples"},{"location":"opcodes/hichan/","text":"lochan and hichan will almost always be used together. One application of this is SFZ files which are to be controlled from MIDI guitar controllers, which send MIDI data for each string on a separate MIDI channel. The regions for that string would then have lochan and hichan set to the proper number. Examples lochan=1 hichan=7 lochan=2 hichan=2","title":"lochan / hichan"},{"location":"opcodes/hichan/#examples","text":"lochan=1 hichan=7 lochan=2 hichan=2","title":"Examples"},{"location":"opcodes/hichanaft/","text":"Examples The region will play only if last Channel Aftertouch message received was in the 30-100 range. lochanaft=30 hichanaft=100","title":"lochanaft / hichanaft"},{"location":"opcodes/hichanaft/#examples","text":"The region will play only if last Channel Aftertouch message received was in the 30-100 range. lochanaft=30 hichanaft=100","title":"Examples"},{"location":"opcodes/hihdccN/","text":"Other opcodes such as set_hdccN can also be used with these. Example lohdcc90=0.333 hihdcc90=0.7","title":"lohdccN / hihdccN"},{"location":"opcodes/hihdccN/#example","text":"lohdcc90=0.333 hihdcc90=0.7","title":"Example"},{"location":"opcodes/hikey/","text":"When a region only covers one note, it is generally more convenient to use key instead of hikey and lokey . When hikey and lokey are used, they will usually need to be used together with pitch_keycenter . These opcodes, as well as key , can use either MIDI note numbers (0 to 127) or MIDI note names (e.g. c3 or D#4). Using note numbers is recommended, however, as note numbers are interpreted consistently, while the same note names can be mapped to note numbers an octave or even two apart in different DAWs. In the SFZ 1 specification, the allowed range is 0 to 127. However, SFZ 2 additionally includes the possibility to set lokey and hikey to -1, to prevent a region from being triggered by any keys. This is a way (though, admittedly, not a very elegant one) to use the on_loccN / onhiccN opcodes to trigger, for example, pedal noises which are triggered whether any keys are pressed or not. Examples <region> sample=*sine lokey=72 hikey=84 As with the key opcode, the values can also be MIDI note names: <region> sample=*sine lokey=c5 hikey=c6 When an instrument is sampled every minor third, this kind of usage will be common: <region> sample=a4.wav lokey=68 hikey=70 pitch_keycenter=69 <region> sample=c5.wav lokey=71 hikey=73 pitch_keycenter=72 <region> sample=eb5.wav lokey=74 hikey=76 pitch_keycenter=75","title":"lokey / hikey"},{"location":"opcodes/hikey/#examples","text":"<region> sample=*sine lokey=72 hikey=84 As with the key opcode, the values can also be MIDI note names: <region> sample=*sine lokey=c5 hikey=c6 When an instrument is sampled every minor third, this kind of usage will be common: <region> sample=a4.wav lokey=68 hikey=70 pitch_keycenter=69 <region> sample=c5.wav lokey=71 hikey=73 pitch_keycenter=72 <region> sample=eb5.wav lokey=74 hikey=76 pitch_keycenter=75","title":"Examples"},{"location":"opcodes/hint_/","text":"ARIA supports specific opcodes in \u2039 control \u203a which start with \"hint\", these should be ignored by any other SFZ parser. Other engines could implement other hints as they wished. A useful case is hint_ram_based =1, which will cause the samples to be loaded into RAM in their entirety, instead of preloading only starts into RAM and streaming the rest from disk. This can be useful for preventing sound dropout with larger instruments on lower-performance systems, or instruments located on a HDD.","title":"Hint "},{"location":"opcodes/hipolyaft/","text":"Example The region will play only if last Polyphonic Aftertouch message received was in the 30-100 range. lopolyaft=30 hipolyaft=100 Practical Considerations In the rgcaudio sfz player, the incoming note information in the Polyphonic Aftertouch message is not relevant (which basically means polyphonic aftertouch isn't polyphonic, and works like channel aftertouch). In ARIA, the incoming note information is used, and polyphonic aftertouch works polyphonically. Other SFZ players need testing.","title":"lopolyaft / hipolyaft"},{"location":"opcodes/hipolyaft/#example","text":"The region will play only if last Polyphonic Aftertouch message received was in the 30-100 range. lopolyaft=30 hipolyaft=100","title":"Example"},{"location":"opcodes/hipolyaft/#practical-considerations","text":"In the rgcaudio sfz player, the incoming note information in the Polyphonic Aftertouch message is not relevant (which basically means polyphonic aftertouch isn't polyphonic, and works like channel aftertouch). In ARIA, the incoming note information is used, and polyphonic aftertouch works polyphonically. Other SFZ players need testing.","title":"Practical Considerations"},{"location":"opcodes/hiprog/","text":"MIDI program numbers in the General MIDI spec ranged from 0 to 127 but were often displayed externally as 1 to 128. This uses the 0 to 127 range. By default, most DAWs seem to have the program number set to 0, so setting loprog higher than 0 without sending program change messages results in no sound. Examples loprog=0 hiprog=0 loprog=1 hiprog=1 loprog=10 hiprog=12","title":"loprog / hiprog"},{"location":"opcodes/hiprog/#examples","text":"loprog=0 hiprog=0 loprog=1 hiprog=1 loprog=10 hiprog=12","title":"Examples"},{"location":"opcodes/hirand/","text":"Random values. The player will generate a new random number on every note-on event, in the range 0 to 1. Examples lorand=0.2 hirand=0.4 lorand=0.4 hirand=1 The most common application for this is randomized round robins. Note that hirand for a region should equal lorand for the next region - if we had, for example, hirand =0.249 for the first region and lorand =0.25 for the next, that would result in no sound playing if the random number generated was, for example, 0.2496343491. So, an 0.001 chance of no sound at all - a difficult problem to spot when testing. <region> hirand=0.25 sample=kick_vl1_rr1.wav <region> lorand=0.25 hirand=0.5 sample=kick_vl1_rr2.wav <region> lorand=0.5 hirand=0.75 sample=kick_vl1_rr3.wav <region> lorand=0.75 sample=kick_vl1_rr4.wav It is also possible to combine this with the seq_length and seq_position opcodes to split round robins into two subsets, and randomize within each subset. This results in randomization, but prevents the possibility of the same sample being triggered twice in a row when the random number generated falls into the same range as the previously generated number. This can be good when there are a lot (6 or more) round robin samples available. The code for 8 samples split into two sequential subsets might look like this: <region> seq_length=2 seq_position=1 hirand=0.25 sample=kick_vl1_rr1.wav <region> seq_length=2 seq_position=1 lorand=0.25 hirand=0.5 sample=kick_vl1_rr2.wav <region> seq_length=2 seq_position=1 lorand=0.5 hirand=0.75 sample=kick_vl1_rr3.wav <region> seq_length=2 seq_position=1 lorand=0.75 sample=kick_vl1_rr4.wav <region> seq_length=2 seq_position=2 hirand=0.25 sample=kick_vl1_rr5.wav <region> seq_length=2 seq_position=2 lorand=0.25 hirand=0.5 sample=kick_vl1_rr6.wav <region> seq_length=2 seq_position=2 lorand=0.5 hirand=0.75 sample=kick_vl1_rr7.wav <region> seq_length=2 seq_position=2 lorand=0.75 sample=kick_vl1_rr8.wav Practical Considerations In the ARIA implementation of SFZ, sequence position is not tracked together for all regions, which means the above is not a practical way to implement alternating left/right hand or up/down bowing samples. Also in ARIA, a separate random number is generated for each region which is playing, which means lorand/hirand probably should not be used with samples which have multiple mic positions. Using it can result in triggering spot, overhead and room mics which do not match, and that can result in phasing issues etc. There are other potential uses which have nothing to do with round robins, for example having key fingering noises on a clarinet trigger sometimes (but not always) when a note is played.","title":"lorand / hirand"},{"location":"opcodes/hirand/#examples","text":"lorand=0.2 hirand=0.4 lorand=0.4 hirand=1 The most common application for this is randomized round robins. Note that hirand for a region should equal lorand for the next region - if we had, for example, hirand =0.249 for the first region and lorand =0.25 for the next, that would result in no sound playing if the random number generated was, for example, 0.2496343491. So, an 0.001 chance of no sound at all - a difficult problem to spot when testing. <region> hirand=0.25 sample=kick_vl1_rr1.wav <region> lorand=0.25 hirand=0.5 sample=kick_vl1_rr2.wav <region> lorand=0.5 hirand=0.75 sample=kick_vl1_rr3.wav <region> lorand=0.75 sample=kick_vl1_rr4.wav It is also possible to combine this with the seq_length and seq_position opcodes to split round robins into two subsets, and randomize within each subset. This results in randomization, but prevents the possibility of the same sample being triggered twice in a row when the random number generated falls into the same range as the previously generated number. This can be good when there are a lot (6 or more) round robin samples available. The code for 8 samples split into two sequential subsets might look like this: <region> seq_length=2 seq_position=1 hirand=0.25 sample=kick_vl1_rr1.wav <region> seq_length=2 seq_position=1 lorand=0.25 hirand=0.5 sample=kick_vl1_rr2.wav <region> seq_length=2 seq_position=1 lorand=0.5 hirand=0.75 sample=kick_vl1_rr3.wav <region> seq_length=2 seq_position=1 lorand=0.75 sample=kick_vl1_rr4.wav <region> seq_length=2 seq_position=2 hirand=0.25 sample=kick_vl1_rr5.wav <region> seq_length=2 seq_position=2 lorand=0.25 hirand=0.5 sample=kick_vl1_rr6.wav <region> seq_length=2 seq_position=2 lorand=0.5 hirand=0.75 sample=kick_vl1_rr7.wav <region> seq_length=2 seq_position=2 lorand=0.75 sample=kick_vl1_rr8.wav","title":"Examples"},{"location":"opcodes/hirand/#practical-considerations","text":"In the ARIA implementation of SFZ, sequence position is not tracked together for all regions, which means the above is not a practical way to implement alternating left/right hand or up/down bowing samples. Also in ARIA, a separate random number is generated for each region which is playing, which means lorand/hirand probably should not be used with samples which have multiple mic positions. Using it can result in triggering spot, overhead and room mics which do not match, and that can result in phasing issues etc. There are other potential uses which have nothing to do with round robins, for example having key fingering noises on a clarinet trigger sometimes (but not always) when a note is played.","title":"Practical Considerations"},{"location":"opcodes/hitimer/","text":"Not implemented in ARIA, may have been implemented in some Cakewalk products. The timer is how long has passed since the last sample had played in the same group. It is, however, not known whether this is a group header or polyphony group. Examples <region> hitimer=0.25 sample=quick.wav <region> lotimer=0.25 sample=slow.wav","title":"lotimer / hitimer"},{"location":"opcodes/hitimer/#examples","text":"<region> hitimer=0.25 sample=quick.wav <region> lotimer=0.25 sample=slow.wav","title":"Examples"},{"location":"opcodes/hivel/","text":"This is obviously useful for instruments with dynamic layers controlled by velocity. Though dynamic layers can also be controlled by CC, especially for sustained instruments, lovel and hivel are the standard way of controlling dynamics for instruments such as drums and pianos. It is also possible to use lovel / hivel to control other things instead, such as articulations - for example, a guitar could have palm-muted samples on low velocities, and pinch harmonics on velocity 127. These opcodes will often need to be used with amp_velcurve_N , unless amp_veltrack is set to 0. The reason for this is that with default velocity tracking behavior and non-normalized samples (and there are many reasons why normalizing samples should be avoided), the quiet velocity layers will be too quiet. Velocity 0 is a note-off message, so 1 is the lowest usable value with hivel/lovel. Example lovel=64 hivel=95 An instrument with four velocity-controlled dynamic layers might use lovel and hivel like this: <region>hivel=31 amp_velcurve_31=1 sample=kick_vl1.wav <region>lovel=32 hivel=63 amp_velcurve_63=1 sample=kick_vl2.wav <region>lovel=64 hivel=95 amp_velcurve_95=1 sample=kick_vl3.wav <region>lovel=96 sample=kick_vl4.wav The way this would work is the kick_vl1.wav region will play at velocities up to 31, with volume going gradually from 0 at velocity 0 (so, no sound) to full volume at velocity 31. The kick_vl2.wav region will play at velocties 32 to 63, with volume being full at velocity 63 and lower volume (but not zero) at 32. The kick_vl3 wav region will play at velocites 64 to 95, with full volume at velocity 95. Finally, the kick_vl4 layer plays at velocities 96 to 127, with no amp_velcurve_N set meaning it will have full volume at velocity 127.","title":"lovel / hivel"},{"location":"opcodes/hivel/#example","text":"lovel=64 hivel=95 An instrument with four velocity-controlled dynamic layers might use lovel and hivel like this: <region>hivel=31 amp_velcurve_31=1 sample=kick_vl1.wav <region>lovel=32 hivel=63 amp_velcurve_63=1 sample=kick_vl2.wav <region>lovel=64 hivel=95 amp_velcurve_95=1 sample=kick_vl3.wav <region>lovel=96 sample=kick_vl4.wav The way this would work is the kick_vl1.wav region will play at velocities up to 31, with volume going gradually from 0 at velocity 0 (so, no sound) to full volume at velocity 31. The kick_vl2.wav region will play at velocties 32 to 63, with volume being full at velocity 63 and lower volume (but not zero) at 32. The kick_vl3 wav region will play at velocites 64 to 95, with full volume at velocity 95. Finally, the kick_vl4 layer plays at velocities 96 to 127, with no amp_velcurve_N set meaning it will have full volume at velocity 127.","title":"Example"},{"location":"opcodes/image/","text":"Practical Considerations Supported in Cakewalk DropZone, sfizz and possibly other players, but not ARIA / Sforzando. DropZone supports bitmap images with transparent alpha channels, showing one image per instrument and can be placed under any header. The visible image is approximately 530x150 pixels. If a larger image is loaded, only the top left part will be visible. If set multiple times, the last image set in the SFZ file is actually used. Dimension Pro parses but ignores the opcode. sfizz supports it under the <control> header only, together with a custom image_controls opcode to support an additional image in its controls tab. The image size is 775x335 pixels with 1:1 aspect ratio, not limited to BMP images.","title":"Image"},{"location":"opcodes/image/#practical-considerations","text":"Supported in Cakewalk DropZone, sfizz and possibly other players, but not ARIA / Sforzando. DropZone supports bitmap images with transparent alpha channels, showing one image per instrument and can be placed under any header. The visible image is approximately 530x150 pixels. If a larger image is loaded, only the top left part will be visible. If set multiple times, the last image set in the SFZ file is actually used. Dimension Pro parses but ignores the opcode. sfizz supports it under the <control> header only, together with a custom image_controls opcode to support an additional image in its controls tab. The image size is 775x335 pixels with 1:1 aspect ratio, not limited to BMP images.","title":"Practical Considerations"},{"location":"opcodes/include/","text":"The file to which #include points is, in effect, pasted into the SFZ file at the point of the #include. This means that the file structure needs to be respected - after all #includes are processed, \u2039control\u203a header needs to be before the regions in the file, \u2039curve\u203a opcodes need to be at the bottom etc. This can be nested - #included files can contain more #includes of their own, though of course recursion must be avoided! The included path must be surrounded by double quotes, similar to how include works in C/C++ files. Note that this is different from how the paths in the sample opcode works, which do not need quotes. Either a filename or a path can be used. If the #included files are in another folder, the SFZ is interpreted as if it was in the main SFZ file's path, not the path where the #included files are. The #included files can either have the extension sfz or sfzh, which is functionally no different from sfz, just used for clarity when #including a header. This is useful for creating large complex files, and also for simplifying the management of files which repeat similar regions with different opcodes. This is especially convenient in conjunction with the \u2039master\u203a header. Examples #include \"header.sfz\" #include \"note_map.sfz\" #include \"legato/dynfade_legato_first_map.sfz\" Here's an example of how #include and master can be used together: <global> loop_mode=one_shot off_mode=normal tune=-1200 //Everything is tuned down an octave, then tuned back up with its own tune param pan=-100 //Similar for pan - hard left, brought to proper position with param pan_oncc10=0 //Disable master pan amplitude_oncc7=100 ampeg_attack=0.001 ampeg_decay=0.7 ampeg_sustain=100 <master> amplitude_cc30=100 pan_cc31=200 tune_cc32=2400 tune_cc55=-500 offset_cc33=3000 ampeg_sustain_oncc33=-100 #include \"mappings/bobobo_bass.sfz\" <master> amplitude_cc35=100 pan_cc36=200 tune_cc37=2400 offset_cc38=1500 ampeg_sustain_oncc38=-100 tune_cc55=-250 #include \"mappings/bobobo_tenor_l_1.sfz\" #include \"mappings/bobobo_tenor_l_2.sfz\" Using #include with #define in the same instrument requires care, especially if the same value has to be #defined to have different settings at different points in an instrument. The following does not work well in ARIA/Sforzando, assuming that B.sfz uses MYVAR : #define $MYVAR cc12 #include B.sfz #define $MYVAR cc13 #include B.sfz However, a workaround there is to use #include to put each #define statement in a separate file. In simple tests, that has been successful.","title":"Include"},{"location":"opcodes/include/#examples","text":"#include \"header.sfz\" #include \"note_map.sfz\" #include \"legato/dynfade_legato_first_map.sfz\" Here's an example of how #include and master can be used together: <global> loop_mode=one_shot off_mode=normal tune=-1200 //Everything is tuned down an octave, then tuned back up with its own tune param pan=-100 //Similar for pan - hard left, brought to proper position with param pan_oncc10=0 //Disable master pan amplitude_oncc7=100 ampeg_attack=0.001 ampeg_decay=0.7 ampeg_sustain=100 <master> amplitude_cc30=100 pan_cc31=200 tune_cc32=2400 tune_cc55=-500 offset_cc33=3000 ampeg_sustain_oncc33=-100 #include \"mappings/bobobo_bass.sfz\" <master> amplitude_cc35=100 pan_cc36=200 tune_cc37=2400 offset_cc38=1500 ampeg_sustain_oncc38=-100 tune_cc55=-250 #include \"mappings/bobobo_tenor_l_1.sfz\" #include \"mappings/bobobo_tenor_l_2.sfz\" Using #include with #define in the same instrument requires care, especially if the same value has to be #defined to have different settings at different points in an instrument. The following does not work well in ARIA/Sforzando, assuming that B.sfz uses MYVAR : #define $MYVAR cc12 #include B.sfz #define $MYVAR cc13 #include B.sfz However, a workaround there is to use #include to put each #define statement in a separate file. In simple tests, that has been successful.","title":"Examples"},{"location":"opcodes/internal/","text":"","title":"Internal"},{"location":"opcodes/key/","text":"Because of this, it is a very useful and convenient opcode for instruments which do not need to spread a sample across multiple notes. That means most chromatically sampled instruments or drum kits. key values can be specified in MIDI note numbers (0-127) or note names (IPN Standard). Numbers generally are better to use for getting the SFZ to behave the same in all DAWs. Example These two conventions will yield the same key mapping: key=72 // or key=c5 Both are also equivalent to: lokey=72 hikey=72 pitch_keycenter=72 Key can also be combined with the others, which will override the value set by key although key should be specified first. In ARIA, the value set by pitch_keycenter will always be used, whether key or pitch_keycenter is set first in the SFZ file. However, in some other players, setting pitch_keycenter to a different value than key is only effective if key is set first and pitch_keycenter second. Therefore, for compatibility, it is best to set key first, and pitch_keycenter later. key=72 lokey=70 Will be equivalent to lokey=70 hikey=72 pitch_keycenter=72 However, this would just be the same as setting key=72, as key comes later and the lokey value it would set will override the previous lokey. lokey=70 key=72","title":"Key"},{"location":"opcodes/key/#example","text":"These two conventions will yield the same key mapping: key=72 // or key=c5 Both are also equivalent to: lokey=72 hikey=72 pitch_keycenter=72 Key can also be combined with the others, which will override the value set by key although key should be specified first. In ARIA, the value set by pitch_keycenter will always be used, whether key or pitch_keycenter is set first in the SFZ file. However, in some other players, setting pitch_keycenter to a different value than key is only effective if key is set first and pitch_keycenter second. Therefore, for compatibility, it is best to set key first, and pitch_keycenter later. key=72 lokey=70 Will be equivalent to lokey=70 hikey=72 pitch_keycenter=72 However, this would just be the same as setting key=72, as key comes later and the lokey value it would set will override the previous lokey. lokey=70 key=72","title":"Example"},{"location":"opcodes/label_ccN/","text":"Used under the \u2039 control \u203a header. Some DAWs will display those labels as parameter names, and Sforzando will also use them in the Control tab if no GUI is defined. Examples label_cc30=Bass vol label_cc31=Bass pan label_cc32=Tune label_cc33=Mute","title":"label ccN"},{"location":"opcodes/label_ccN/#examples","text":"label_cc30=Bass vol label_cc31=Bass pan label_cc32=Tune label_cc33=Mute","title":"Examples"},{"location":"opcodes/label_keyN/","text":"Used under the \u2039 control \u203a header. Example label_key36=Bass Drum label_key38=Snare Drum label_key54=Tambourine label_key56=Cowbell","title":"label keyN"},{"location":"opcodes/label_keyN/#example","text":"label_key36=Bass Drum label_key38=Snare Drum label_key54=Tambourine label_key56=Cowbell","title":"Example"},{"location":"opcodes/label_outputN/","text":"Used under the \u2039 control \u203a header. Example <control> // Keep output labels short label_output0=Snare label_output1=Kick Drum <master> output=0 // ... <master> output=1 // ...","title":"label outputN"},{"location":"opcodes/label_outputN/#example","text":"<control> // Keep output labels short label_output0=Snare label_output1=Kick Drum <master> output=0 // ... <master> output=1 // ...","title":"Example"},{"location":"opcodes/lfoN_amplitude/","text":"","title":"lfoN amplitude"},{"location":"opcodes/lfoN_amplitude_onccX/","text":"","title":"lfoN amplitude onccX"},{"location":"opcodes/lfoN_amplitude_smoothccX/","text":"","title":"lfoN amplitude smoothccX"},{"location":"opcodes/lfoN_amplitude_stepccX/","text":"","title":"lfoN amplitude stepccX"},{"location":"opcodes/lfoN_bitred/","text":"","title":"lfoN bitred"},{"location":"opcodes/lfoN_bitred_onccX/","text":"","title":"lfoN bitred onccX"},{"location":"opcodes/lfoN_bitred_smoothccX/","text":"","title":"lfoN bitred smoothccX"},{"location":"opcodes/lfoN_bitred_stepccX/","text":"","title":"lfoN bitred stepccX"},{"location":"opcodes/lfoN_count/","text":"If this is not set, the LFO will run and continue to repeat as long as the region plays. Examples lfo01_count=2 lfo02_count=5","title":"lfoN count"},{"location":"opcodes/lfoN_count/#examples","text":"lfo01_count=2 lfo02_count=5","title":"Examples"},{"location":"opcodes/lfoN_cutoff/","text":"","title":"lfoN cutoff"},{"location":"opcodes/lfoN_cutoff2/","text":"","title":"lfoN cutoff2"},{"location":"opcodes/lfoN_cutoff2_onccX/","text":"","title":"lfoN cutoff2 onccX"},{"location":"opcodes/lfoN_cutoff2_smoothccX/","text":"","title":"lfoN cutoff2 smoothccX"},{"location":"opcodes/lfoN_cutoff2_stepccX/","text":"","title":"lfoN cutoff2 stepccX"},{"location":"opcodes/lfoN_cutoff_onccX/","text":"","title":"lfoN cutoff onccX"},{"location":"opcodes/lfoN_cutoff_smoothccX/","text":"","title":"lfoN cutoff smoothccX"},{"location":"opcodes/lfoN_cutoff_stepccX/","text":"","title":"lfoN cutoff stepccX"},{"location":"opcodes/lfoN_decim/","text":"","title":"lfoN decim"},{"location":"opcodes/lfoN_decim_onccX/","text":"","title":"lfoN decim onccX"},{"location":"opcodes/lfoN_decim_smoothccX/","text":"","title":"lfoN decim smoothccX"},{"location":"opcodes/lfoN_decim_stepccX/","text":"","title":"lfoN decim stepccX"},{"location":"opcodes/lfoN_delay/","text":"Often useful for delaying vibrato onset in strings, vocals, guitar, saxophone etc. Can be combined with lfoN_fade in some cases. Examples lfo01_delay=0.1 lfo02_delay=1.2 lfo02_delay_oncc20=2.5","title":"lfoN delay"},{"location":"opcodes/lfoN_delay/#examples","text":"lfo01_delay=0.1 lfo02_delay=1.2 lfo02_delay_oncc20=2.5","title":"Examples"},{"location":"opcodes/lfoN_delay_onccX/","text":"Often useful for delaying vibrato onset in strings, vocals, guitar, saxophone etc. Can be combined with lfoN_fade in some cases. Examples lfo01_delay=0.1 lfo02_delay=1.2 lfo02_delay_oncc20=2.5","title":"lfoN delay onccX"},{"location":"opcodes/lfoN_delay_onccX/#examples","text":"lfo01_delay=0.1 lfo02_delay=1.2 lfo02_delay_oncc20=2.5","title":"Examples"},{"location":"opcodes/lfoN_depth_lfoX/","text":"","title":"lfoN depth lfoX"},{"location":"opcodes/lfoN_depthadd_lfoX/","text":"","title":"lfoN depthadd lfoX"},{"location":"opcodes/lfoN_drive/","text":"","title":"lfoN drive"},{"location":"opcodes/lfoN_drive_onccX/","text":"","title":"lfoN drive onccX"},{"location":"opcodes/lfoN_drive_smoothccX/","text":"","title":"lfoN drive smoothccX"},{"location":"opcodes/lfoN_drive_stepccX/","text":"","title":"lfoN drive stepccX"},{"location":"opcodes/lfoN_eqXbw/","text":"","title":"lfoN eqXbw"},{"location":"opcodes/lfoN_eqXbw_onccY/","text":"","title":"lfoN eqXbw onccY"},{"location":"opcodes/lfoN_eqXbw_smoothccY/","text":"","title":"lfoN eqXbw smoothccY"},{"location":"opcodes/lfoN_eqXbw_stepccY/","text":"","title":"lfoN eqXbw stepccY"},{"location":"opcodes/lfoN_eqXfreq/","text":"","title":"lfoN eqXfreq"},{"location":"opcodes/lfoN_eqXfreq_onccY/","text":"","title":"lfoN eqXfreq onccY"},{"location":"opcodes/lfoN_eqXfreq_smoothccY/","text":"","title":"lfoN eqXfreq smoothccY"},{"location":"opcodes/lfoN_eqXfreq_stepccY/","text":"","title":"lfoN eqXfreq stepccY"},{"location":"opcodes/lfoN_eqXgain/","text":"","title":"lfoN eqXgain"},{"location":"opcodes/lfoN_eqXgain_onccY/","text":"","title":"lfoN eqXgain onccY"},{"location":"opcodes/lfoN_eqXgain_smoothccY/","text":"","title":"lfoN eqXgain smoothccY"},{"location":"opcodes/lfoN_eqXgain_stepccY/","text":"","title":"lfoN eqXgain stepccY"},{"location":"opcodes/lfoN_fade/","text":"Can be quite useful for making vibrato sound more realistic on instruments such as bowed strings, usually combined with lfoN_delay . Examples lfo01_fade=0.1 lfo02_fade=1.2 lfo02_fade_oncc21=2.5","title":"lfoN fade"},{"location":"opcodes/lfoN_fade/#examples","text":"lfo01_fade=0.1 lfo02_fade=1.2 lfo02_fade_oncc21=2.5","title":"Examples"},{"location":"opcodes/lfoN_fade_onccX/","text":"Can be quite useful for making vibrato sound more realistic on instruments such as bowed strings, usually combined with lfoN_delay . Examples lfo01_fade=0.1 lfo02_fade=1.2 lfo02_fade_oncc21=2.5","title":"lfoN fade onccX"},{"location":"opcodes/lfoN_fade_onccX/#examples","text":"lfo01_fade=0.1 lfo02_fade=1.2 lfo02_fade_oncc21=2.5","title":"Examples"},{"location":"opcodes/lfoN_freq/","text":"Can be modulated by MIDI CC, and the modulation can be smoothed so that rapid controller changes are applied with some \"inertia\". Examples lfo01_freq=2 lfo01_freq_oncc117=8.2 lfo01_freq_smoothcc117=50 lfo02_freq=7","title":"lfoN freq"},{"location":"opcodes/lfoN_freq/#examples","text":"lfo01_freq=2 lfo01_freq_oncc117=8.2 lfo01_freq_smoothcc117=50 lfo02_freq=7","title":"Examples"},{"location":"opcodes/lfoN_freq_lfoX/","text":"","title":"lfoN freq lfoX"},{"location":"opcodes/lfoN_freq_lfoX_onccY/","text":"","title":"lfoN freq lfoX onccY"},{"location":"opcodes/lfoN_freq_onccX/","text":"Can be modulated by MIDI CC, and the modulation can be smoothed so that rapid controller changes are applied with some \"inertia\". Examples lfo01_freq=2 lfo01_freq_oncc117=8.2 lfo01_freq_smoothcc117=50 lfo02_freq=7","title":"lfoN freq onccX"},{"location":"opcodes/lfoN_freq_onccX/#examples","text":"lfo01_freq=2 lfo01_freq_oncc117=8.2 lfo01_freq_smoothcc117=50 lfo02_freq=7","title":"Examples"},{"location":"opcodes/lfoN_freq_smoothccX/","text":"Can be modulated by MIDI CC, and the modulation can be smoothed so that rapid controller changes are applied with some \"inertia\". Examples lfo01_freq=2 lfo01_freq_oncc117=8.2 lfo01_freq_smoothcc117=50 lfo02_freq=7","title":"lfoN freq smoothccX"},{"location":"opcodes/lfoN_freq_smoothccX/#examples","text":"lfo01_freq=2 lfo01_freq_oncc117=8.2 lfo01_freq_smoothcc117=50 lfo02_freq=7","title":"Examples"},{"location":"opcodes/lfoN_freq_stepccX/","text":"Can be modulated by MIDI CC, and the modulation can be smoothed so that rapid controller changes are applied with some \"inertia\". Examples lfo01_freq=2 lfo01_freq_oncc117=8.2 lfo01_freq_smoothcc117=50 lfo02_freq=7","title":"lfoN freq stepccX"},{"location":"opcodes/lfoN_freq_stepccX/#examples","text":"lfo01_freq=2 lfo01_freq_oncc117=8.2 lfo01_freq_smoothcc117=50 lfo02_freq=7","title":"Examples"},{"location":"opcodes/lfoN_noiselevel/","text":"","title":"lfoN noiselevel"},{"location":"opcodes/lfoN_noiselevel_onccX/","text":"","title":"lfoN noiselevel onccX"},{"location":"opcodes/lfoN_noiselevel_smoothccX/","text":"","title":"lfoN noiselevel smoothccX"},{"location":"opcodes/lfoN_noiselevel_stepccX/","text":"","title":"lfoN noiselevel stepccX"},{"location":"opcodes/lfoN_noisestep/","text":"","title":"lfoN noisestep"},{"location":"opcodes/lfoN_noisestep_onccX/","text":"","title":"lfoN noisestep onccX"},{"location":"opcodes/lfoN_noisestep_smoothccX/","text":"","title":"lfoN noisestep smoothccX"},{"location":"opcodes/lfoN_noisestep_stepccX/","text":"","title":"lfoN noisestep stepccX"},{"location":"opcodes/lfoN_noisetone/","text":"","title":"lfoN noisetone"},{"location":"opcodes/lfoN_noisetone_onccX/","text":"","title":"lfoN noisetone onccX"},{"location":"opcodes/lfoN_noisetone_smoothccX/","text":"","title":"lfoN noisetone smoothccX"},{"location":"opcodes/lfoN_noisetone_stepccX/","text":"","title":"lfoN noisetone stepccX"},{"location":"opcodes/lfoN_offset/","text":"It's possible for one LFO to use sub waveforms in addition to the main waveform. This can be used to create more complex LFOs. Up to 8 waveforms can be used in one LFO. The second waveform is set by lfoN_offset2 , the third by lfoN_offset3 etc. Using lfoN_offset with no number after the offset sets the offset for the main waveform, which is perhaps not needed very often. Offset will likely mostly be used on the sub waveforms, but it can also be set for the main waveform if needed. Examples lfo01_offset=0.1 lfo02_offset2=-0.3 lfo03_offset2=0.25 lfo03_offset3=0.419 lfo01_wave=12 //S&H style LFO used here for randomization lfo01_pitch=10 lfo01_freq=2 lfo01_freq_oncc1=3 lfo01_wave2=1 //Sine waveform for the secondary waveform lfo01_ratio2=4 //4 times faster lfo01_offset2=0 //No offset lfo01_scale2=0.3 //Shallower than the main wave","title":"lfoN offset"},{"location":"opcodes/lfoN_offset/#examples","text":"lfo01_offset=0.1 lfo02_offset2=-0.3 lfo03_offset2=0.25 lfo03_offset3=0.419 lfo01_wave=12 //S&H style LFO used here for randomization lfo01_pitch=10 lfo01_freq=2 lfo01_freq_oncc1=3 lfo01_wave2=1 //Sine waveform for the secondary waveform lfo01_ratio2=4 //4 times faster lfo01_offset2=0 //No offset lfo01_scale2=0.3 //Shallower than the main wave","title":"Examples"},{"location":"opcodes/lfoN_offsetX/","text":"It's possible for one LFO to use sub waveforms in addition to the main waveform. This can be used to create more complex LFOs. Up to 8 waveforms can be used in one LFO. The second waveform is set by lfoN_offset2 , the third by lfoN_offset3 etc. Using lfoN_offset with no number after the offset sets the offset for the main waveform, which is perhaps not needed very often. Offset will likely mostly be used on the sub waveforms, but it can also be set for the main waveform if needed. Examples lfo01_offset=0.1 lfo02_offset2=-0.3 lfo03_offset2=0.25 lfo03_offset3=0.419 lfo01_wave=12 //S&H style LFO used here for randomization lfo01_pitch=10 lfo01_freq=2 lfo01_freq_oncc1=3 lfo01_wave2=1 //Sine waveform for the secondary waveform lfo01_ratio2=4 //4 times faster lfo01_offset2=0 //No offset lfo01_scale2=0.3 //Shallower than the main wave","title":"lfoN offsetX"},{"location":"opcodes/lfoN_offsetX/#examples","text":"lfo01_offset=0.1 lfo02_offset2=-0.3 lfo03_offset2=0.25 lfo03_offset3=0.419 lfo01_wave=12 //S&H style LFO used here for randomization lfo01_pitch=10 lfo01_freq=2 lfo01_freq_oncc1=3 lfo01_wave2=1 //Sine waveform for the secondary waveform lfo01_ratio2=4 //4 times faster lfo01_offset2=0 //No offset lfo01_scale2=0.3 //Shallower than the main wave","title":"Examples"},{"location":"opcodes/lfoN_pan/","text":"","title":"lfoN pan"},{"location":"opcodes/lfoN_pan_onccX/","text":"","title":"lfoN pan onccX"},{"location":"opcodes/lfoN_pan_smoothccX/","text":"","title":"lfoN pan smoothccX"},{"location":"opcodes/lfoN_pan_stepccX/","text":"","title":"lfoN pan stepccX"},{"location":"opcodes/lfoN_phase/","text":"Example lfo02_phase=0.5 lfo01_phase=0.25 If the wave is a sine (the default shape), then phase 0 means the LFO starts at value 0 (center) and goes up first. Phase 0.5 means starting at 0 and going down first. Phase 0.25 means starting at 1 (max).","title":"lfoN phase"},{"location":"opcodes/lfoN_phase/#example","text":"lfo02_phase=0.5 lfo01_phase=0.25 If the wave is a sine (the default shape), then phase 0 means the LFO starts at value 0 (center) and goes up first. Phase 0.5 means starting at 0 and going down first. Phase 0.25 means starting at 1 (max).","title":"Example"},{"location":"opcodes/lfoN_phase_onccX/","text":"Example lfo02_phase=0.5 lfo01_phase=0.25 If the wave is a sine (the default shape), then phase 0 means the LFO starts at value 0 (center) and goes up first. Phase 0.5 means starting at 0 and going down first. Phase 0.25 means starting at 1 (max).","title":"lfoN phase onccX"},{"location":"opcodes/lfoN_phase_onccX/#example","text":"lfo02_phase=0.5 lfo01_phase=0.25 If the wave is a sine (the default shape), then phase 0 means the LFO starts at value 0 (center) and goes up first. Phase 0.5 means starting at 0 and going down first. Phase 0.25 means starting at 1 (max).","title":"Example"},{"location":"opcodes/lfoN_pitch/","text":"Destination for lfoN which effects the pitch of the region. The value assigned to the opcode is in cents, and oscillates up/down from the base frequency of the played region. For example playing middle C (MIDI note number 60) with lfo1_pitch set to 100 cents, the oscillation will be between C# a semitone above, and B a semitone below. Negative cents are supported, which effects the start pitch of the region. For example lfo1_freq=100 will start at C# then oscillate downwards to B, while lfo1_freq=-100 will start at B and oscillate upwards to C#. Example: <region> sample=*sine lfo1_freq=2 // frequency of the LFO in hertz, (2 oscillations per second) lfo1_pitch=100 // value in cents","title":"lfoN pitch"},{"location":"opcodes/lfoN_pitch/#example","text":"<region> sample=*sine lfo1_freq=2 // frequency of the LFO in hertz, (2 oscillations per second) lfo1_pitch=100 // value in cents","title":"Example:"},{"location":"opcodes/lfoN_pitch_curveccX/","text":"Destination for lfoN which effects the pitch of the region. The value assigned to the opcode is in cents, and oscillates up/down from the base frequency of the played region. For example playing middle C (MIDI note number 60) with lfo1_pitch set to 100 cents, the oscillation will be between C# a semitone above, and B a semitone below. Negative cents are supported, which effects the start pitch of the region. For example lfo1_freq=100 will start at C# then oscillate downwards to B, while lfo1_freq=-100 will start at B and oscillate upwards to C#. Example: <region> sample=*sine lfo1_freq=2 // frequency of the LFO in hertz, (2 oscillations per second) lfo1_pitch=100 // value in cents","title":"lfoN pitch curveccX"},{"location":"opcodes/lfoN_pitch_curveccX/#example","text":"<region> sample=*sine lfo1_freq=2 // frequency of the LFO in hertz, (2 oscillations per second) lfo1_pitch=100 // value in cents","title":"Example:"},{"location":"opcodes/lfoN_pitch_onccX/","text":"Destination for lfoN which effects the pitch of the region. The value assigned to the opcode is in cents, and oscillates up/down from the base frequency of the played region. For example playing middle C (MIDI note number 60) with lfo1_pitch set to 100 cents, the oscillation will be between C# a semitone above, and B a semitone below. Negative cents are supported, which effects the start pitch of the region. For example lfo1_freq=100 will start at C# then oscillate downwards to B, while lfo1_freq=-100 will start at B and oscillate upwards to C#. Example: <region> sample=*sine lfo1_freq=2 // frequency of the LFO in hertz, (2 oscillations per second) lfo1_pitch=100 // value in cents","title":"lfoN pitch onccX"},{"location":"opcodes/lfoN_pitch_onccX/#example","text":"<region> sample=*sine lfo1_freq=2 // frequency of the LFO in hertz, (2 oscillations per second) lfo1_pitch=100 // value in cents","title":"Example:"},{"location":"opcodes/lfoN_pitch_smoothccX/","text":"Destination for lfoN which effects the pitch of the region. The value assigned to the opcode is in cents, and oscillates up/down from the base frequency of the played region. For example playing middle C (MIDI note number 60) with lfo1_pitch set to 100 cents, the oscillation will be between C# a semitone above, and B a semitone below. Negative cents are supported, which effects the start pitch of the region. For example lfo1_freq=100 will start at C# then oscillate downwards to B, while lfo1_freq=-100 will start at B and oscillate upwards to C#. Example: <region> sample=*sine lfo1_freq=2 // frequency of the LFO in hertz, (2 oscillations per second) lfo1_pitch=100 // value in cents","title":"lfoN pitch smoothccX"},{"location":"opcodes/lfoN_pitch_smoothccX/#example","text":"<region> sample=*sine lfo1_freq=2 // frequency of the LFO in hertz, (2 oscillations per second) lfo1_pitch=100 // value in cents","title":"Example:"},{"location":"opcodes/lfoN_pitch_stepccX/","text":"Destination for lfoN which effects the pitch of the region. The value assigned to the opcode is in cents, and oscillates up/down from the base frequency of the played region. For example playing middle C (MIDI note number 60) with lfo1_pitch set to 100 cents, the oscillation will be between C# a semitone above, and B a semitone below. Negative cents are supported, which effects the start pitch of the region. For example lfo1_freq=100 will start at C# then oscillate downwards to B, while lfo1_freq=-100 will start at B and oscillate upwards to C#. Example: <region> sample=*sine lfo1_freq=2 // frequency of the LFO in hertz, (2 oscillations per second) lfo1_pitch=100 // value in cents","title":"lfoN pitch stepccX"},{"location":"opcodes/lfoN_pitch_stepccX/#example","text":"<region> sample=*sine lfo1_freq=2 // frequency of the LFO in hertz, (2 oscillations per second) lfo1_pitch=100 // value in cents","title":"Example:"},{"location":"opcodes/lfoN_ratio/","text":"It's possible for one LFO to use sub waveforms in addition to the main waveform. This can be used to create more complex LFOs. Up to 8 waveforms can be used in one LFO. The second waveform is set by lfoN_ratio2 , the third by lfoN_ratio3 etc. Using lfoN_ratio with no number after the ratio sets the ratio for the main waveform, which is perhaps not needed very often. Ratio will likely mostly be used on the sub waveforms, but it can also be set for the main waveform if needed. Example lfo01_ratio2=4 lfo03_ratio=0.321 lfo01_wave=12 //S&H style LFO used here for randomization lfo01_pitch=10 lfo01_freq=2 lfo01_freq_oncc1=3 lfo01_wave2=1 //Sine waveform for the secondary waveform lfo01_ratio2=4 //4 times faster lfo01_offset2=0 //No offset lfo01_scale2=0.3 //Shallower than the main wave","title":"lfoN ratio"},{"location":"opcodes/lfoN_ratio/#example","text":"lfo01_ratio2=4 lfo03_ratio=0.321 lfo01_wave=12 //S&H style LFO used here for randomization lfo01_pitch=10 lfo01_freq=2 lfo01_freq_oncc1=3 lfo01_wave2=1 //Sine waveform for the secondary waveform lfo01_ratio2=4 //4 times faster lfo01_offset2=0 //No offset lfo01_scale2=0.3 //Shallower than the main wave","title":"Example"},{"location":"opcodes/lfoN_ratioX/","text":"It's possible for one LFO to use sub waveforms in addition to the main waveform. This can be used to create more complex LFOs. Up to 8 waveforms can be used in one LFO. The second waveform is set by lfoN_ratio2 , the third by lfoN_ratio3 etc. Using lfoN_ratio with no number after the ratio sets the ratio for the main waveform, which is perhaps not needed very often. Ratio will likely mostly be used on the sub waveforms, but it can also be set for the main waveform if needed. Example lfo01_ratio2=4 lfo03_ratio=0.321 lfo01_wave=12 //S&H style LFO used here for randomization lfo01_pitch=10 lfo01_freq=2 lfo01_freq_oncc1=3 lfo01_wave2=1 //Sine waveform for the secondary waveform lfo01_ratio2=4 //4 times faster lfo01_offset2=0 //No offset lfo01_scale2=0.3 //Shallower than the main wave","title":"lfoN ratioX"},{"location":"opcodes/lfoN_ratioX/#example","text":"lfo01_ratio2=4 lfo03_ratio=0.321 lfo01_wave=12 //S&H style LFO used here for randomization lfo01_pitch=10 lfo01_freq=2 lfo01_freq_oncc1=3 lfo01_wave2=1 //Sine waveform for the secondary waveform lfo01_ratio2=4 //4 times faster lfo01_offset2=0 //No offset lfo01_scale2=0.3 //Shallower than the main wave","title":"Example"},{"location":"opcodes/lfoN_resonance/","text":"","title":"lfoN resonance"},{"location":"opcodes/lfoN_resonance2/","text":"","title":"lfoN resonance2"},{"location":"opcodes/lfoN_resonance2_onccX/","text":"","title":"lfoN resonance2 onccX"},{"location":"opcodes/lfoN_resonance2_smoothccX/","text":"","title":"lfoN resonance2 smoothccX"},{"location":"opcodes/lfoN_resonance2_stepccX/","text":"","title":"lfoN resonance2 stepccX"},{"location":"opcodes/lfoN_resonance_onccX/","text":"","title":"lfoN resonance onccX"},{"location":"opcodes/lfoN_resonance_smoothccX/","text":"","title":"lfoN resonance smoothccX"},{"location":"opcodes/lfoN_resonance_stepccX/","text":"","title":"lfoN resonance stepccX"},{"location":"opcodes/lfoN_sample_dyn_paramX/","text":"","title":"lfoN sample dyn paramX"},{"location":"opcodes/lfoN_sample_dyn_paramX_onccY/","text":"","title":"lfoN sample dyn paramX onccY"},{"location":"opcodes/lfoN_scale/","text":"It's possible for one LFO to use sub waveforms in addition to the main waveform. This can be used to create more complex LFOs. Up to 8 waveforms can be used in one LFO. The second waveform is set by lfoN_scale2 , the third by lfoN_scale3 etc. Using lfoN_scale with no number after the scale sets the scale for the main waveform, which is perhaps not needed very often. Scale will likely mostly be used on the sub waveforms, but it can also be set for the main waveform if needed. Example lfo01_scale2=0.5 lfo03_scale=0.7 lfo01_wave=12 //S&H style LFO used here for randomization lfo01_pitch=10 lfo01_freq=2 lfo01_freq_oncc1=3 lfo01_wave2=1 //Sine waveform for the secondary waveform lfo01_ratio2=4 //4 times faster lfo01_offset2=0 //No offset lfo01_scale2=0.3 //Shallower than the main wave","title":"lfoN scale"},{"location":"opcodes/lfoN_scale/#example","text":"lfo01_scale2=0.5 lfo03_scale=0.7 lfo01_wave=12 //S&H style LFO used here for randomization lfo01_pitch=10 lfo01_freq=2 lfo01_freq_oncc1=3 lfo01_wave2=1 //Sine waveform for the secondary waveform lfo01_ratio2=4 //4 times faster lfo01_offset2=0 //No offset lfo01_scale2=0.3 //Shallower than the main wave","title":"Example"},{"location":"opcodes/lfoN_scaleX/","text":"It's possible for one LFO to use sub waveforms in addition to the main waveform. This can be used to create more complex LFOs. Up to 8 waveforms can be used in one LFO. The second waveform is set by lfoN_scale2 , the third by lfoN_scale3 etc. Using lfoN_scale with no number after the scale sets the scale for the main waveform, which is perhaps not needed very often. Scale will likely mostly be used on the sub waveforms, but it can also be set for the main waveform if needed. Example lfo01_scale2=0.5 lfo03_scale=0.7 lfo01_wave=12 //S&H style LFO used here for randomization lfo01_pitch=10 lfo01_freq=2 lfo01_freq_oncc1=3 lfo01_wave2=1 //Sine waveform for the secondary waveform lfo01_ratio2=4 //4 times faster lfo01_offset2=0 //No offset lfo01_scale2=0.3 //Shallower than the main wave","title":"lfoN scaleX"},{"location":"opcodes/lfoN_scaleX/#example","text":"lfo01_scale2=0.5 lfo03_scale=0.7 lfo01_wave=12 //S&H style LFO used here for randomization lfo01_pitch=10 lfo01_freq=2 lfo01_freq_oncc1=3 lfo01_wave2=1 //Sine waveform for the secondary waveform lfo01_ratio2=4 //4 times faster lfo01_offset2=0 //No offset lfo01_scale2=0.3 //Shallower than the main wave","title":"Example"},{"location":"opcodes/lfoN_smooth/","text":"","title":"lfoN smooth"},{"location":"opcodes/lfoN_smooth_onccX/","text":"","title":"lfoN smooth onccX"},{"location":"opcodes/lfoN_stepX/","text":"The level of step number X in an LFO used as a step sequencer, which is possible in some Cakewalk products. Must have lfoN_steps set for the LFO in order for this to mean anything. Range is from -100% to 100%, and the range of the MIDI CC modulation is the same, though both added together will effectively be -100% or 100% if their sum exceeds one of those bounds. If this is not set for a particular step, the default value for that step is 0. Examples lfo01_step01=10 lfo01_step01_oncc1=50 lfo01_step02=80 lfo01_step02_oncc1=50","title":"lfoN stepX"},{"location":"opcodes/lfoN_stepX/#examples","text":"lfo01_step01=10 lfo01_step01_oncc1=50 lfo01_step02=80 lfo01_step02_oncc1=50","title":"Examples"},{"location":"opcodes/lfoN_stepX_onccY/","text":"The level of step number X in an LFO used as a step sequencer, which is possible in some Cakewalk products. Must have lfoN_steps set for the LFO in order for this to mean anything. Range is from -100% to 100%, and the range of the MIDI CC modulation is the same, though both added together will effectively be -100% or 100% if their sum exceeds one of those bounds. If this is not set for a particular step, the default value for that step is 0. Examples lfo01_step01=10 lfo01_step01_oncc1=50 lfo01_step02=80 lfo01_step02_oncc1=50","title":"lfoN stepX onccY"},{"location":"opcodes/lfoN_stepX_onccY/#examples","text":"lfo01_step01=10 lfo01_step01_oncc1=50 lfo01_step02=80 lfo01_step02_oncc1=50","title":"Examples"},{"location":"opcodes/lfoN_steps/","text":"The number of steps in the step sequencer. This can be used in some Cakewalk products, together with lfoN_stepX, to use an LFO as a step sequencer instead of a typical LFO. If both lfoN_steps and lfoN_wave are set for the same region, the one which is set later in the SFZ file takes effect - an LFO can't have both a wave and steps, so if lfoN_wave is set and then lfoN_steps is set, the LFO will only act as a step sequencer. lfoN_phase can't be used with step sequencers, but lfoN_delay, lfoN_fade and lfoN_count all can. Examples lfo3_steps=16 lfo1_steps=8","title":"lfoN steps"},{"location":"opcodes/lfoN_steps/#examples","text":"lfo3_steps=16 lfo1_steps=8","title":"Examples"},{"location":"opcodes/lfoN_volume/","text":"","title":"lfoN volume"},{"location":"opcodes/lfoN_volume_onccX/","text":"","title":"lfoN volume onccX"},{"location":"opcodes/lfoN_volume_smoothccX/","text":"","title":"lfoN volume smoothccX"},{"location":"opcodes/lfoN_volume_stepccX/","text":"","title":"lfoN volume stepccX"},{"location":"opcodes/lfoN_wave/","text":"In ARIA it's possible for one LFO to use sub waveforms in addition to the main waveform. This can be used to create more complex LFOs. Up to 8 waveforms can be used in one LFO. The second waveform is set by lfoN_wave2 , the third by lfoN_wave3 etc. lfoN_ratio2 is important for giving each wave a different frequency, and lfoN_scale2 scale lfoN_offsetX can optionally be used as well. In SFZ v2 , the waves are: triangle sine 75% pulse square (50% pulse) 25% pulse 12:5% pulse saw going up saw going down In ARIA , the waves are: deprecated, should not be used, but is random triangle sine 75% pulse square (50% pulse) 25% pulse 12:5% pulse saw going up saw going down used in Chipsounds used in Chipsounds future user LFO future user LFO random sample & hold, generating a random value between -1 and 1 twice per period stepped LFO Triangle is the default waveform in ARIA, though the SFZ1 LFOs in ARIA use the sine as the default waveform. The default waveforms in Cakewalk products or other SFZ players have not been tested. The waveforms supported in the other player engines need to be tested. Examples lfo01_wave=6 lfo02_wave=3 lfo01_wave2=1 lfo03_wave2=12 lfo01_wave=12 //S&H style LFO used here for randomization lfo01_pitch=10 lfo01_freq=2 lfo01_freq_oncc1=3 lfo01_wave2=1 //Sine waveform for the secondary waveform lfo01_ratio2=4 //4 times faster lfo01_offset2=0 //No offset lfo01_scale2=0.3 //Shallower than the main wave Wave 13 is a provision for ARIA to support SFZ 2.0's stepped LFO , equivalent to: lfo01_steps=4 lfo01_freq=1 lfo01_pitch=1200 lfo01_step01_oncc73=100 lfo01_step01_smoothcc73=100 lfo01_step02_oncc73=100 lfo01_step02_smoothcc73=100 lfo01_step03_oncc73=100 lfo01_step03_smoothcc73=100 lfo01_step04_oncc73=100 lfo01_step04_smoothcc73=100","title":"lfoN wave"},{"location":"opcodes/lfoN_wave/#examples","text":"lfo01_wave=6 lfo02_wave=3 lfo01_wave2=1 lfo03_wave2=12 lfo01_wave=12 //S&H style LFO used here for randomization lfo01_pitch=10 lfo01_freq=2 lfo01_freq_oncc1=3 lfo01_wave2=1 //Sine waveform for the secondary waveform lfo01_ratio2=4 //4 times faster lfo01_offset2=0 //No offset lfo01_scale2=0.3 //Shallower than the main wave Wave 13 is a provision for ARIA to support SFZ 2.0's stepped LFO , equivalent to: lfo01_steps=4 lfo01_freq=1 lfo01_pitch=1200 lfo01_step01_oncc73=100 lfo01_step01_smoothcc73=100 lfo01_step02_oncc73=100 lfo01_step02_smoothcc73=100 lfo01_step03_oncc73=100 lfo01_step03_smoothcc73=100 lfo01_step04_oncc73=100 lfo01_step04_smoothcc73=100","title":"Examples"},{"location":"opcodes/lfoN_waveX/","text":"In ARIA it's possible for one LFO to use sub waveforms in addition to the main waveform. This can be used to create more complex LFOs. Up to 8 waveforms can be used in one LFO. The second waveform is set by lfoN_wave2 , the third by lfoN_wave3 etc. lfoN_ratio2 is important for giving each wave a different frequency, and lfoN_scale2 scale lfoN_offsetX can optionally be used as well. In SFZ v2 , the waves are: triangle sine 75% pulse square (50% pulse) 25% pulse 12:5% pulse saw going up saw going down In ARIA , the waves are: deprecated, should not be used, but is random triangle sine 75% pulse square (50% pulse) 25% pulse 12:5% pulse saw going up saw going down used in Chipsounds used in Chipsounds future user LFO future user LFO random sample & hold, generating a random value between -1 and 1 twice per period stepped LFO Triangle is the default waveform in ARIA, though the SFZ1 LFOs in ARIA use the sine as the default waveform. The default waveforms in Cakewalk products or other SFZ players have not been tested. The waveforms supported in the other player engines need to be tested. Examples lfo01_wave=6 lfo02_wave=3 lfo01_wave2=1 lfo03_wave2=12 lfo01_wave=12 //S&H style LFO used here for randomization lfo01_pitch=10 lfo01_freq=2 lfo01_freq_oncc1=3 lfo01_wave2=1 //Sine waveform for the secondary waveform lfo01_ratio2=4 //4 times faster lfo01_offset2=0 //No offset lfo01_scale2=0.3 //Shallower than the main wave Wave 13 is a provision for ARIA to support SFZ 2.0's stepped LFO , equivalent to: lfo01_steps=4 lfo01_freq=1 lfo01_pitch=1200 lfo01_step01_oncc73=100 lfo01_step01_smoothcc73=100 lfo01_step02_oncc73=100 lfo01_step02_smoothcc73=100 lfo01_step03_oncc73=100 lfo01_step03_smoothcc73=100 lfo01_step04_oncc73=100 lfo01_step04_smoothcc73=100","title":"lfoN waveX"},{"location":"opcodes/lfoN_waveX/#examples","text":"lfo01_wave=6 lfo02_wave=3 lfo01_wave2=1 lfo03_wave2=12 lfo01_wave=12 //S&H style LFO used here for randomization lfo01_pitch=10 lfo01_freq=2 lfo01_freq_oncc1=3 lfo01_wave2=1 //Sine waveform for the secondary waveform lfo01_ratio2=4 //4 times faster lfo01_offset2=0 //No offset lfo01_scale2=0.3 //Shallower than the main wave Wave 13 is a provision for ARIA to support SFZ 2.0's stepped LFO , equivalent to: lfo01_steps=4 lfo01_freq=1 lfo01_pitch=1200 lfo01_step01_oncc73=100 lfo01_step01_smoothcc73=100 lfo01_step02_oncc73=100 lfo01_step02_smoothcc73=100 lfo01_step03_oncc73=100 lfo01_step03_smoothcc73=100 lfo01_step04_oncc73=100 lfo01_step04_smoothcc73=100","title":"Examples"},{"location":"opcodes/lfoN_wave_onccX/","text":"In ARIA it's possible for one LFO to use sub waveforms in addition to the main waveform. This can be used to create more complex LFOs. Up to 8 waveforms can be used in one LFO. The second waveform is set by lfoN_wave2 , the third by lfoN_wave3 etc. lfoN_ratio2 is important for giving each wave a different frequency, and lfoN_scale2 scale lfoN_offsetX can optionally be used as well. In SFZ v2 , the waves are: triangle sine 75% pulse square (50% pulse) 25% pulse 12:5% pulse saw going up saw going down In ARIA , the waves are: deprecated, should not be used, but is random triangle sine 75% pulse square (50% pulse) 25% pulse 12:5% pulse saw going up saw going down used in Chipsounds used in Chipsounds future user LFO future user LFO random sample & hold, generating a random value between -1 and 1 twice per period stepped LFO Triangle is the default waveform in ARIA, though the SFZ1 LFOs in ARIA use the sine as the default waveform. The default waveforms in Cakewalk products or other SFZ players have not been tested. The waveforms supported in the other player engines need to be tested. Examples lfo01_wave=6 lfo02_wave=3 lfo01_wave2=1 lfo03_wave2=12 lfo01_wave=12 //S&H style LFO used here for randomization lfo01_pitch=10 lfo01_freq=2 lfo01_freq_oncc1=3 lfo01_wave2=1 //Sine waveform for the secondary waveform lfo01_ratio2=4 //4 times faster lfo01_offset2=0 //No offset lfo01_scale2=0.3 //Shallower than the main wave Wave 13 is a provision for ARIA to support SFZ 2.0's stepped LFO , equivalent to: lfo01_steps=4 lfo01_freq=1 lfo01_pitch=1200 lfo01_step01_oncc73=100 lfo01_step01_smoothcc73=100 lfo01_step02_oncc73=100 lfo01_step02_smoothcc73=100 lfo01_step03_oncc73=100 lfo01_step03_smoothcc73=100 lfo01_step04_oncc73=100 lfo01_step04_smoothcc73=100","title":"lfoN wave onccX"},{"location":"opcodes/lfoN_wave_onccX/#examples","text":"lfo01_wave=6 lfo02_wave=3 lfo01_wave2=1 lfo03_wave2=12 lfo01_wave=12 //S&H style LFO used here for randomization lfo01_pitch=10 lfo01_freq=2 lfo01_freq_oncc1=3 lfo01_wave2=1 //Sine waveform for the secondary waveform lfo01_ratio2=4 //4 times faster lfo01_offset2=0 //No offset lfo01_scale2=0.3 //Shallower than the main wave Wave 13 is a provision for ARIA to support SFZ 2.0's stepped LFO , equivalent to: lfo01_steps=4 lfo01_freq=1 lfo01_pitch=1200 lfo01_step01_oncc73=100 lfo01_step01_smoothcc73=100 lfo01_step02_oncc73=100 lfo01_step02_smoothcc73=100 lfo01_step03_oncc73=100 lfo01_step03_smoothcc73=100 lfo01_step04_oncc73=100 lfo01_step04_smoothcc73=100","title":"Examples"},{"location":"opcodes/lfoN_width/","text":"","title":"lfoN width"},{"location":"opcodes/lfoN_width_onccX/","text":"","title":"lfoN width onccX"},{"location":"opcodes/lfoN_width_smoothccX/","text":"","title":"lfoN width smoothccX"},{"location":"opcodes/lfoN_width_stepccX/","text":"","title":"lfoN width stepccX"},{"location":"opcodes/load_end/","text":"","title":"Load end"},{"location":"opcodes/load_mode/","text":"","title":"Load mode"},{"location":"opcodes/load_start/","text":"","title":"Load start"},{"location":"opcodes/lobend/","text":"The region will play only if last Pitch Bend message received was in the 0 to 4000 range. Examples lobend=0 hibend=4000","title":"lobend / hibend"},{"location":"opcodes/lobend/#examples","text":"lobend=0 hibend=4000","title":"Examples"},{"location":"opcodes/lobpm/","text":"Host tempo value. The region will play if the host tempo is equal to or higher than lobpm , and lower than hibpm . Examples lobpm=0 hibpm=100 lobpm=100 hibpm=200.5","title":"lobpm / hibpm"},{"location":"opcodes/lobpm/#examples","text":"lobpm=0 hibpm=100 lobpm=100 hibpm=200.5","title":"Examples"},{"location":"opcodes/loccN/","text":"N will normally be a number from 1 to 127. Examples locc74=30 hicc74=100 The region will play only if last MIDI controller 74 received was in the 30 to 100 range. Allowed range is 0 to 127. The defaults are loccN=0 and hiccN=127. Practical applications include using MIDI CC to switch things on and off - for example, additional voices, release noises, vibrato etc. A common example would be having a hi-hat with various degrees of openness sampled, all of those mapped to the same MIDI note, and hicc/locc used to define the ranges for which each degree of openness should play. A simpler example would be switching between sine, saw and noise waveforms: <region>hicc1=63 sample=*sine <region>locc1=64 hicc=126 sample=*saw <region>locc1=127 sample=*noise This is a \"hard\" switch - if a region is within the locc to hicc range it plays, if it's outside that range it does not play. For smooth fades controlled by CC (such as crossfaded dynamic layers or crossfaded vibrato layers on sustained instruments), other opcodes such as xfin_loccN / xfin_hiccN and xfout_loccN / xfout_hiccN should be used, or perhaps the amplitude_onccN ARIA extension.","title":"loccN / hiccN"},{"location":"opcodes/loccN/#examples","text":"locc74=30 hicc74=100 The region will play only if last MIDI controller 74 received was in the 30 to 100 range. Allowed range is 0 to 127. The defaults are loccN=0 and hiccN=127. Practical applications include using MIDI CC to switch things on and off - for example, additional voices, release noises, vibrato etc. A common example would be having a hi-hat with various degrees of openness sampled, all of those mapped to the same MIDI note, and hicc/locc used to define the ranges for which each degree of openness should play. A simpler example would be switching between sine, saw and noise waveforms: <region>hicc1=63 sample=*sine <region>locc1=64 hicc=126 sample=*saw <region>locc1=127 sample=*noise This is a \"hard\" switch - if a region is within the locc to hicc range it plays, if it's outside that range it does not play. For smooth fades controlled by CC (such as crossfaded dynamic layers or crossfaded vibrato layers on sustained instruments), other opcodes such as xfin_loccN / xfin_hiccN and xfout_loccN / xfout_hiccN should be used, or perhaps the amplitude_onccN ARIA extension.","title":"Examples"},{"location":"opcodes/lochan/","text":"lochan and hichan will almost always be used together. One application of this is SFZ files which are to be controlled from MIDI guitar controllers, which send MIDI data for each string on a separate MIDI channel. The regions for that string would then have lochan and hichan set to the proper number. Examples lochan=1 hichan=7 lochan=2 hichan=2","title":"lochan / hichan"},{"location":"opcodes/lochan/#examples","text":"lochan=1 hichan=7 lochan=2 hichan=2","title":"Examples"},{"location":"opcodes/lochanaft/","text":"Examples The region will play only if last Channel Aftertouch message received was in the 30-100 range. lochanaft=30 hichanaft=100","title":"lochanaft / hichanaft"},{"location":"opcodes/lochanaft/#examples","text":"The region will play only if last Channel Aftertouch message received was in the 30-100 range. lochanaft=30 hichanaft=100","title":"Examples"},{"location":"opcodes/lohdccN/","text":"Other opcodes such as set_hdccN can also be used with these. Example lohdcc90=0.333 hihdcc90=0.7","title":"lohdccN / hihdccN"},{"location":"opcodes/lohdccN/#example","text":"lohdcc90=0.333 hihdcc90=0.7","title":"Example"},{"location":"opcodes/lokey/","text":"When a region only covers one note, it is generally more convenient to use key instead of hikey and lokey . When hikey and lokey are used, they will usually need to be used together with pitch_keycenter . These opcodes, as well as key , can use either MIDI note numbers (0 to 127) or MIDI note names (e.g. c3 or D#4). Using note numbers is recommended, however, as note numbers are interpreted consistently, while the same note names can be mapped to note numbers an octave or even two apart in different DAWs. In the SFZ 1 specification, the allowed range is 0 to 127. However, SFZ 2 additionally includes the possibility to set lokey and hikey to -1, to prevent a region from being triggered by any keys. This is a way (though, admittedly, not a very elegant one) to use the on_loccN / onhiccN opcodes to trigger, for example, pedal noises which are triggered whether any keys are pressed or not. Examples <region> sample=*sine lokey=72 hikey=84 As with the key opcode, the values can also be MIDI note names: <region> sample=*sine lokey=c5 hikey=c6 When an instrument is sampled every minor third, this kind of usage will be common: <region> sample=a4.wav lokey=68 hikey=70 pitch_keycenter=69 <region> sample=c5.wav lokey=71 hikey=73 pitch_keycenter=72 <region> sample=eb5.wav lokey=74 hikey=76 pitch_keycenter=75","title":"lokey / hikey"},{"location":"opcodes/lokey/#examples","text":"<region> sample=*sine lokey=72 hikey=84 As with the key opcode, the values can also be MIDI note names: <region> sample=*sine lokey=c5 hikey=c6 When an instrument is sampled every minor third, this kind of usage will be common: <region> sample=a4.wav lokey=68 hikey=70 pitch_keycenter=69 <region> sample=c5.wav lokey=71 hikey=73 pitch_keycenter=72 <region> sample=eb5.wav lokey=74 hikey=76 pitch_keycenter=75","title":"Examples"},{"location":"opcodes/loop_count/","text":"This is in addition to the time the sample is played unlooped, as normal, so loop_count=3 will result in the looped part of the sample being played four times, not three times. If the sample contains data after the end of the loop, this portion of the sample will be played after all repetitions of the loop have been completed (assuming no note-off message had been received by then). Examples loop_count=3 loop_count=15","title":"Loop count"},{"location":"opcodes/loop_count/#examples","text":"loop_count=3 loop_count=15","title":"Examples"},{"location":"opcodes/loop_crossfade/","text":"This can be used to add a crossfade to a loop where the looped sample does not have the crossfade \"baked into\" its audio data. Practical Considerations This opcode is uinimplemented in most SFZ players, but it is avaialble in OpenMPT and sfizz. sfizz currently uses a sinusoidal formula as default. \\[ amp = (1-cos(pi*x))/2 \\] OpenMPT's crossfade implementation currently applies a fade halfway between a constant volume fade and constant power fade. \\[ amp = pow(x, 0.75) \\]","title":"Loop crossfade"},{"location":"opcodes/loop_crossfade/#practical-considerations","text":"This opcode is uinimplemented in most SFZ players, but it is avaialble in OpenMPT and sfizz. sfizz currently uses a sinusoidal formula as default. \\[ amp = (1-cos(pi*x))/2 \\] OpenMPT's crossfade implementation currently applies a fade halfway between a constant volume fade and constant power fade. \\[ amp = pow(x, 0.75) \\]","title":"Practical Considerations"},{"location":"opcodes/loop_end/","text":"This is inclusive - the sample specified is played as part of the loop. If loop_end is not specified and the sample has a loop defined, the SFZ player will use the end point of the first loop defined in the file. That means for files with one loop, loop_end does not usually need to be set, as it's generally more practical to define loop points in an audio editor where they can be checked for smoothness, crossfaded if necessary etc. If loop_end is specified, it will be used instead the loop end point defined in the sample. For files which have multiple loops defined, this is the only way to get anything other than the first defined loop to play. This opcode will not have any effect if loop_mode is set to no_loop . Practical Considerations Loop endpoints can be modulated using loop_lengthccN in rgc sfz, and loop_length_onccN in Cakewalk products - though the term \"length\" is used, it's specifically the location of the end point which is modulated. In ARIA, if loop_end is not specified, the sample does not have a loop defined and loop_mode is set to loop_continuous or loop_sustain , the player will loop through the entire file. Not directly related to SFZ players, but causing a common error, some audio editors number samples starting with 1, while according to the WAV file specification the first sample should be number 0. If one of these editors is used to create sample files which have loop point information, and the loop endpoint is set to the last sample of the file, the SFZ player will think the loop endpoint is after the end of the file, and will return an error. The solution to this is either to reduce the loop start and endpoints in the WAV file by 1 each, or to set loop_start and loop_end in the SFZ. Examples loop_end=4503 loop_end=12445","title":"Loop end"},{"location":"opcodes/loop_end/#practical-considerations","text":"Loop endpoints can be modulated using loop_lengthccN in rgc sfz, and loop_length_onccN in Cakewalk products - though the term \"length\" is used, it's specifically the location of the end point which is modulated. In ARIA, if loop_end is not specified, the sample does not have a loop defined and loop_mode is set to loop_continuous or loop_sustain , the player will loop through the entire file. Not directly related to SFZ players, but causing a common error, some audio editors number samples starting with 1, while according to the WAV file specification the first sample should be number 0. If one of these editors is used to create sample files which have loop point information, and the loop endpoint is set to the last sample of the file, the SFZ player will think the loop endpoint is after the end of the file, and will return an error. The solution to this is either to reduce the loop start and endpoints in the WAV file by 1 each, or to set loop_start and loop_end in the SFZ.","title":"Practical Considerations"},{"location":"opcodes/loop_end/#examples","text":"loop_end=4503 loop_end=12445","title":"Examples"},{"location":"opcodes/loop_length_onccN/","text":"This is inclusive - the sample specified is played as part of the loop. If loop_end is not specified and the sample has a loop defined, the SFZ player will use the end point of the first loop defined in the file. That means for files with one loop, loop_end does not usually need to be set, as it's generally more practical to define loop points in an audio editor where they can be checked for smoothness, crossfaded if necessary etc. If loop_end is specified, it will be used instead the loop end point defined in the sample. For files which have multiple loops defined, this is the only way to get anything other than the first defined loop to play. This opcode will not have any effect if loop_mode is set to no_loop . Practical Considerations Loop endpoints can be modulated using loop_lengthccN in rgc sfz, and loop_length_onccN in Cakewalk products - though the term \"length\" is used, it's specifically the location of the end point which is modulated. In ARIA, if loop_end is not specified, the sample does not have a loop defined and loop_mode is set to loop_continuous or loop_sustain , the player will loop through the entire file. Not directly related to SFZ players, but causing a common error, some audio editors number samples starting with 1, while according to the WAV file specification the first sample should be number 0. If one of these editors is used to create sample files which have loop point information, and the loop endpoint is set to the last sample of the file, the SFZ player will think the loop endpoint is after the end of the file, and will return an error. The solution to this is either to reduce the loop start and endpoints in the WAV file by 1 each, or to set loop_start and loop_end in the SFZ. Examples loop_end=4503 loop_end=12445","title":"loop length onccN"},{"location":"opcodes/loop_length_onccN/#practical-considerations","text":"Loop endpoints can be modulated using loop_lengthccN in rgc sfz, and loop_length_onccN in Cakewalk products - though the term \"length\" is used, it's specifically the location of the end point which is modulated. In ARIA, if loop_end is not specified, the sample does not have a loop defined and loop_mode is set to loop_continuous or loop_sustain , the player will loop through the entire file. Not directly related to SFZ players, but causing a common error, some audio editors number samples starting with 1, while according to the WAV file specification the first sample should be number 0. If one of these editors is used to create sample files which have loop point information, and the loop endpoint is set to the last sample of the file, the SFZ player will think the loop endpoint is after the end of the file, and will return an error. The solution to this is either to reduce the loop start and endpoints in the WAV file by 1 each, or to set loop_start and loop_end in the SFZ.","title":"Practical Considerations"},{"location":"opcodes/loop_length_onccN/#examples","text":"loop_end=4503 loop_end=12445","title":"Examples"},{"location":"opcodes/loop_lengthccN/","text":"This is inclusive - the sample specified is played as part of the loop. If loop_end is not specified and the sample has a loop defined, the SFZ player will use the end point of the first loop defined in the file. That means for files with one loop, loop_end does not usually need to be set, as it's generally more practical to define loop points in an audio editor where they can be checked for smoothness, crossfaded if necessary etc. If loop_end is specified, it will be used instead the loop end point defined in the sample. For files which have multiple loops defined, this is the only way to get anything other than the first defined loop to play. This opcode will not have any effect if loop_mode is set to no_loop . Practical Considerations Loop endpoints can be modulated using loop_lengthccN in rgc sfz, and loop_length_onccN in Cakewalk products - though the term \"length\" is used, it's specifically the location of the end point which is modulated. In ARIA, if loop_end is not specified, the sample does not have a loop defined and loop_mode is set to loop_continuous or loop_sustain , the player will loop through the entire file. Not directly related to SFZ players, but causing a common error, some audio editors number samples starting with 1, while according to the WAV file specification the first sample should be number 0. If one of these editors is used to create sample files which have loop point information, and the loop endpoint is set to the last sample of the file, the SFZ player will think the loop endpoint is after the end of the file, and will return an error. The solution to this is either to reduce the loop start and endpoints in the WAV file by 1 each, or to set loop_start and loop_end in the SFZ. Examples loop_end=4503 loop_end=12445","title":"loop lengthccN"},{"location":"opcodes/loop_lengthccN/#practical-considerations","text":"Loop endpoints can be modulated using loop_lengthccN in rgc sfz, and loop_length_onccN in Cakewalk products - though the term \"length\" is used, it's specifically the location of the end point which is modulated. In ARIA, if loop_end is not specified, the sample does not have a loop defined and loop_mode is set to loop_continuous or loop_sustain , the player will loop through the entire file. Not directly related to SFZ players, but causing a common error, some audio editors number samples starting with 1, while according to the WAV file specification the first sample should be number 0. If one of these editors is used to create sample files which have loop point information, and the loop endpoint is set to the last sample of the file, the SFZ player will think the loop endpoint is after the end of the file, and will return an error. The solution to this is either to reduce the loop start and endpoints in the WAV file by 1 each, or to set loop_start and loop_end in the SFZ.","title":"Practical Considerations"},{"location":"opcodes/loop_lengthccN/#examples","text":"loop_end=4503 loop_end=12445","title":"Examples"},{"location":"opcodes/loop_mode/","text":"If loop_mode is not specified, each sample will play according to its predefined loop mode according to the loop metadata in the audio file. That is, the player will play the sample looped using the first defined loop, if available. If no loops are defined (which is usually the case with most files), the wave will play unlooped. The possible values are: no_loop : no looping will be performed. Sample will play straight from start to end, or until note off, whatever reaches first. one_shot : sample will play from start to end, ignoring note off. This is commonly used for drums. This mode is engaged automatically if the count opcode is defined. loop_continuous : once the player reaches sample loop point, the loop will play until note expiration. This includes looping during the release phase. loop_sustain : the player will play the loop while the note is held, by keeping it depressed or by using the sustain pedal (CC64). During the release phase, there's no looping. Whether no_loop, loop_continuous or loop_sustain is set, the duration of the release phase is set using ampeg_release . However, in loop_sustain or no_loop mode, the sound can be cut off before the release phase ends, if the end of sample is reached. In loop_continuous mode, the loop will repeat if the loop end is reached during the release phase, including repeating multiple times if the release time is longer than the loop length. Practical Considerations For samples with trigger =release set, no_loop and one_shot will both behave as one_shot and the entire release sample will play. If loop_continuous is set, looping will be applied - and unless loop_count is set or there is some other way the sound will be muted, that means the sound can potentially continue indefinitely. If an instrument is using the default loop_mode=no_loop, there is no need to set loop_mode=one_shot for the release samples; however, if an instrument has loop_mode=loop_continuous set under a header which also includes release samples, the release regions will normally need to be set to loop_mode=one_shot to override that. In ARIA, if loop_mode=loop_continuous or loop_sustain, loop_end is not specified, and the sample does not have a loop defined, the player will loop through the entire sample file. Examples loop_mode=no_loop loop_mode=loop_continuous","title":"Loop mode"},{"location":"opcodes/loop_mode/#practical-considerations","text":"For samples with trigger =release set, no_loop and one_shot will both behave as one_shot and the entire release sample will play. If loop_continuous is set, looping will be applied - and unless loop_count is set or there is some other way the sound will be muted, that means the sound can potentially continue indefinitely. If an instrument is using the default loop_mode=no_loop, there is no need to set loop_mode=one_shot for the release samples; however, if an instrument has loop_mode=loop_continuous set under a header which also includes release samples, the release regions will normally need to be set to loop_mode=one_shot to override that. In ARIA, if loop_mode=loop_continuous or loop_sustain, loop_end is not specified, and the sample does not have a loop defined, the player will loop through the entire sample file.","title":"Practical Considerations"},{"location":"opcodes/loop_mode/#examples","text":"loop_mode=no_loop loop_mode=loop_continuous","title":"Examples"},{"location":"opcodes/loop_start/","text":"If loop_start is not specified and the sample has a loop defined, the SFZ player will use the start point of the first loop defined in the file. That means for files with one loop, loop_start does not usually need to be set, as it's generally more practical to define loop points in an audio editor where they can be checked for smoothness, crossfaded if necessary etc. If loop_start is specified, it will be used instead the loop start point defined in the sample. For files which have multiple loops defined, this is the only way to get anything other than the first defined loop to play. This opcode will not have any effect if loop_mode is set to no_loop . Examples loop_start=4503 loop_start=12445","title":"Loop start"},{"location":"opcodes/loop_start/#examples","text":"loop_start=4503 loop_start=12445","title":"Examples"},{"location":"opcodes/loop_start_onccN/","text":"If loop_start is not specified and the sample has a loop defined, the SFZ player will use the start point of the first loop defined in the file. That means for files with one loop, loop_start does not usually need to be set, as it's generally more practical to define loop points in an audio editor where they can be checked for smoothness, crossfaded if necessary etc. If loop_start is specified, it will be used instead the loop start point defined in the sample. For files which have multiple loops defined, this is the only way to get anything other than the first defined loop to play. This opcode will not have any effect if loop_mode is set to no_loop . Examples loop_start=4503 loop_start=12445","title":"loop start onccN"},{"location":"opcodes/loop_start_onccN/#examples","text":"loop_start=4503 loop_start=12445","title":"Examples"},{"location":"opcodes/loop_startccN/","text":"If loop_start is not specified and the sample has a loop defined, the SFZ player will use the start point of the first loop defined in the file. That means for files with one loop, loop_start does not usually need to be set, as it's generally more practical to define loop points in an audio editor where they can be checked for smoothness, crossfaded if necessary etc. If loop_start is specified, it will be used instead the loop start point defined in the sample. For files which have multiple loops defined, this is the only way to get anything other than the first defined loop to play. This opcode will not have any effect if loop_mode is set to no_loop . Examples loop_start=4503 loop_start=12445","title":"loop startccN"},{"location":"opcodes/loop_startccN/#examples","text":"loop_start=4503 loop_start=12445","title":"Examples"},{"location":"opcodes/loop_tune/","text":"Examples loop_tune=-4 loop_tune=6 Useful with very short loops such as single-cycle waveforms, which can be slightly out of tune compared to the complete waveform from which they were cut.","title":"Loop tune"},{"location":"opcodes/loop_tune/#examples","text":"loop_tune=-4 loop_tune=6 Useful with very short loops such as single-cycle waveforms, which can be slightly out of tune compared to the complete waveform from which they were cut.","title":"Examples"},{"location":"opcodes/loop_type/","text":"This only affects the loop portion of the sample. To play a sample backwards with no looping, use direction instead.","title":"Loop type"},{"location":"opcodes/loopcount/","text":"This is in addition to the time the sample is played unlooped, as normal, so loop_count=3 will result in the looped part of the sample being played four times, not three times. If the sample contains data after the end of the loop, this portion of the sample will be played after all repetitions of the loop have been completed (assuming no note-off message had been received by then). Examples loop_count=3 loop_count=15","title":"Loopcount"},{"location":"opcodes/loopcount/#examples","text":"loop_count=3 loop_count=15","title":"Examples"},{"location":"opcodes/loopend/","text":"This is inclusive - the sample specified is played as part of the loop. If loop_end is not specified and the sample has a loop defined, the SFZ player will use the end point of the first loop defined in the file. That means for files with one loop, loop_end does not usually need to be set, as it's generally more practical to define loop points in an audio editor where they can be checked for smoothness, crossfaded if necessary etc. If loop_end is specified, it will be used instead the loop end point defined in the sample. For files which have multiple loops defined, this is the only way to get anything other than the first defined loop to play. This opcode will not have any effect if loop_mode is set to no_loop . Practical Considerations Loop endpoints can be modulated using loop_lengthccN in rgc sfz, and loop_length_onccN in Cakewalk products - though the term \"length\" is used, it's specifically the location of the end point which is modulated. In ARIA, if loop_end is not specified, the sample does not have a loop defined and loop_mode is set to loop_continuous or loop_sustain , the player will loop through the entire file. Not directly related to SFZ players, but causing a common error, some audio editors number samples starting with 1, while according to the WAV file specification the first sample should be number 0. If one of these editors is used to create sample files which have loop point information, and the loop endpoint is set to the last sample of the file, the SFZ player will think the loop endpoint is after the end of the file, and will return an error. The solution to this is either to reduce the loop start and endpoints in the WAV file by 1 each, or to set loop_start and loop_end in the SFZ. Examples loop_end=4503 loop_end=12445","title":"Loopend"},{"location":"opcodes/loopend/#practical-considerations","text":"Loop endpoints can be modulated using loop_lengthccN in rgc sfz, and loop_length_onccN in Cakewalk products - though the term \"length\" is used, it's specifically the location of the end point which is modulated. In ARIA, if loop_end is not specified, the sample does not have a loop defined and loop_mode is set to loop_continuous or loop_sustain , the player will loop through the entire file. Not directly related to SFZ players, but causing a common error, some audio editors number samples starting with 1, while according to the WAV file specification the first sample should be number 0. If one of these editors is used to create sample files which have loop point information, and the loop endpoint is set to the last sample of the file, the SFZ player will think the loop endpoint is after the end of the file, and will return an error. The solution to this is either to reduce the loop start and endpoints in the WAV file by 1 each, or to set loop_start and loop_end in the SFZ.","title":"Practical Considerations"},{"location":"opcodes/loopend/#examples","text":"loop_end=4503 loop_end=12445","title":"Examples"},{"location":"opcodes/loopmode/","text":"If loop_mode is not specified, each sample will play according to its predefined loop mode according to the loop metadata in the audio file. That is, the player will play the sample looped using the first defined loop, if available. If no loops are defined (which is usually the case with most files), the wave will play unlooped. The possible values are: no_loop : no looping will be performed. Sample will play straight from start to end, or until note off, whatever reaches first. one_shot : sample will play from start to end, ignoring note off. This is commonly used for drums. This mode is engaged automatically if the count opcode is defined. loop_continuous : once the player reaches sample loop point, the loop will play until note expiration. This includes looping during the release phase. loop_sustain : the player will play the loop while the note is held, by keeping it depressed or by using the sustain pedal (CC64). During the release phase, there's no looping. Whether no_loop, loop_continuous or loop_sustain is set, the duration of the release phase is set using ampeg_release . However, in loop_sustain or no_loop mode, the sound can be cut off before the release phase ends, if the end of sample is reached. In loop_continuous mode, the loop will repeat if the loop end is reached during the release phase, including repeating multiple times if the release time is longer than the loop length. Practical Considerations For samples with trigger =release set, no_loop and one_shot will both behave as one_shot and the entire release sample will play. If loop_continuous is set, looping will be applied - and unless loop_count is set or there is some other way the sound will be muted, that means the sound can potentially continue indefinitely. If an instrument is using the default loop_mode=no_loop, there is no need to set loop_mode=one_shot for the release samples; however, if an instrument has loop_mode=loop_continuous set under a header which also includes release samples, the release regions will normally need to be set to loop_mode=one_shot to override that. In ARIA, if loop_mode=loop_continuous or loop_sustain, loop_end is not specified, and the sample does not have a loop defined, the player will loop through the entire sample file. Examples loop_mode=no_loop loop_mode=loop_continuous","title":"Loopmode"},{"location":"opcodes/loopmode/#practical-considerations","text":"For samples with trigger =release set, no_loop and one_shot will both behave as one_shot and the entire release sample will play. If loop_continuous is set, looping will be applied - and unless loop_count is set or there is some other way the sound will be muted, that means the sound can potentially continue indefinitely. If an instrument is using the default loop_mode=no_loop, there is no need to set loop_mode=one_shot for the release samples; however, if an instrument has loop_mode=loop_continuous set under a header which also includes release samples, the release regions will normally need to be set to loop_mode=one_shot to override that. In ARIA, if loop_mode=loop_continuous or loop_sustain, loop_end is not specified, and the sample does not have a loop defined, the player will loop through the entire sample file.","title":"Practical Considerations"},{"location":"opcodes/loopmode/#examples","text":"loop_mode=no_loop loop_mode=loop_continuous","title":"Examples"},{"location":"opcodes/loopstart/","text":"If loop_start is not specified and the sample has a loop defined, the SFZ player will use the start point of the first loop defined in the file. That means for files with one loop, loop_start does not usually need to be set, as it's generally more practical to define loop points in an audio editor where they can be checked for smoothness, crossfaded if necessary etc. If loop_start is specified, it will be used instead the loop start point defined in the sample. For files which have multiple loops defined, this is the only way to get anything other than the first defined loop to play. This opcode will not have any effect if loop_mode is set to no_loop . Examples loop_start=4503 loop_start=12445","title":"Loopstart"},{"location":"opcodes/loopstart/#examples","text":"loop_start=4503 loop_start=12445","title":"Examples"},{"location":"opcodes/looptune/","text":"Examples loop_tune=-4 loop_tune=6 Useful with very short loops such as single-cycle waveforms, which can be slightly out of tune compared to the complete waveform from which they were cut.","title":"Looptune"},{"location":"opcodes/looptune/#examples","text":"loop_tune=-4 loop_tune=6 Useful with very short loops such as single-cycle waveforms, which can be slightly out of tune compared to the complete waveform from which they were cut.","title":"Examples"},{"location":"opcodes/looptype/","text":"This only affects the loop portion of the sample. To play a sample backwards with no looping, use direction instead.","title":"Looptype"},{"location":"opcodes/lopolyaft/","text":"Example The region will play only if last Polyphonic Aftertouch message received was in the 30-100 range. lopolyaft=30 hipolyaft=100 Practical Considerations In the rgcaudio sfz player, the incoming note information in the Polyphonic Aftertouch message is not relevant (which basically means polyphonic aftertouch isn't polyphonic, and works like channel aftertouch). In ARIA, the incoming note information is used, and polyphonic aftertouch works polyphonically. Other SFZ players need testing.","title":"lopolyaft / hipolyaft"},{"location":"opcodes/lopolyaft/#example","text":"The region will play only if last Polyphonic Aftertouch message received was in the 30-100 range. lopolyaft=30 hipolyaft=100","title":"Example"},{"location":"opcodes/lopolyaft/#practical-considerations","text":"In the rgcaudio sfz player, the incoming note information in the Polyphonic Aftertouch message is not relevant (which basically means polyphonic aftertouch isn't polyphonic, and works like channel aftertouch). In ARIA, the incoming note information is used, and polyphonic aftertouch works polyphonically. Other SFZ players need testing.","title":"Practical Considerations"},{"location":"opcodes/loprog/","text":"MIDI program numbers in the General MIDI spec ranged from 0 to 127 but were often displayed externally as 1 to 128. This uses the 0 to 127 range. By default, most DAWs seem to have the program number set to 0, so setting loprog higher than 0 without sending program change messages results in no sound. Examples loprog=0 hiprog=0 loprog=1 hiprog=1 loprog=10 hiprog=12","title":"loprog / hiprog"},{"location":"opcodes/loprog/#examples","text":"loprog=0 hiprog=0 loprog=1 hiprog=1 loprog=10 hiprog=12","title":"Examples"},{"location":"opcodes/lorand/","text":"Random values. The player will generate a new random number on every note-on event, in the range 0 to 1. Examples lorand=0.2 hirand=0.4 lorand=0.4 hirand=1 The most common application for this is randomized round robins. Note that hirand for a region should equal lorand for the next region - if we had, for example, hirand =0.249 for the first region and lorand =0.25 for the next, that would result in no sound playing if the random number generated was, for example, 0.2496343491. So, an 0.001 chance of no sound at all - a difficult problem to spot when testing. <region> hirand=0.25 sample=kick_vl1_rr1.wav <region> lorand=0.25 hirand=0.5 sample=kick_vl1_rr2.wav <region> lorand=0.5 hirand=0.75 sample=kick_vl1_rr3.wav <region> lorand=0.75 sample=kick_vl1_rr4.wav It is also possible to combine this with the seq_length and seq_position opcodes to split round robins into two subsets, and randomize within each subset. This results in randomization, but prevents the possibility of the same sample being triggered twice in a row when the random number generated falls into the same range as the previously generated number. This can be good when there are a lot (6 or more) round robin samples available. The code for 8 samples split into two sequential subsets might look like this: <region> seq_length=2 seq_position=1 hirand=0.25 sample=kick_vl1_rr1.wav <region> seq_length=2 seq_position=1 lorand=0.25 hirand=0.5 sample=kick_vl1_rr2.wav <region> seq_length=2 seq_position=1 lorand=0.5 hirand=0.75 sample=kick_vl1_rr3.wav <region> seq_length=2 seq_position=1 lorand=0.75 sample=kick_vl1_rr4.wav <region> seq_length=2 seq_position=2 hirand=0.25 sample=kick_vl1_rr5.wav <region> seq_length=2 seq_position=2 lorand=0.25 hirand=0.5 sample=kick_vl1_rr6.wav <region> seq_length=2 seq_position=2 lorand=0.5 hirand=0.75 sample=kick_vl1_rr7.wav <region> seq_length=2 seq_position=2 lorand=0.75 sample=kick_vl1_rr8.wav Practical Considerations In the ARIA implementation of SFZ, sequence position is not tracked together for all regions, which means the above is not a practical way to implement alternating left/right hand or up/down bowing samples. Also in ARIA, a separate random number is generated for each region which is playing, which means lorand/hirand probably should not be used with samples which have multiple mic positions. Using it can result in triggering spot, overhead and room mics which do not match, and that can result in phasing issues etc. There are other potential uses which have nothing to do with round robins, for example having key fingering noises on a clarinet trigger sometimes (but not always) when a note is played.","title":"lorand / hirand"},{"location":"opcodes/lorand/#examples","text":"lorand=0.2 hirand=0.4 lorand=0.4 hirand=1 The most common application for this is randomized round robins. Note that hirand for a region should equal lorand for the next region - if we had, for example, hirand =0.249 for the first region and lorand =0.25 for the next, that would result in no sound playing if the random number generated was, for example, 0.2496343491. So, an 0.001 chance of no sound at all - a difficult problem to spot when testing. <region> hirand=0.25 sample=kick_vl1_rr1.wav <region> lorand=0.25 hirand=0.5 sample=kick_vl1_rr2.wav <region> lorand=0.5 hirand=0.75 sample=kick_vl1_rr3.wav <region> lorand=0.75 sample=kick_vl1_rr4.wav It is also possible to combine this with the seq_length and seq_position opcodes to split round robins into two subsets, and randomize within each subset. This results in randomization, but prevents the possibility of the same sample being triggered twice in a row when the random number generated falls into the same range as the previously generated number. This can be good when there are a lot (6 or more) round robin samples available. The code for 8 samples split into two sequential subsets might look like this: <region> seq_length=2 seq_position=1 hirand=0.25 sample=kick_vl1_rr1.wav <region> seq_length=2 seq_position=1 lorand=0.25 hirand=0.5 sample=kick_vl1_rr2.wav <region> seq_length=2 seq_position=1 lorand=0.5 hirand=0.75 sample=kick_vl1_rr3.wav <region> seq_length=2 seq_position=1 lorand=0.75 sample=kick_vl1_rr4.wav <region> seq_length=2 seq_position=2 hirand=0.25 sample=kick_vl1_rr5.wav <region> seq_length=2 seq_position=2 lorand=0.25 hirand=0.5 sample=kick_vl1_rr6.wav <region> seq_length=2 seq_position=2 lorand=0.5 hirand=0.75 sample=kick_vl1_rr7.wav <region> seq_length=2 seq_position=2 lorand=0.75 sample=kick_vl1_rr8.wav","title":"Examples"},{"location":"opcodes/lorand/#practical-considerations","text":"In the ARIA implementation of SFZ, sequence position is not tracked together for all regions, which means the above is not a practical way to implement alternating left/right hand or up/down bowing samples. Also in ARIA, a separate random number is generated for each region which is playing, which means lorand/hirand probably should not be used with samples which have multiple mic positions. Using it can result in triggering spot, overhead and room mics which do not match, and that can result in phasing issues etc. There are other potential uses which have nothing to do with round robins, for example having key fingering noises on a clarinet trigger sometimes (but not always) when a note is played.","title":"Practical Considerations"},{"location":"opcodes/lotimer/","text":"Not implemented in ARIA, may have been implemented in some Cakewalk products. The timer is how long has passed since the last sample had played in the same group. It is, however, not known whether this is a group header or polyphony group. Examples <region> hitimer=0.25 sample=quick.wav <region> lotimer=0.25 sample=slow.wav","title":"lotimer / hitimer"},{"location":"opcodes/lotimer/#examples","text":"<region> hitimer=0.25 sample=quick.wav <region> lotimer=0.25 sample=slow.wav","title":"Examples"},{"location":"opcodes/lovel/","text":"This is obviously useful for instruments with dynamic layers controlled by velocity. Though dynamic layers can also be controlled by CC, especially for sustained instruments, lovel and hivel are the standard way of controlling dynamics for instruments such as drums and pianos. It is also possible to use lovel / hivel to control other things instead, such as articulations - for example, a guitar could have palm-muted samples on low velocities, and pinch harmonics on velocity 127. These opcodes will often need to be used with amp_velcurve_N , unless amp_veltrack is set to 0. The reason for this is that with default velocity tracking behavior and non-normalized samples (and there are many reasons why normalizing samples should be avoided), the quiet velocity layers will be too quiet. Velocity 0 is a note-off message, so 1 is the lowest usable value with hivel/lovel. Example lovel=64 hivel=95 An instrument with four velocity-controlled dynamic layers might use lovel and hivel like this: <region>hivel=31 amp_velcurve_31=1 sample=kick_vl1.wav <region>lovel=32 hivel=63 amp_velcurve_63=1 sample=kick_vl2.wav <region>lovel=64 hivel=95 amp_velcurve_95=1 sample=kick_vl3.wav <region>lovel=96 sample=kick_vl4.wav The way this would work is the kick_vl1.wav region will play at velocities up to 31, with volume going gradually from 0 at velocity 0 (so, no sound) to full volume at velocity 31. The kick_vl2.wav region will play at velocties 32 to 63, with volume being full at velocity 63 and lower volume (but not zero) at 32. The kick_vl3 wav region will play at velocites 64 to 95, with full volume at velocity 95. Finally, the kick_vl4 layer plays at velocities 96 to 127, with no amp_velcurve_N set meaning it will have full volume at velocity 127.","title":"lovel / hivel"},{"location":"opcodes/lovel/#example","text":"lovel=64 hivel=95 An instrument with four velocity-controlled dynamic layers might use lovel and hivel like this: <region>hivel=31 amp_velcurve_31=1 sample=kick_vl1.wav <region>lovel=32 hivel=63 amp_velcurve_63=1 sample=kick_vl2.wav <region>lovel=64 hivel=95 amp_velcurve_95=1 sample=kick_vl3.wav <region>lovel=96 sample=kick_vl4.wav The way this would work is the kick_vl1.wav region will play at velocities up to 31, with volume going gradually from 0 at velocity 0 (so, no sound) to full volume at velocity 31. The kick_vl2.wav region will play at velocties 32 to 63, with volume being full at velocity 63 and lower volume (but not zero) at 32. The kick_vl3 wav region will play at velocites 64 to 95, with full volume at velocity 95. Finally, the kick_vl4 layer plays at velocities 96 to 127, with no amp_velcurve_N set meaning it will have full volume at velocity 127.","title":"Example"},{"location":"opcodes/master_amplitude/","text":"Example master_amplitude=60","title":"Master amplitude"},{"location":"opcodes/master_amplitude/#example","text":"master_amplitude=60","title":"Example"},{"location":"opcodes/master_label/","text":"Useful for debugging. It can be set anywhere, not just under the \u2039 master \u203a header. Example master_label=China2","title":"Master label"},{"location":"opcodes/master_label/#example","text":"master_label=China2","title":"Example"},{"location":"opcodes/master_tune/","text":"","title":"Master tune"},{"location":"opcodes/master_volume/","text":"","title":"Master volume"},{"location":"opcodes/md5/","text":"It may be used to verify the integrity of the sample file, or to locate renamed files by content. Example /* University of Iowa Music Instrument Samples - Piano http://theremin.music.uiowa.edu/MISpiano.html */ <region> sample=Piano.ff.A0.aiff md5=4ce81c280832d99f05a0d609a1031d5e","title":"Md5"},{"location":"opcodes/md5/#example","text":"/* University of Iowa Music Instrument Samples - Piano http://theremin.music.uiowa.edu/MISpiano.html */ <region> sample=Piano.ff.A0.aiff md5=4ce81c280832d99f05a0d609a1031d5e","title":"Example"},{"location":"opcodes/noise_filter/","text":"","title":"Noise filter"},{"location":"opcodes/noise_level/","text":"","title":"Noise level"},{"location":"opcodes/noise_level_onccN/","text":"","title":"noise level onccN"},{"location":"opcodes/noise_level_smoothccN/","text":"","title":"noise level smoothccN"},{"location":"opcodes/noise_step/","text":"","title":"Noise step"},{"location":"opcodes/noise_step_onccN/","text":"","title":"noise step onccN"},{"location":"opcodes/noise_stereo/","text":"","title":"Noise stereo"},{"location":"opcodes/noise_tone/","text":"","title":"Noise tone"},{"location":"opcodes/noise_tone_onccN/","text":"","title":"noise tone onccN"},{"location":"opcodes/note_offset/","text":"This opcode tells SFZ to shift all incoming MIDI data by the specified number of notes - basically like octave_offset but measured in half-steps instead of octaves. It should be used under the \u2039 control \u203a header. Example note_offset=-3","title":"Note offset"},{"location":"opcodes/note_offset/#example","text":"note_offset=-3","title":"Example"},{"location":"opcodes/note_polyphony/","text":"Example note_polyphony=3 The difference between applying polyphony across one note and using note_polyphony is that note_polyphony also uses note_selfmask which opens up some additional options. Default self-masking behavior is that higher-or-equal-velocity notes turn off lower-velocity notes, but lower-velocity notes do not turn off higher-velocity notes. A new note will always play. To be more precise, assuming a note_polyphony =1, the self-masking behavior by default is: - If a low-velocity note is playing, a higher-or-equal velocity note kills the low-velocity note. - If a high-velocity note is playing, a strictly-lower-velocity note will play without killing the high-velocity note. The note_polyphony opcode is thus not a strict polyphony limit but more of a hint for the instrument behavior. This behavior is indeed generally desirable when playing repeated piano notes, hammered dulcimers, etc. It can also be useful for cymbals, although especially with hi-hats, those will often use different notes for different articulations, and note_polyphony would be limited to working within an articulation. The note polyphony is checked within a polyphony group, set by the group or polyphony_group opcodes. If no group is specified on the region (or its group, master or globally) the note polyphony applies to the default group as if group =0 was specified. This means that instruments where one note needs to trigger multiple layers, for example drums with separate microphone samples, will usually need to set a separate group number for each microphone position, so the note polyphony limit is tracked separately for each mic.","title":"Note polyphony"},{"location":"opcodes/note_polyphony/#example","text":"note_polyphony=3 The difference between applying polyphony across one note and using note_polyphony is that note_polyphony also uses note_selfmask which opens up some additional options. Default self-masking behavior is that higher-or-equal-velocity notes turn off lower-velocity notes, but lower-velocity notes do not turn off higher-velocity notes. A new note will always play. To be more precise, assuming a note_polyphony =1, the self-masking behavior by default is: - If a low-velocity note is playing, a higher-or-equal velocity note kills the low-velocity note. - If a high-velocity note is playing, a strictly-lower-velocity note will play without killing the high-velocity note. The note_polyphony opcode is thus not a strict polyphony limit but more of a hint for the instrument behavior. This behavior is indeed generally desirable when playing repeated piano notes, hammered dulcimers, etc. It can also be useful for cymbals, although especially with hi-hats, those will often use different notes for different articulations, and note_polyphony would be limited to working within an articulation. The note polyphony is checked within a polyphony group, set by the group or polyphony_group opcodes. If no group is specified on the region (or its group, master or globally) the note polyphony applies to the default group as if group =0 was specified. This means that instruments where one note needs to trigger multiple layers, for example drums with separate microphone samples, will usually need to set a separate group number for each microphone position, so the note polyphony limit is tracked separately for each mic.","title":"Example"},{"location":"opcodes/note_selfmask/","text":"This affects only muting of notes where the polyphony is limited by note_polyphony and not cases where polyphony is used. Default self-masking behavior is that higher-or-equal-velocity notes turn off lower-velocity notes, but lower-velocity notes do not turn off higher-velocity notes. A new note will always play. To be more precise, assuming a note_polyphony =1, the self-masking behavior by default is: - If a low-velocity note is playing, a higher-or-equal velocity note kills the low-velocity note. - If a high-velocity note is playing, a strictly-lower-velocity note will play without killing the high-velocity note. The note_polyphony opcode is thus not a strict polyphony limit but more of a hint for the instrument behavior. This behavior is indeed generally desirable when playing repeated piano notes, ride cymbals, hammered dulcimers etc. With note_selfmask set to off, notes turn off notes with the same pitch regardless of velocity, which generally sounds less \"musical\" but does ensure that note polyphony is always preserved within the set limit, and can sound right for certain instruments. Example note_selfmask=off","title":"Note selfmask"},{"location":"opcodes/note_selfmask/#example","text":"note_selfmask=off","title":"Example"},{"location":"opcodes/octave_offset/","text":"This opcode tells SFZ to shift all incoming MIDI data by the specified octave - this allows changing IPN notation into MMA, so C4 will be MIDI note 48 instead of MIDI note 60. It should be used under the \u2039 control \u203a header. Example octave_offset=-1","title":"Octave offset"},{"location":"opcodes/octave_offset/#example","text":"octave_offset=-1","title":"Example"},{"location":"opcodes/off_by/","text":"When a new region with a group number equal to off_by plays, this region will be turned off. Examples off_by=3 off_by=334 This is used in conjunction with group to make things monophonic, but can also be used in other contexts where one sound should cause another to stop - for example, cymbal chokes. Practical considerations With the default for both group and off_by being 0, any instruments that leave these default values in place should in theory be monophonic. As a workaround, rgc sfz, Cakewalk players, BassMIDI and LinuxSampler implement special behavior where if group=0 and off_by=0, regions are not muted, and muting only happens for non-zero values of off_by. ARIA/Sforzando has a different workaround, with the default value of off_by being 4294967295. The actual minimum and maximum values are not currently known. Some players will treat numbers outside a certain range as equivalent to off_by=0, and ARIA/Sforzando will also do this with text strings. The behavior of non-integer numbers is also currently unknown. This makes it possible to use an extremely large number for one group/off_by combination, but it's obviously not recommended.","title":"Off by"},{"location":"opcodes/off_by/#examples","text":"off_by=3 off_by=334 This is used in conjunction with group to make things monophonic, but can also be used in other contexts where one sound should cause another to stop - for example, cymbal chokes.","title":"Examples"},{"location":"opcodes/off_by/#practical-considerations","text":"With the default for both group and off_by being 0, any instruments that leave these default values in place should in theory be monophonic. As a workaround, rgc sfz, Cakewalk players, BassMIDI and LinuxSampler implement special behavior where if group=0 and off_by=0, regions are not muted, and muting only happens for non-zero values of off_by. ARIA/Sforzando has a different workaround, with the default value of off_by being 4294967295. The actual minimum and maximum values are not currently known. Some players will treat numbers outside a certain range as equivalent to off_by=0, and ARIA/Sforzando will also do this with text strings. The behavior of non-integer numbers is also currently unknown. This makes it possible to use an extremely large number for one group/off_by combination, but it's obviously not recommended.","title":"Practical considerations"},{"location":"opcodes/off_curve/","text":"-2 is a static, non-changing envelope segment. -1 is linear slope. 0 is x^n with n being the coefficient set in off_shape. 1 is n^x. 2 logarithmic, possibly not implemented in any SFZ player. 10 is vendor-specific math. Examples off_curve=-1 off_curve=10","title":"Off curve"},{"location":"opcodes/off_curve/#examples","text":"off_curve=-1 off_curve=10","title":"Examples"},{"location":"opcodes/off_mode/","text":"Region off mode. This opcode will determinate how a region is turned off by an off_by opcode. There are two choices: fast (default): The voice will be turned off immediately. Release settings will not have any effect. normal : The region will be set into release stage. All envelope generators will enter in release stage, and region will expire when the amplifier envelope generator expired. ARIA also adds off_mode =time which can be used to specify a time independent of the sample release time using off_time , and also off_shape and off_curve to control the curve of the fadeout. In ARIA, time is actually the default value with a default off_time of 6 ms. 6 ms is also the fadeout time for off_mode=fast so these are equivalent in end result, but time is the true default value \"under the hood\". Examples off_mode=fast off_mode=normal Note that the default is fast, and not normal, which means that \"normal isn't normal\", and if normal is needed, it will need to be set explicitly. Normal is useful for legato instruments where a fading in the previous samples while the new one fades in is desirable, and can also be useful for making hi-hat muting behavior sound a little more natural. With longer release times, off_mode =normal is also a way to manage buildup in instruments which have a very long sustain and can have the sound of several notes build up - for example, hammered dulcimers or ride cymbals.","title":"Off mode"},{"location":"opcodes/off_mode/#examples","text":"off_mode=fast off_mode=normal Note that the default is fast, and not normal, which means that \"normal isn't normal\", and if normal is needed, it will need to be set explicitly. Normal is useful for legato instruments where a fading in the previous samples while the new one fades in is desirable, and can also be useful for making hi-hat muting behavior sound a little more natural. With longer release times, off_mode =normal is also a way to manage buildup in instruments which have a very long sustain and can have the sound of several notes build up - for example, hammered dulcimers or ride cymbals.","title":"Examples"},{"location":"opcodes/off_shape/","text":"Like ampeg_release_shape , but for regions being muted by polyphony limitations. Examples off_shape=2.1 off_shape=-3.8","title":"Off shape"},{"location":"opcodes/off_shape/#examples","text":"off_shape=2.1 off_shape=-3.8","title":"Examples"},{"location":"opcodes/off_time/","text":"Examples off_time=0.1 off_time=0.05","title":"Off time"},{"location":"opcodes/off_time/#examples","text":"off_time=0.1 off_time=0.05","title":"Examples"},{"location":"opcodes/offby/","text":"When a new region with a group number equal to off_by plays, this region will be turned off. Examples off_by=3 off_by=334 This is used in conjunction with group to make things monophonic, but can also be used in other contexts where one sound should cause another to stop - for example, cymbal chokes. Practical considerations With the default for both group and off_by being 0, any instruments that leave these default values in place should in theory be monophonic. As a workaround, rgc sfz, Cakewalk players, BassMIDI and LinuxSampler implement special behavior where if group=0 and off_by=0, regions are not muted, and muting only happens for non-zero values of off_by. ARIA/Sforzando has a different workaround, with the default value of off_by being 4294967295. The actual minimum and maximum values are not currently known. Some players will treat numbers outside a certain range as equivalent to off_by=0, and ARIA/Sforzando will also do this with text strings. The behavior of non-integer numbers is also currently unknown. This makes it possible to use an extremely large number for one group/off_by combination, but it's obviously not recommended.","title":"Offby"},{"location":"opcodes/offby/#examples","text":"off_by=3 off_by=334 This is used in conjunction with group to make things monophonic, but can also be used in other contexts where one sound should cause another to stop - for example, cymbal chokes.","title":"Examples"},{"location":"opcodes/offby/#practical-considerations","text":"With the default for both group and off_by being 0, any instruments that leave these default values in place should in theory be monophonic. As a workaround, rgc sfz, Cakewalk players, BassMIDI and LinuxSampler implement special behavior where if group=0 and off_by=0, regions are not muted, and muting only happens for non-zero values of off_by. ARIA/Sforzando has a different workaround, with the default value of off_by being 4294967295. The actual minimum and maximum values are not currently known. Some players will treat numbers outside a certain range as equivalent to off_by=0, and ARIA/Sforzando will also do this with text strings. The behavior of non-integer numbers is also currently unknown. This makes it possible to use an extremely large number for one group/off_by combination, but it's obviously not recommended.","title":"Practical considerations"},{"location":"opcodes/offset/","text":"The player will reproduce samples starting with the very first sample in the file, unless offset is specified. It will start playing the file at the offset sample in this case. Note that this if this causes the region to play from a point where the value in the file is not zero, this may result in a click in the audio. When modulating offset with a MIDI CC, it's generally not possible to ensure the offset will always land on a near-zero point, so a small ampeg_attack value can be used to create a quick fade-in and avoid clicks. Also, when using a player with disk streaming, such as Sforzando/ARIA, which does not load entire samples to memory but instead preloads on only the start (usually about half a second, following the original Gigasampler method), it is generally not a good idea to use MIDI CC modulate offset by high values so high that they would cause the offset to exceeed this buffer. In practice, that means keeping offset_random no higher than 20000 or so on most systems. Examples offset=3000 offset=32425 offset_cc1=3000 offset_cc64=1388 Uses include: - having the player skip pre-attack pick noise in guitar samples - phase-aligning samples from various microphones - skipping the start of a saxophone sample in legato instruments offset_ccN is useful to specify an alternate sample start point based on MIDI controllers.","title":"Offset"},{"location":"opcodes/offset/#examples","text":"offset=3000 offset=32425 offset_cc1=3000 offset_cc64=1388 Uses include: - having the player skip pre-attack pick noise in guitar samples - phase-aligning samples from various microphones - skipping the start of a saxophone sample in legato instruments offset_ccN is useful to specify an alternate sample start point based on MIDI controllers.","title":"Examples"},{"location":"opcodes/offset_ccN/","text":"The player will reproduce samples starting with the very first sample in the file, unless offset is specified. It will start playing the file at the offset sample in this case. Note that this if this causes the region to play from a point where the value in the file is not zero, this may result in a click in the audio. When modulating offset with a MIDI CC, it's generally not possible to ensure the offset will always land on a near-zero point, so a small ampeg_attack value can be used to create a quick fade-in and avoid clicks. Also, when using a player with disk streaming, such as Sforzando/ARIA, which does not load entire samples to memory but instead preloads on only the start (usually about half a second, following the original Gigasampler method), it is generally not a good idea to use MIDI CC modulate offset by high values so high that they would cause the offset to exceeed this buffer. In practice, that means keeping offset_random no higher than 20000 or so on most systems. Examples offset=3000 offset=32425 offset_cc1=3000 offset_cc64=1388 Uses include: - having the player skip pre-attack pick noise in guitar samples - phase-aligning samples from various microphones - skipping the start of a saxophone sample in legato instruments offset_ccN is useful to specify an alternate sample start point based on MIDI controllers.","title":"offset ccN"},{"location":"opcodes/offset_ccN/#examples","text":"offset=3000 offset=32425 offset_cc1=3000 offset_cc64=1388 Uses include: - having the player skip pre-attack pick noise in guitar samples - phase-aligning samples from various microphones - skipping the start of a saxophone sample in legato instruments offset_ccN is useful to specify an alternate sample start point based on MIDI controllers.","title":"Examples"},{"location":"opcodes/offset_mode/","text":"An ARIA extension that can be used to set offset to a percentage of the total sample length, instead of being measured in sample units. It applies to both fixed offset and offset modulated by MIDI CC. Examples offset_mode=percent offset_oncc25=50","title":"Offset mode"},{"location":"opcodes/offset_mode/#examples","text":"offset_mode=percent offset_oncc25=50","title":"Examples"},{"location":"opcodes/offset_onccN/","text":"The player will reproduce samples starting with the very first sample in the file, unless offset is specified. It will start playing the file at the offset sample in this case. Note that this if this causes the region to play from a point where the value in the file is not zero, this may result in a click in the audio. When modulating offset with a MIDI CC, it's generally not possible to ensure the offset will always land on a near-zero point, so a small ampeg_attack value can be used to create a quick fade-in and avoid clicks. Also, when using a player with disk streaming, such as Sforzando/ARIA, which does not load entire samples to memory but instead preloads on only the start (usually about half a second, following the original Gigasampler method), it is generally not a good idea to use MIDI CC modulate offset by high values so high that they would cause the offset to exceeed this buffer. In practice, that means keeping offset_random no higher than 20000 or so on most systems. Examples offset=3000 offset=32425 offset_cc1=3000 offset_cc64=1388 Uses include: - having the player skip pre-attack pick noise in guitar samples - phase-aligning samples from various microphones - skipping the start of a saxophone sample in legato instruments offset_ccN is useful to specify an alternate sample start point based on MIDI controllers.","title":"offset onccN"},{"location":"opcodes/offset_onccN/#examples","text":"offset=3000 offset=32425 offset_cc1=3000 offset_cc64=1388 Uses include: - having the player skip pre-attack pick noise in guitar samples - phase-aligning samples from various microphones - skipping the start of a saxophone sample in legato instruments offset_ccN is useful to specify an alternate sample start point based on MIDI controllers.","title":"Examples"},{"location":"opcodes/offset_random/","text":"In many cases, will need to be used with a small ampeg_attack value to avoid clicks caused by the region playing starting with a point in the sample file where the value is non-zero. Computed when the note is triggered. Unipolar in ARIA, Cakewalk and rcg sfz. Note: when using a player with disk streaming, such as Sforzando/ARIA, which does not load entire samples to memory but instead preloads on only the start (usually about half a second, following the original Gigasampler method), it is generally not a good idea to make the offset_random values so high that they would cause the offset to exceeed this buffer. In practice, that means keeping offset_random no higher than 20000 or so on most systems. Examples offset_random=300 offset_random=100 Potential uses: randomizing the phase alignment of multiple samples playing in unison; playing a looped sample from a randomized start point in order to create natural variation.","title":"Offset random"},{"location":"opcodes/offset_random/#examples","text":"offset_random=300 offset_random=100 Potential uses: randomizing the phase alignment of multiple samples playing in unison; playing a looped sample from a randomized start point in order to create natural variation.","title":"Examples"},{"location":"opcodes/on_hiccN/","text":"Sample trigger on MIDI continuous control N. This does not involve playing any MIDI notes. Example on_locc64=127 on_hicc64=127 Region will play when a MIDI CC64 (sustain pedal) message with 127 value is received. So, basically, when the sustain pedal is pressed down, this region will play. This is useful with piano pedals - in the above example, on_loccN and on_hiccN could be used to trigger a mechanical noise sample, whether any keys are being played or not. It would not typically be used with hi-hat pedals, as most electronic drum kits will send a MIDI note when the pedal hits bottom. Practical Considerations on_locc/on_hicc effectively replaces the default trigger =attack. The behavior of a region which has on_locc/on_hicc and trigger=attack both explicitly specified is not defined by the SFZ specification, and that combination should be used. In ARIA if on_locc/on_hicc and trigger=release or trigger=release_key is used, the on_locc/on_hicc opcode will be effectively disregarded, and the region will behave like a normal release or release_key region.","title":"on_loccN / on_hiccN"},{"location":"opcodes/on_hiccN/#example","text":"on_locc64=127 on_hicc64=127 Region will play when a MIDI CC64 (sustain pedal) message with 127 value is received. So, basically, when the sustain pedal is pressed down, this region will play. This is useful with piano pedals - in the above example, on_loccN and on_hiccN could be used to trigger a mechanical noise sample, whether any keys are being played or not. It would not typically be used with hi-hat pedals, as most electronic drum kits will send a MIDI note when the pedal hits bottom.","title":"Example"},{"location":"opcodes/on_hiccN/#practical-considerations","text":"on_locc/on_hicc effectively replaces the default trigger =attack. The behavior of a region which has on_locc/on_hicc and trigger=attack both explicitly specified is not defined by the SFZ specification, and that combination should be used. In ARIA if on_locc/on_hicc and trigger=release or trigger=release_key is used, the on_locc/on_hicc opcode will be effectively disregarded, and the region will behave like a normal release or release_key region.","title":"Practical Considerations"},{"location":"opcodes/on_hihdccN/","text":"Example on_lohdcc64=1 on_hihdcc64=1","title":"on_lohdccN / on_hihdccN"},{"location":"opcodes/on_hihdccN/#example","text":"on_lohdcc64=1 on_hihdcc64=1","title":"Example"},{"location":"opcodes/on_loccN/","text":"Sample trigger on MIDI continuous control N. This does not involve playing any MIDI notes. Example on_locc64=127 on_hicc64=127 Region will play when a MIDI CC64 (sustain pedal) message with 127 value is received. So, basically, when the sustain pedal is pressed down, this region will play. This is useful with piano pedals - in the above example, on_loccN and on_hiccN could be used to trigger a mechanical noise sample, whether any keys are being played or not. It would not typically be used with hi-hat pedals, as most electronic drum kits will send a MIDI note when the pedal hits bottom. Practical Considerations on_locc/on_hicc effectively replaces the default trigger =attack. The behavior of a region which has on_locc/on_hicc and trigger=attack both explicitly specified is not defined by the SFZ specification, and that combination should be used. In ARIA if on_locc/on_hicc and trigger=release or trigger=release_key is used, the on_locc/on_hicc opcode will be effectively disregarded, and the region will behave like a normal release or release_key region.","title":"on_loccN / on_hiccN"},{"location":"opcodes/on_loccN/#example","text":"on_locc64=127 on_hicc64=127 Region will play when a MIDI CC64 (sustain pedal) message with 127 value is received. So, basically, when the sustain pedal is pressed down, this region will play. This is useful with piano pedals - in the above example, on_loccN and on_hiccN could be used to trigger a mechanical noise sample, whether any keys are being played or not. It would not typically be used with hi-hat pedals, as most electronic drum kits will send a MIDI note when the pedal hits bottom.","title":"Example"},{"location":"opcodes/on_loccN/#practical-considerations","text":"on_locc/on_hicc effectively replaces the default trigger =attack. The behavior of a region which has on_locc/on_hicc and trigger=attack both explicitly specified is not defined by the SFZ specification, and that combination should be used. In ARIA if on_locc/on_hicc and trigger=release or trigger=release_key is used, the on_locc/on_hicc opcode will be effectively disregarded, and the region will behave like a normal release or release_key region.","title":"Practical Considerations"},{"location":"opcodes/on_lohdccN/","text":"Example on_lohdcc64=1 on_hihdcc64=1","title":"on_lohdccN / on_hihdccN"},{"location":"opcodes/on_lohdccN/#example","text":"on_lohdcc64=1 on_hihdcc64=1","title":"Example"},{"location":"opcodes/oscillator/","text":"","title":"Oscillator"},{"location":"opcodes/oscillator_detune/","text":"","title":"Oscillator detune"},{"location":"opcodes/oscillator_detune_onccN/","text":"","title":"oscillator detune onccN"},{"location":"opcodes/oscillator_mod_depth/","text":"","title":"Oscillator mod depth"},{"location":"opcodes/oscillator_mod_depth_onccN/","text":"","title":"oscillator mod depth onccN"},{"location":"opcodes/oscillator_mod_smoothccN/","text":"","title":"oscillator mod smoothccN"},{"location":"opcodes/oscillator_mode/","text":"0: Normal or ring modulation, see also oscillator_multi 1: Phase modulation 2: Frequency modulation","title":"Oscillator mode"},{"location":"opcodes/oscillator_multi/","text":"Assuming oscillator_mode =0: If the value is 1, the region operates normally, in single oscillator mode. If the value is 2, the region operates in ring modulation mode. If between 3 and 9, this defines a unison, with the value being the number of oscillators. In this case, oscillator_detune must also be set to indicate the spread between the oscillators. Cakewalk unison Let m be the number of oscillators defined by oscillator_multi , and d the detune value defined by oscillator_detune . The array of m oscillators is tuned by multiplying d for each oscillator by its coefficient. Oscillator Coefficient 1 0 2 -1 3 1 4 -1/4 5 1/4 6 -1/2 7 1/2 8 -3/4 9 3/4 {: .table .table-sm .table-bordered .table-striped } The oscillators sum into left and right channels with declining linear gain, opposite for each channel. With i the number of the oscillator (starting at 1), the left gain is (i-1)/(m-1) , and the right gain is 1-((i-1)/(m-1)) . Example /* # Left: [4] 25 cents, 0 dB [3] -25 cents, -2.49878 dB [2] 100 cents, -6.0206 dB [1] -100 cents, -12.0412 dB [0] 0 cents, -inf dB # Right: [0] 0 cents, 0 dB [1] -100 cents, -2.49878 dB [2] 100 cents, -6.0206 dB [3] -25 cents, -12.0412 dB [4] 25 cents, -inf dB */ <region> oscillator_detune=100 oscillator_multi=5","title":"Oscillator multi"},{"location":"opcodes/oscillator_multi/#cakewalk-unison","text":"Let m be the number of oscillators defined by oscillator_multi , and d the detune value defined by oscillator_detune . The array of m oscillators is tuned by multiplying d for each oscillator by its coefficient. Oscillator Coefficient 1 0 2 -1 3 1 4 -1/4 5 1/4 6 -1/2 7 1/2 8 -3/4 9 3/4 {: .table .table-sm .table-bordered .table-striped } The oscillators sum into left and right channels with declining linear gain, opposite for each channel. With i the number of the oscillator (starting at 1), the left gain is (i-1)/(m-1) , and the right gain is 1-((i-1)/(m-1)) .","title":"Cakewalk unison"},{"location":"opcodes/oscillator_multi/#example","text":"/* # Left: [4] 25 cents, 0 dB [3] -25 cents, -2.49878 dB [2] 100 cents, -6.0206 dB [1] -100 cents, -12.0412 dB [0] 0 cents, -inf dB # Right: [0] 0 cents, 0 dB [1] -100 cents, -2.49878 dB [2] 100 cents, -6.0206 dB [3] -25 cents, -12.0412 dB [4] 25 cents, -inf dB */ <region> oscillator_detune=100 oscillator_multi=5","title":"Example"},{"location":"opcodes/oscillator_phase/","text":"This opcode behaves in two different ways in ARIA: non-negative values from 0 to 360 set the phase in degrees, while any negative value randomizes the phase. As implemented in sfizz as of version 1.2.3 the range is 0 to 1 which behaves the same as ARIA's 0 to 360.","title":"Oscillator phase"},{"location":"opcodes/oscillator_quality/","text":"","title":"Oscillator quality"},{"location":"opcodes/oscillator_table_size/","text":"","title":"Oscillator table size"},{"location":"opcodes/output/","text":"If the player doesn't feature multiple outputs (which most currently do not), this opcode is ignored. Examples output=0 output=4","title":"Output"},{"location":"opcodes/output/#examples","text":"output=0 output=4","title":"Examples"},{"location":"opcodes/pan/","text":"If a mono sample is used, pan value defines the position in the stereo image where the sample will be placed. When a stereo sample is used, the pan value the relative amplitude of one channel respect the other. A value of zero means centered, negative values move the panoramic to the left, positive to the right. Examples pan=-30.5 pan=0 pan=43","title":"Pan"},{"location":"opcodes/pan/#examples","text":"pan=-30.5 pan=0 pan=43","title":"Examples"},{"location":"opcodes/pan_ccN/","text":"If a mono sample is used, pan value defines the position in the stereo image where the sample will be placed. When a stereo sample is used, the pan value the relative amplitude of one channel respect the other. A value of zero means centered, negative values move the panoramic to the left, positive to the right. Examples pan=-30.5 pan=0 pan=43","title":"pan ccN"},{"location":"opcodes/pan_ccN/#examples","text":"pan=-30.5 pan=0 pan=43","title":"Examples"},{"location":"opcodes/pan_curveccN/","text":"If a mono sample is used, pan value defines the position in the stereo image where the sample will be placed. When a stereo sample is used, the pan value the relative amplitude of one channel respect the other. A value of zero means centered, negative values move the panoramic to the left, positive to the right. Examples pan=-30.5 pan=0 pan=43","title":"pan curveccN"},{"location":"opcodes/pan_curveccN/#examples","text":"pan=-30.5 pan=0 pan=43","title":"Examples"},{"location":"opcodes/pan_keycenter/","text":"In this key, pan_keytrack will have no effect. Examples pan_keycenter=48 amp_keycenter=65","title":"Pan keycenter"},{"location":"opcodes/pan_keycenter/#examples","text":"pan_keycenter=48 amp_keycenter=65","title":"Examples"},{"location":"opcodes/pan_keytrack/","text":"Positive values mean higher notes are panned more to the right, negative means higher notes are panned more to the left. In most cases, this will be a small value. The note at which this is centered (at which the effect of pan_keytrack is 0) is set using pan_keycenter . Examples pan_keytrack=8 pan_keytrack=-1.3","title":"Pan keytrack"},{"location":"opcodes/pan_keytrack/#examples","text":"pan_keytrack=8 pan_keytrack=-1.3","title":"Examples"},{"location":"opcodes/pan_law/","text":"Allowed values are balance and mma. In earlier versions of ARIA, no_law was also supported but that was later deprecated, and if no_law is specified then balance will be used. Examples pan_law=balance pan_law=mma","title":"Pan law"},{"location":"opcodes/pan_law/#examples","text":"pan_law=balance pan_law=mma","title":"Examples"},{"location":"opcodes/pan_onccN/","text":"If a mono sample is used, pan value defines the position in the stereo image where the sample will be placed. When a stereo sample is used, the pan value the relative amplitude of one channel respect the other. A value of zero means centered, negative values move the panoramic to the left, positive to the right. Examples pan=-30.5 pan=0 pan=43","title":"pan onccN"},{"location":"opcodes/pan_onccN/#examples","text":"pan=-30.5 pan=0 pan=43","title":"Examples"},{"location":"opcodes/pan_random/","text":"","title":"Pan random"},{"location":"opcodes/pan_smoothccN/","text":"If a mono sample is used, pan value defines the position in the stereo image where the sample will be placed. When a stereo sample is used, the pan value the relative amplitude of one channel respect the other. A value of zero means centered, negative values move the panoramic to the left, positive to the right. Examples pan=-30.5 pan=0 pan=43","title":"pan smoothccN"},{"location":"opcodes/pan_smoothccN/#examples","text":"pan=-30.5 pan=0 pan=43","title":"Examples"},{"location":"opcodes/pan_stepccN/","text":"If a mono sample is used, pan value defines the position in the stereo image where the sample will be placed. When a stereo sample is used, the pan value the relative amplitude of one channel respect the other. A value of zero means centered, negative values move the panoramic to the left, positive to the right. Examples pan=-30.5 pan=0 pan=43","title":"pan stepccN"},{"location":"opcodes/pan_stepccN/#examples","text":"pan=-30.5 pan=0 pan=43","title":"Examples"},{"location":"opcodes/pan_veltrack/","text":"With positive values, higher-velocity notes will be panned more to the right, with negative values more to the left. Examples pan_veltrack=100 pan_veltrack=-40","title":"Pan veltrack"},{"location":"opcodes/pan_veltrack/#examples","text":"pan_veltrack=100 pan_veltrack=-40","title":"Examples"},{"location":"opcodes/param_offset/","text":"Multiples of 100 seem most convenient, because with param_offset=300 that would put the first parameter on 300, second on 301, third on 302 and so on, but other integer values can also be used. These then can be used like MIDI CC, but with numbers above 127. In practice with the Sforzando SFZ player, it appears that values that result in all the effect parameters falling between 257 and 500 work best. Higher numbers work, but may not be accessible to DAWs for automation etc. Examples param_offset=300 param_offset=400 param_offset=412 This is how this can actually be used with Sforzando's built in MDA Limiter \u2039 effect \u203a: <control> label_cc400=Limiter Thresh label_cc401=Limiter Level set_cc400=63 set_cc401=63 <effect> param_offset=400 type=com.mda.Limiter","title":"Param offset"},{"location":"opcodes/param_offset/#examples","text":"param_offset=300 param_offset=400 param_offset=412 This is how this can actually be used with Sforzando's built in MDA Limiter \u2039 effect \u203a: <control> label_cc400=Limiter Thresh label_cc401=Limiter Level set_cc400=63 set_cc401=63 <effect> param_offset=400 type=com.mda.Limiter","title":"Examples"},{"location":"opcodes/phase/","text":"Example phase=invert Practical Considerations Based on testing in Sforzando, this works with both samples and generated sound such as sample=sine , except for sample=noise . Noise might still be inverted, but as it's randomly generated separately for each region, playing a noise region and a phase-inverted noise region at once will still result in noise, not silence.","title":"Phase"},{"location":"opcodes/phase/#example","text":"phase=invert","title":"Example"},{"location":"opcodes/phase/#practical-considerations","text":"Based on testing in Sforzando, this works with both samples and generated sound such as sample=sine , except for sample=noise . Noise might still be inverted, but as it's randomly generated separately for each region, playing a noise region and a phase-inverted noise region at once will still result in noise, not silence.","title":"Practical Considerations"},{"location":"opcodes/phaser_depth/","text":"Used under the \u2039effect\u203a header, with type = phaser .","title":"Phaser depth"},{"location":"opcodes/phaser_depth_onccN/","text":"Used under the \u2039effect\u203a header, with type = phaser .","title":"phaser depth onccN"},{"location":"opcodes/phaser_feedback/","text":"Used under the \u2039effect\u203a header, with type = phaser .","title":"Phaser feedback"},{"location":"opcodes/phaser_feedback_onccN/","text":"Used under the \u2039effect\u203a header, with type = phaser .","title":"phaser feedback onccN"},{"location":"opcodes/phaser_freq/","text":"Used under the \u2039effect\u203a header, with type = phaser .","title":"Phaser freq"},{"location":"opcodes/phaser_freq_onccN/","text":"Used under the \u2039effect\u203a header, with type = phaser .","title":"phaser freq onccN"},{"location":"opcodes/phaser_phase_onccN/","text":"Used under the \u2039effect\u203a header, with type = phaser .","title":"phaser phase onccN"},{"location":"opcodes/phaser_stages/","text":"Used under the \u2039effect\u203a header, with type = phaser .","title":"Phaser stages"},{"location":"opcodes/phaser_waveform/","text":"Used under the \u2039effect\u203a header, with type = phaser .","title":"Phaser waveform"},{"location":"opcodes/phaser_wet/","text":"Used under the \u2039effect\u203a header, with type = phaser .","title":"Phaser wet"},{"location":"opcodes/phaser_wet_onccN/","text":"Used under the \u2039effect\u203a header, with type = phaser .","title":"phaser wet onccN"},{"location":"opcodes/pitch/","text":"Range of tune in the SFZ1 spec is \u00b11 semitone, from -100 to 100, though at least in ARIA, it seems a broader range is supported, at least -2400 to 2400 cents. Examples tune=33 tune=-30 tune=94 Uses include correcting the intonation of naturally off-pitch samples, and detuning unison voices. Modulating pitch with MIDI CC to create a tune control is possible in SFZ2. If the control needs to go both up and down, there are two ways to do this. One is to move the pitch down by the tuning range, then have modulation move it up by twice the tuning range, so that when the control is at the midpoint, the region will play at its orignal, unmodulated pitch. For a range of 100 cents this would look like this: tune=-100 pitch_oncc27=200 Another way is to use default \u2039curve\u203a 1 which ranges from -1 to 1, and set the pitch control to the tuning range. pitch_oncc27=100 pitch_curvecc27=1 Practical Considerations In ARIA, tune_*ccN can also be used as an alias for pitch_*ccN (see below).","title":"tune / pitch"},{"location":"opcodes/pitch/#examples","text":"tune=33 tune=-30 tune=94 Uses include correcting the intonation of naturally off-pitch samples, and detuning unison voices. Modulating pitch with MIDI CC to create a tune control is possible in SFZ2. If the control needs to go both up and down, there are two ways to do this. One is to move the pitch down by the tuning range, then have modulation move it up by twice the tuning range, so that when the control is at the midpoint, the region will play at its orignal, unmodulated pitch. For a range of 100 cents this would look like this: tune=-100 pitch_oncc27=200 Another way is to use default \u2039curve\u203a 1 which ranges from -1 to 1, and set the pitch control to the tuning range. pitch_oncc27=100 pitch_curvecc27=1","title":"Examples"},{"location":"opcodes/pitch/#practical-considerations","text":"In ARIA, tune_*ccN can also be used as an alias for pitch_*ccN (see below).","title":"Practical Considerations"},{"location":"opcodes/pitch_attack/","text":"Examples ampeg_attack=1.2 fileg_attack=0.1 These are very frequently used, especially with amplifier envelopes. ampeg_attack is the standard \"A\" in the basic ADSR volume envelope. fileg_attack is key to 303-style basses.","title":"Pitch attack"},{"location":"opcodes/pitch_attack/#examples","text":"ampeg_attack=1.2 fileg_attack=0.1 These are very frequently used, especially with amplifier envelopes. ampeg_attack is the standard \"A\" in the basic ADSR volume envelope. fileg_attack is key to 303-style basses.","title":"Examples"},{"location":"opcodes/pitch_curveccN/","text":"Range of tune in the SFZ1 spec is \u00b11 semitone, from -100 to 100, though at least in ARIA, it seems a broader range is supported, at least -2400 to 2400 cents. Examples tune=33 tune=-30 tune=94 Uses include correcting the intonation of naturally off-pitch samples, and detuning unison voices. Modulating pitch with MIDI CC to create a tune control is possible in SFZ2. If the control needs to go both up and down, there are two ways to do this. One is to move the pitch down by the tuning range, then have modulation move it up by twice the tuning range, so that when the control is at the midpoint, the region will play at its orignal, unmodulated pitch. For a range of 100 cents this would look like this: tune=-100 pitch_oncc27=200 Another way is to use default \u2039curve\u203a 1 which ranges from -1 to 1, and set the pitch control to the tuning range. pitch_oncc27=100 pitch_curvecc27=1 Practical Considerations In ARIA, tune_*ccN can also be used as an alias for pitch_*ccN (see below).","title":"tune / pitch"},{"location":"opcodes/pitch_curveccN/#examples","text":"tune=33 tune=-30 tune=94 Uses include correcting the intonation of naturally off-pitch samples, and detuning unison voices. Modulating pitch with MIDI CC to create a tune control is possible in SFZ2. If the control needs to go both up and down, there are two ways to do this. One is to move the pitch down by the tuning range, then have modulation move it up by twice the tuning range, so that when the control is at the midpoint, the region will play at its orignal, unmodulated pitch. For a range of 100 cents this would look like this: tune=-100 pitch_oncc27=200 Another way is to use default \u2039curve\u203a 1 which ranges from -1 to 1, and set the pitch control to the tuning range. pitch_oncc27=100 pitch_curvecc27=1","title":"Examples"},{"location":"opcodes/pitch_curveccN/#practical-considerations","text":"In ARIA, tune_*ccN can also be used as an alias for pitch_*ccN (see below).","title":"Practical Considerations"},{"location":"opcodes/pitch_decay/","text":"Examples ampeg_decay=1.5 fileg_decay=0.5 This should normally not be shorter than the corresponding envelope's release time.","title":"Pitch decay"},{"location":"opcodes/pitch_decay/#examples","text":"ampeg_decay=1.5 fileg_decay=0.5 This should normally not be shorter than the corresponding envelope's release time.","title":"Examples"},{"location":"opcodes/pitch_delay/","text":"This is the time elapsed from note on to the start of the Attack stage. If both envelope delay and the general delay or delay_random are used in the same region, the envelope delays start after delay and delay_random have both completed their duration. Examples fileg_delay=0.004 ampeg_delay=0.05","title":"Pitch delay"},{"location":"opcodes/pitch_delay/#examples","text":"fileg_delay=0.004 ampeg_delay=0.05","title":"Examples"},{"location":"opcodes/pitch_depth/","text":"For pitcheg and fileg, this is in cents, and can range from -12000 to 12000. -12000 cents is 10 octaves. For ampeg, this should not normally be used. Examples fileg_depth=1200 pitcheg_depth=-100","title":"Pitch depth"},{"location":"opcodes/pitch_depth/#examples","text":"fileg_depth=1200 pitcheg_depth=-100","title":"Examples"},{"location":"opcodes/pitch_hold/","text":"During the hold stage, EG output will remain at its maximum value. Examples ampeg_hold=1.5 fileg_hold=0.1","title":"Pitch hold"},{"location":"opcodes/pitch_hold/#examples","text":"ampeg_hold=1.5 fileg_hold=0.1","title":"Examples"},{"location":"opcodes/pitch_keycenter/","text":"For samples which only need to be played at their natural pitch and triggered by one specific MIDI note, it's generally easier to use key instead. Cases using both pitch_keycenter and key are described in more detail under key. sample as value Starting with SFZ v2, it's possible to set pitch_keycenter to sample (pitch_keycenter=sample). This causes the SFZ player to look in the sample file metadata for the keycenter value. If pitch_keycenter is set to sample and the file metadata does not contain pitch information, it defaults to MIDI note 0. If samples contain good quality metadata, setting pitch_keycenter to sample can be simpler than setting the keycenter for each individual sample. If pitch_keycenter is set to sample and key is also used, the behavior depends on the sampler. ARIA uses the value set using the key opcode, while rgc sfz and Cakewalk products use the value from the sample metadata. ARIA also supports setting pitch_keycenter to sample only at the <region> level, not at <group> or higher levels. Examples pitch_keycenter=56 pitch_keycenter=c#2 pitch_keycenter=sample","title":"Pitch keycenter"},{"location":"opcodes/pitch_keycenter/#sample-as-value","text":"Starting with SFZ v2, it's possible to set pitch_keycenter to sample (pitch_keycenter=sample). This causes the SFZ player to look in the sample file metadata for the keycenter value. If pitch_keycenter is set to sample and the file metadata does not contain pitch information, it defaults to MIDI note 0. If samples contain good quality metadata, setting pitch_keycenter to sample can be simpler than setting the keycenter for each individual sample. If pitch_keycenter is set to sample and key is also used, the behavior depends on the sampler. ARIA uses the value set using the key opcode, while rgc sfz and Cakewalk products use the value from the sample metadata. ARIA also supports setting pitch_keycenter to sample only at the <region> level, not at <group> or higher levels.","title":"sample as value"},{"location":"opcodes/pitch_keycenter/#examples","text":"pitch_keycenter=56 pitch_keycenter=c#2 pitch_keycenter=sample","title":"Examples"},{"location":"opcodes/pitch_keytrack/","text":"Default value is 100, which means pitch will change one hundred cents (one semitone) per played note. Setting this value to zero means that all notes in the region will play the same pitch, particularly useful when mapping drum sounds. Examples pitch_keytrack=20 pitch_keytrack=0 Most of the time, this will either be 100 (default) or 0, but intermediate values, values above 100 or negative values are occasionally useful.","title":"Pitch keytrack"},{"location":"opcodes/pitch_keytrack/#examples","text":"pitch_keytrack=20 pitch_keytrack=0 Most of the time, this will either be 100 (default) or 0, but intermediate values, values above 100 or negative values are occasionally useful.","title":"Examples"},{"location":"opcodes/pitch_onccN/","text":"Range of tune in the SFZ1 spec is \u00b11 semitone, from -100 to 100, though at least in ARIA, it seems a broader range is supported, at least -2400 to 2400 cents. Examples tune=33 tune=-30 tune=94 Uses include correcting the intonation of naturally off-pitch samples, and detuning unison voices. Modulating pitch with MIDI CC to create a tune control is possible in SFZ2. If the control needs to go both up and down, there are two ways to do this. One is to move the pitch down by the tuning range, then have modulation move it up by twice the tuning range, so that when the control is at the midpoint, the region will play at its orignal, unmodulated pitch. For a range of 100 cents this would look like this: tune=-100 pitch_oncc27=200 Another way is to use default \u2039curve\u203a 1 which ranges from -1 to 1, and set the pitch control to the tuning range. pitch_oncc27=100 pitch_curvecc27=1 Practical Considerations In ARIA, tune_*ccN can also be used as an alias for pitch_*ccN (see below).","title":"tune / pitch"},{"location":"opcodes/pitch_onccN/#examples","text":"tune=33 tune=-30 tune=94 Uses include correcting the intonation of naturally off-pitch samples, and detuning unison voices. Modulating pitch with MIDI CC to create a tune control is possible in SFZ2. If the control needs to go both up and down, there are two ways to do this. One is to move the pitch down by the tuning range, then have modulation move it up by twice the tuning range, so that when the control is at the midpoint, the region will play at its orignal, unmodulated pitch. For a range of 100 cents this would look like this: tune=-100 pitch_oncc27=200 Another way is to use default \u2039curve\u203a 1 which ranges from -1 to 1, and set the pitch control to the tuning range. pitch_oncc27=100 pitch_curvecc27=1","title":"Examples"},{"location":"opcodes/pitch_onccN/#practical-considerations","text":"In ARIA, tune_*ccN can also be used as an alias for pitch_*ccN (see below).","title":"Practical Considerations"},{"location":"opcodes/pitch_random/","text":"Examples Computed when the note is triggered, remains the same for that region for as long as the region plays. pitch_random=10 pitch_random=400 Useful for humanizing the pitch of instruments with naturally imprecise intonation, especially when playing multiple regions in unison. Practical Considerations In ARIA this is unipolar, and equivalent to pitch_oncc135 . So, if pitch_random is set to 20, the region will play at pitches tuned by an amount in the range from 0 cents to +20 cents. In order to get pitch to fluctuate between -20 and +20 cents, there would be two ways to get there, either by applying a fixed shift of -20 cents and a random shift of up to 40 cents: pitch=-20 pitch_random=40 Or use CC136, which is bipolar random from -1 to 1: pitch_oncc136=20 In rcg sfz and Cakewalk, this is bipolar.","title":"Pitch random"},{"location":"opcodes/pitch_random/#examples","text":"Computed when the note is triggered, remains the same for that region for as long as the region plays. pitch_random=10 pitch_random=400 Useful for humanizing the pitch of instruments with naturally imprecise intonation, especially when playing multiple regions in unison.","title":"Examples"},{"location":"opcodes/pitch_random/#practical-considerations","text":"In ARIA this is unipolar, and equivalent to pitch_oncc135 . So, if pitch_random is set to 20, the region will play at pitches tuned by an amount in the range from 0 cents to +20 cents. In order to get pitch to fluctuate between -20 and +20 cents, there would be two ways to get there, either by applying a fixed shift of -20 cents and a random shift of up to 40 cents: pitch=-20 pitch_random=40 Or use CC136, which is bipolar random from -1 to 1: pitch_oncc136=20 In rcg sfz and Cakewalk, this is bipolar.","title":"Practical Considerations"},{"location":"opcodes/pitch_release/","text":"Examples ampeg_release=1.34 fileg_release=0.2 In many instruments, pitch_release will need to be set to avoid the sound cutting off unrealistically quickly when a note ends (unless the instrument uses loop_mode set to one_shot , in which case the entire sample will always play) even if amplifier envelopes are not used otherwise to shape the sound. Also, pitch_release is used when off_mode is set to normal.","title":"Pitch release"},{"location":"opcodes/pitch_release/#examples","text":"ampeg_release=1.34 fileg_release=0.2 In many instruments, pitch_release will need to be set to avoid the sound cutting off unrealistically quickly when a note ends (unless the instrument uses loop_mode set to one_shot , in which case the entire sample will always play) even if amplifier envelopes are not used otherwise to shape the sound. Also, pitch_release is used when off_mode is set to normal.","title":"Examples"},{"location":"opcodes/pitch_smoothccN/","text":"Range of tune in the SFZ1 spec is \u00b11 semitone, from -100 to 100, though at least in ARIA, it seems a broader range is supported, at least -2400 to 2400 cents. Examples tune=33 tune=-30 tune=94 Uses include correcting the intonation of naturally off-pitch samples, and detuning unison voices. Modulating pitch with MIDI CC to create a tune control is possible in SFZ2. If the control needs to go both up and down, there are two ways to do this. One is to move the pitch down by the tuning range, then have modulation move it up by twice the tuning range, so that when the control is at the midpoint, the region will play at its orignal, unmodulated pitch. For a range of 100 cents this would look like this: tune=-100 pitch_oncc27=200 Another way is to use default \u2039curve\u203a 1 which ranges from -1 to 1, and set the pitch control to the tuning range. pitch_oncc27=100 pitch_curvecc27=1 Practical Considerations In ARIA, tune_*ccN can also be used as an alias for pitch_*ccN (see below).","title":"tune / pitch"},{"location":"opcodes/pitch_smoothccN/#examples","text":"tune=33 tune=-30 tune=94 Uses include correcting the intonation of naturally off-pitch samples, and detuning unison voices. Modulating pitch with MIDI CC to create a tune control is possible in SFZ2. If the control needs to go both up and down, there are two ways to do this. One is to move the pitch down by the tuning range, then have modulation move it up by twice the tuning range, so that when the control is at the midpoint, the region will play at its orignal, unmodulated pitch. For a range of 100 cents this would look like this: tune=-100 pitch_oncc27=200 Another way is to use default \u2039curve\u203a 1 which ranges from -1 to 1, and set the pitch control to the tuning range. pitch_oncc27=100 pitch_curvecc27=1","title":"Examples"},{"location":"opcodes/pitch_smoothccN/#practical-considerations","text":"In ARIA, tune_*ccN can also be used as an alias for pitch_*ccN (see below).","title":"Practical Considerations"},{"location":"opcodes/pitch_stepccN/","text":"Range of tune in the SFZ1 spec is \u00b11 semitone, from -100 to 100, though at least in ARIA, it seems a broader range is supported, at least -2400 to 2400 cents. Examples tune=33 tune=-30 tune=94 Uses include correcting the intonation of naturally off-pitch samples, and detuning unison voices. Modulating pitch with MIDI CC to create a tune control is possible in SFZ2. If the control needs to go both up and down, there are two ways to do this. One is to move the pitch down by the tuning range, then have modulation move it up by twice the tuning range, so that when the control is at the midpoint, the region will play at its orignal, unmodulated pitch. For a range of 100 cents this would look like this: tune=-100 pitch_oncc27=200 Another way is to use default \u2039curve\u203a 1 which ranges from -1 to 1, and set the pitch control to the tuning range. pitch_oncc27=100 pitch_curvecc27=1 Practical Considerations In ARIA, tune_*ccN can also be used as an alias for pitch_*ccN (see below).","title":"tune / pitch"},{"location":"opcodes/pitch_stepccN/#examples","text":"tune=33 tune=-30 tune=94 Uses include correcting the intonation of naturally off-pitch samples, and detuning unison voices. Modulating pitch with MIDI CC to create a tune control is possible in SFZ2. If the control needs to go both up and down, there are two ways to do this. One is to move the pitch down by the tuning range, then have modulation move it up by twice the tuning range, so that when the control is at the midpoint, the region will play at its orignal, unmodulated pitch. For a range of 100 cents this would look like this: tune=-100 pitch_oncc27=200 Another way is to use default \u2039curve\u203a 1 which ranges from -1 to 1, and set the pitch control to the tuning range. pitch_oncc27=100 pitch_curvecc27=1","title":"Examples"},{"location":"opcodes/pitch_stepccN/#practical-considerations","text":"In ARIA, tune_*ccN can also be used as an alias for pitch_*ccN (see below).","title":"Practical Considerations"},{"location":"opcodes/pitch_sustain/","text":"Examples ampeg_sustain=40.34 pitcheg_sustain=10","title":"Pitch sustain"},{"location":"opcodes/pitch_sustain/#examples","text":"ampeg_sustain=40.34 pitcheg_sustain=10","title":"Examples"},{"location":"opcodes/pitch_vel2attack/","text":"Examples ampeg_attack=1.2 fileg_attack=0.1 These are very frequently used, especially with amplifier envelopes. ampeg_attack is the standard \"A\" in the basic ADSR volume envelope. fileg_attack is key to 303-style basses.","title":"Pitch vel2attack"},{"location":"opcodes/pitch_vel2attack/#examples","text":"ampeg_attack=1.2 fileg_attack=0.1 These are very frequently used, especially with amplifier envelopes. ampeg_attack is the standard \"A\" in the basic ADSR volume envelope. fileg_attack is key to 303-style basses.","title":"Examples"},{"location":"opcodes/pitch_vel2decay/","text":"Examples ampeg_decay=1.5 fileg_decay=0.5 This should normally not be shorter than the corresponding envelope's release time.","title":"Pitch vel2decay"},{"location":"opcodes/pitch_vel2decay/#examples","text":"ampeg_decay=1.5 fileg_decay=0.5 This should normally not be shorter than the corresponding envelope's release time.","title":"Examples"},{"location":"opcodes/pitch_vel2delay/","text":"This is the time elapsed from note on to the start of the Attack stage. If both envelope delay and the general delay or delay_random are used in the same region, the envelope delays start after delay and delay_random have both completed their duration. Examples fileg_delay=0.004 ampeg_delay=0.05","title":"Pitch vel2delay"},{"location":"opcodes/pitch_vel2delay/#examples","text":"fileg_delay=0.004 ampeg_delay=0.05","title":"Examples"},{"location":"opcodes/pitch_vel2depth/","text":"For pitcheg and fileg, this is in cents, and can range from -12000 to 12000. -12000 cents is 10 octaves. For ampeg, this should not normally be used. Examples fileg_depth=1200 pitcheg_depth=-100","title":"Pitch vel2depth"},{"location":"opcodes/pitch_vel2depth/#examples","text":"fileg_depth=1200 pitcheg_depth=-100","title":"Examples"},{"location":"opcodes/pitch_vel2hold/","text":"During the hold stage, EG output will remain at its maximum value. Examples ampeg_hold=1.5 fileg_hold=0.1","title":"Pitch vel2hold"},{"location":"opcodes/pitch_vel2hold/#examples","text":"ampeg_hold=1.5 fileg_hold=0.1","title":"Examples"},{"location":"opcodes/pitch_vel2release/","text":"Examples ampeg_release=1.34 fileg_release=0.2 In many instruments, pitch_vel2release will need to be set to avoid the sound cutting off unrealistically quickly when a note ends (unless the instrument uses loop_mode set to one_shot , in which case the entire sample will always play) even if amplifier envelopes are not used otherwise to shape the sound. Also, pitch_vel2release is used when off_mode is set to normal.","title":"Pitch vel2release"},{"location":"opcodes/pitch_vel2release/#examples","text":"ampeg_release=1.34 fileg_release=0.2 In many instruments, pitch_vel2release will need to be set to avoid the sound cutting off unrealistically quickly when a note ends (unless the instrument uses loop_mode set to one_shot , in which case the entire sample will always play) even if amplifier envelopes are not used otherwise to shape the sound. Also, pitch_vel2release is used when off_mode is set to normal.","title":"Examples"},{"location":"opcodes/pitch_vel2sustain/","text":"Examples ampeg_sustain=40.34 pitcheg_sustain=10","title":"Pitch vel2sustain"},{"location":"opcodes/pitch_vel2sustain/#examples","text":"ampeg_sustain=40.34 pitcheg_sustain=10","title":"Examples"},{"location":"opcodes/pitch_veltrack/","text":"Examples pitch_veltrack=0 pitch_veltrack=1200 This can be useful when trying to emulate dynamic response on drum samples recorded at only one velocity.","title":"Pitch veltrack"},{"location":"opcodes/pitch_veltrack/#examples","text":"pitch_veltrack=0 pitch_veltrack=1200 This can be useful when trying to emulate dynamic response on drum samples recorded at only one velocity.","title":"Examples"},{"location":"opcodes/pitcheg_attack/","text":"Examples ampeg_attack=1.2 fileg_attack=0.1 These are very frequently used, especially with amplifier envelopes. ampeg_attack is the standard \"A\" in the basic ADSR volume envelope. fileg_attack is key to 303-style basses.","title":"Pitcheg attack"},{"location":"opcodes/pitcheg_attack/#examples","text":"ampeg_attack=1.2 fileg_attack=0.1 These are very frequently used, especially with amplifier envelopes. ampeg_attack is the standard \"A\" in the basic ADSR volume envelope. fileg_attack is key to 303-style basses.","title":"Examples"},{"location":"opcodes/pitcheg_attack_curveccN/","text":"Examples ampeg_attack=1.2 fileg_attack=0.1 These are very frequently used, especially with amplifier envelopes. ampeg_attack is the standard \"A\" in the basic ADSR volume envelope. fileg_attack is key to 303-style basses.","title":"pitcheg attack curveccN"},{"location":"opcodes/pitcheg_attack_curveccN/#examples","text":"ampeg_attack=1.2 fileg_attack=0.1 These are very frequently used, especially with amplifier envelopes. ampeg_attack is the standard \"A\" in the basic ADSR volume envelope. fileg_attack is key to 303-style basses.","title":"Examples"},{"location":"opcodes/pitcheg_attack_onccN/","text":"Examples ampeg_attack=1.2 fileg_attack=0.1 These are very frequently used, especially with amplifier envelopes. ampeg_attack is the standard \"A\" in the basic ADSR volume envelope. fileg_attack is key to 303-style basses.","title":"pitcheg attack onccN"},{"location":"opcodes/pitcheg_attack_onccN/#examples","text":"ampeg_attack=1.2 fileg_attack=0.1 These are very frequently used, especially with amplifier envelopes. ampeg_attack is the standard \"A\" in the basic ADSR volume envelope. fileg_attack is key to 303-style basses.","title":"Examples"},{"location":"opcodes/pitcheg_attack_shape/","text":"0 is linear. Positive values are slower curves (that means the envelope will initially not fade in much, and most of the fade in will happen towards the end of the attack period) and negative values faster (quick initial fade in with the latter part of the attack stage fading in less). Past 10 or -10, there's little difference - at that point, the envelope is practically a horizontal line and a vertical line (if positive) or a vertical line followed by a horizontal line (if negative). Examples ampeg_attack_shape=2.1 ampeg_attack_shape=-3.8","title":"Pitcheg attack shape"},{"location":"opcodes/pitcheg_attack_shape/#examples","text":"ampeg_attack_shape=2.1 ampeg_attack_shape=-3.8","title":"Examples"},{"location":"opcodes/pitcheg_decay/","text":"Examples ampeg_decay=1.5 fileg_decay=0.5 This should normally not be shorter than the corresponding envelope's release time.","title":"Pitcheg decay"},{"location":"opcodes/pitcheg_decay/#examples","text":"ampeg_decay=1.5 fileg_decay=0.5 This should normally not be shorter than the corresponding envelope's release time.","title":"Examples"},{"location":"opcodes/pitcheg_decay_curveccN/","text":"Examples ampeg_decay=1.5 fileg_decay=0.5 This should normally not be shorter than the corresponding envelope's release time.","title":"pitcheg decay curveccN"},{"location":"opcodes/pitcheg_decay_curveccN/#examples","text":"ampeg_decay=1.5 fileg_decay=0.5 This should normally not be shorter than the corresponding envelope's release time.","title":"Examples"},{"location":"opcodes/pitcheg_decay_onccN/","text":"Examples ampeg_decay=1.5 fileg_decay=0.5 This should normally not be shorter than the corresponding envelope's release time.","title":"pitcheg decay onccN"},{"location":"opcodes/pitcheg_decay_onccN/#examples","text":"ampeg_decay=1.5 fileg_decay=0.5 This should normally not be shorter than the corresponding envelope's release time.","title":"Examples"},{"location":"opcodes/pitcheg_decay_shape/","text":"0 is linear, positive values are slower curves (that means the envelope will initially not decay out much, and most of the decay will happen towards the end of the decay period) and negative values faster (quick initial decay with quiet tail decaying more slowly). Past 10 or -10, there's little difference - at that point, the envelope is practically a horizontal line and a vertical line (if positive) or a vertical line followed by a horizontal line (if negative). Examples ampeg_decay_shape=2.1 ampeg_decay_shape=-3.8","title":"Pitcheg decay shape"},{"location":"opcodes/pitcheg_decay_shape/#examples","text":"ampeg_decay_shape=2.1 ampeg_decay_shape=-3.8","title":"Examples"},{"location":"opcodes/pitcheg_decay_zero/","text":"When set to 1, the decay slope is fixed, and the higher the sustain level of the envelope, the less time the decay stage will actually take. Changing pitcheg_sustain will change the actual duration of the decay stage as well, up to a maximum of the full pitcheg_decay value at pitcheg_sustain equal to 0. Setting this to 0 will make the decay always happen during the entire time period specified by pitcheg_decay , regardless of the current pitcheg_sustain level. Examples pitcheg_decay_zero=0 pitcheg_decay_zero=1","title":"Pitcheg decay zero"},{"location":"opcodes/pitcheg_decay_zero/#examples","text":"pitcheg_decay_zero=0 pitcheg_decay_zero=1","title":"Examples"},{"location":"opcodes/pitcheg_delay/","text":"This is the time elapsed from note on to the start of the Attack stage. If both envelope delay and the general delay or delay_random are used in the same region, the envelope delays start after delay and delay_random have both completed their duration. Examples fileg_delay=0.004 ampeg_delay=0.05","title":"Pitcheg delay"},{"location":"opcodes/pitcheg_delay/#examples","text":"fileg_delay=0.004 ampeg_delay=0.05","title":"Examples"},{"location":"opcodes/pitcheg_delay_curveccN/","text":"This is the time elapsed from note on to the start of the Attack stage. If both envelope delay and the general delay or delay_random are used in the same region, the envelope delays start after delay and delay_random have both completed their duration. Examples fileg_delay=0.004 ampeg_delay=0.05","title":"pitcheg delay curveccN"},{"location":"opcodes/pitcheg_delay_curveccN/#examples","text":"fileg_delay=0.004 ampeg_delay=0.05","title":"Examples"},{"location":"opcodes/pitcheg_delay_onccN/","text":"This is the time elapsed from note on to the start of the Attack stage. If both envelope delay and the general delay or delay_random are used in the same region, the envelope delays start after delay and delay_random have both completed their duration. Examples fileg_delay=0.004 ampeg_delay=0.05","title":"pitcheg delay onccN"},{"location":"opcodes/pitcheg_delay_onccN/#examples","text":"fileg_delay=0.004 ampeg_delay=0.05","title":"Examples"},{"location":"opcodes/pitcheg_depth/","text":"For pitcheg and fileg, this is in cents, and can range from -12000 to 12000. -12000 cents is 10 octaves. For ampeg, this should not normally be used. Examples fileg_depth=1200 pitcheg_depth=-100","title":"Pitcheg depth"},{"location":"opcodes/pitcheg_depth/#examples","text":"fileg_depth=1200 pitcheg_depth=-100","title":"Examples"},{"location":"opcodes/pitcheg_depth_curveccN/","text":"For pitcheg and fileg, this is in cents, and can range from -12000 to 12000. -12000 cents is 10 octaves. For ampeg, this should not normally be used. Examples fileg_depth=1200 pitcheg_depth=-100","title":"pitcheg depth curveccN"},{"location":"opcodes/pitcheg_depth_curveccN/#examples","text":"fileg_depth=1200 pitcheg_depth=-100","title":"Examples"},{"location":"opcodes/pitcheg_depth_onccN/","text":"For pitcheg and fileg, this is in cents, and can range from -12000 to 12000. -12000 cents is 10 octaves. For ampeg, this should not normally be used. Examples fileg_depth=1200 pitcheg_depth=-100","title":"pitcheg depth onccN"},{"location":"opcodes/pitcheg_depth_onccN/#examples","text":"fileg_depth=1200 pitcheg_depth=-100","title":"Examples"},{"location":"opcodes/pitcheg_depthccN/","text":"For pitcheg and fileg, this is in cents, and can range from -12000 to 12000. -12000 cents is 10 octaves. For ampeg, this should not normally be used. Examples fileg_depth=1200 pitcheg_depth=-100","title":"pitcheg depthccN"},{"location":"opcodes/pitcheg_depthccN/#examples","text":"fileg_depth=1200 pitcheg_depth=-100","title":"Examples"},{"location":"opcodes/pitcheg_dynamic/","text":"When 1, causes envelope segment durations and sustain level to be recalculated when a MIDI CC message modulating those envelopes is received. When 0, envelope segment durations and sustain level are calculated only at the start of the particular envelope segment. Examples pitcheg_dynamic=1 pitcheg_dynamic=0","title":"Pitcheg dynamic"},{"location":"opcodes/pitcheg_dynamic/#examples","text":"pitcheg_dynamic=1 pitcheg_dynamic=0","title":"Examples"},{"location":"opcodes/pitcheg_hold/","text":"During the hold stage, EG output will remain at its maximum value. Examples ampeg_hold=1.5 fileg_hold=0.1","title":"Pitcheg hold"},{"location":"opcodes/pitcheg_hold/#examples","text":"ampeg_hold=1.5 fileg_hold=0.1","title":"Examples"},{"location":"opcodes/pitcheg_hold_curveccN/","text":"During the hold stage, EG output will remain at its maximum value. Examples ampeg_hold=1.5 fileg_hold=0.1","title":"pitcheg hold curveccN"},{"location":"opcodes/pitcheg_hold_curveccN/#examples","text":"ampeg_hold=1.5 fileg_hold=0.1","title":"Examples"},{"location":"opcodes/pitcheg_hold_onccN/","text":"During the hold stage, EG output will remain at its maximum value. Examples ampeg_hold=1.5 fileg_hold=0.1","title":"pitcheg hold onccN"},{"location":"opcodes/pitcheg_hold_onccN/#examples","text":"ampeg_hold=1.5 fileg_hold=0.1","title":"Examples"},{"location":"opcodes/pitcheg_release/","text":"Examples ampeg_release=1.34 fileg_release=0.2 In many instruments, pitcheg_release will need to be set to avoid the sound cutting off unrealistically quickly when a note ends (unless the instrument uses loop_mode set to one_shot , in which case the entire sample will always play) even if amplifier envelopes are not used otherwise to shape the sound. Also, pitcheg_release is used when off_mode is set to normal.","title":"Pitcheg release"},{"location":"opcodes/pitcheg_release/#examples","text":"ampeg_release=1.34 fileg_release=0.2 In many instruments, pitcheg_release will need to be set to avoid the sound cutting off unrealistically quickly when a note ends (unless the instrument uses loop_mode set to one_shot , in which case the entire sample will always play) even if amplifier envelopes are not used otherwise to shape the sound. Also, pitcheg_release is used when off_mode is set to normal.","title":"Examples"},{"location":"opcodes/pitcheg_release_curveccN/","text":"Examples ampeg_release=1.34 fileg_release=0.2 In many instruments, pitcheg_release_curveccN will need to be set to avoid the sound cutting off unrealistically quickly when a note ends (unless the instrument uses loop_mode set to one_shot , in which case the entire sample will always play) even if amplifier envelopes are not used otherwise to shape the sound. Also, pitcheg_release_curveccN is used when off_mode is set to normal.","title":"pitcheg release curveccN"},{"location":"opcodes/pitcheg_release_curveccN/#examples","text":"ampeg_release=1.34 fileg_release=0.2 In many instruments, pitcheg_release_curveccN will need to be set to avoid the sound cutting off unrealistically quickly when a note ends (unless the instrument uses loop_mode set to one_shot , in which case the entire sample will always play) even if amplifier envelopes are not used otherwise to shape the sound. Also, pitcheg_release_curveccN is used when off_mode is set to normal.","title":"Examples"},{"location":"opcodes/pitcheg_release_onccN/","text":"Examples ampeg_release=1.34 fileg_release=0.2 In many instruments, pitcheg_release_onccN will need to be set to avoid the sound cutting off unrealistically quickly when a note ends (unless the instrument uses loop_mode set to one_shot , in which case the entire sample will always play) even if amplifier envelopes are not used otherwise to shape the sound. Also, pitcheg_release_onccN is used when off_mode is set to normal.","title":"pitcheg release onccN"},{"location":"opcodes/pitcheg_release_onccN/#examples","text":"ampeg_release=1.34 fileg_release=0.2 In many instruments, pitcheg_release_onccN will need to be set to avoid the sound cutting off unrealistically quickly when a note ends (unless the instrument uses loop_mode set to one_shot , in which case the entire sample will always play) even if amplifier envelopes are not used otherwise to shape the sound. Also, pitcheg_release_onccN is used when off_mode is set to normal.","title":"Examples"},{"location":"opcodes/pitcheg_release_shape/","text":"0 is linear, positive values are slower curves (that means the envelope will initially not fade out much, and most of the fade will happen towards the end of the release period) and negative values faster (quick initial fadeout with quiet tail fading out more slowly). Past 10 or -10, there's little difference - at that point, the envelope is practically a horizontal line and a vertical line (if positive) or a vertical line followed by a horizontal line (if negative). Examples ampeg_release_shape=2.1 ampeg_release_shape=-3.8","title":"Pitcheg release shape"},{"location":"opcodes/pitcheg_release_shape/#examples","text":"ampeg_release_shape=2.1 ampeg_release_shape=-3.8","title":"Examples"},{"location":"opcodes/pitcheg_release_zero/","text":"When 1, indicates release time is the time it would take to get from 0dBs to -oo, NOT the time to get from the current sustain to zero. In other words, under default behavior, the release time is fixed, while setting this to 1 makes the release slope fixed but time will be shorter when sustain level is lower. Examples pitcheg_release_zero=1 pitcheg_release_zero=0","title":"Pitcheg release zero"},{"location":"opcodes/pitcheg_release_zero/#examples","text":"pitcheg_release_zero=1 pitcheg_release_zero=0","title":"Examples"},{"location":"opcodes/pitcheg_start/","text":"Examples ampeg_start=20 fileg_start=100 Setting this to 100 should have the same effect as setting the attack time to 0, and adding the attack time to the hold time. Note that in some cases (when the sample starts playing from a point which is not near zero), setting this to a non-zero value for ampeg_start may result in sample playback starting with an audible click.","title":"Pitcheg start"},{"location":"opcodes/pitcheg_start/#examples","text":"ampeg_start=20 fileg_start=100 Setting this to 100 should have the same effect as setting the attack time to 0, and adding the attack time to the hold time. Note that in some cases (when the sample starts playing from a point which is not near zero), setting this to a non-zero value for ampeg_start may result in sample playback starting with an audible click.","title":"Examples"},{"location":"opcodes/pitcheg_start_curveccN/","text":"Examples ampeg_start=20 fileg_start=100 Setting this to 100 should have the same effect as setting the attack time to 0, and adding the attack time to the hold time. Note that in some cases (when the sample starts playing from a point which is not near zero), setting this to a non-zero value for ampeg_start may result in sample playback starting with an audible click.","title":"pitcheg start curveccN"},{"location":"opcodes/pitcheg_start_curveccN/#examples","text":"ampeg_start=20 fileg_start=100 Setting this to 100 should have the same effect as setting the attack time to 0, and adding the attack time to the hold time. Note that in some cases (when the sample starts playing from a point which is not near zero), setting this to a non-zero value for ampeg_start may result in sample playback starting with an audible click.","title":"Examples"},{"location":"opcodes/pitcheg_start_onccN/","text":"Examples ampeg_start=20 fileg_start=100 Setting this to 100 should have the same effect as setting the attack time to 0, and adding the attack time to the hold time. Note that in some cases (when the sample starts playing from a point which is not near zero), setting this to a non-zero value for ampeg_start may result in sample playback starting with an audible click.","title":"pitcheg start onccN"},{"location":"opcodes/pitcheg_start_onccN/#examples","text":"ampeg_start=20 fileg_start=100 Setting this to 100 should have the same effect as setting the attack time to 0, and adding the attack time to the hold time. Note that in some cases (when the sample starts playing from a point which is not near zero), setting this to a non-zero value for ampeg_start may result in sample playback starting with an audible click.","title":"Examples"},{"location":"opcodes/pitcheg_sustain/","text":"Examples ampeg_sustain=40.34 pitcheg_sustain=10","title":"Pitcheg sustain"},{"location":"opcodes/pitcheg_sustain/#examples","text":"ampeg_sustain=40.34 pitcheg_sustain=10","title":"Examples"},{"location":"opcodes/pitcheg_sustain_curveccN/","text":"Examples ampeg_sustain=40.34 pitcheg_sustain=10","title":"pitcheg sustain curveccN"},{"location":"opcodes/pitcheg_sustain_curveccN/#examples","text":"ampeg_sustain=40.34 pitcheg_sustain=10","title":"Examples"},{"location":"opcodes/pitcheg_sustain_onccN/","text":"Examples ampeg_sustain=40.34 pitcheg_sustain=10","title":"pitcheg sustain onccN"},{"location":"opcodes/pitcheg_sustain_onccN/#examples","text":"ampeg_sustain=40.34 pitcheg_sustain=10","title":"Examples"},{"location":"opcodes/pitcheg_vel2attack/","text":"Examples ampeg_attack=1.2 fileg_attack=0.1 These are very frequently used, especially with amplifier envelopes. ampeg_attack is the standard \"A\" in the basic ADSR volume envelope. fileg_attack is key to 303-style basses.","title":"Pitcheg vel2attack"},{"location":"opcodes/pitcheg_vel2attack/#examples","text":"ampeg_attack=1.2 fileg_attack=0.1 These are very frequently used, especially with amplifier envelopes. ampeg_attack is the standard \"A\" in the basic ADSR volume envelope. fileg_attack is key to 303-style basses.","title":"Examples"},{"location":"opcodes/pitcheg_vel2decay/","text":"Examples ampeg_decay=1.5 fileg_decay=0.5 This should normally not be shorter than the corresponding envelope's release time.","title":"Pitcheg vel2decay"},{"location":"opcodes/pitcheg_vel2decay/#examples","text":"ampeg_decay=1.5 fileg_decay=0.5 This should normally not be shorter than the corresponding envelope's release time.","title":"Examples"},{"location":"opcodes/pitcheg_vel2delay/","text":"This is the time elapsed from note on to the start of the Attack stage. If both envelope delay and the general delay or delay_random are used in the same region, the envelope delays start after delay and delay_random have both completed their duration. Examples fileg_delay=0.004 ampeg_delay=0.05","title":"Pitcheg vel2delay"},{"location":"opcodes/pitcheg_vel2delay/#examples","text":"fileg_delay=0.004 ampeg_delay=0.05","title":"Examples"},{"location":"opcodes/pitcheg_vel2depth/","text":"For pitcheg and fileg, this is in cents, and can range from -12000 to 12000. -12000 cents is 10 octaves. For ampeg, this should not normally be used. Examples fileg_depth=1200 pitcheg_depth=-100","title":"Pitcheg vel2depth"},{"location":"opcodes/pitcheg_vel2depth/#examples","text":"fileg_depth=1200 pitcheg_depth=-100","title":"Examples"},{"location":"opcodes/pitcheg_vel2hold/","text":"During the hold stage, EG output will remain at its maximum value. Examples ampeg_hold=1.5 fileg_hold=0.1","title":"Pitcheg vel2hold"},{"location":"opcodes/pitcheg_vel2hold/#examples","text":"ampeg_hold=1.5 fileg_hold=0.1","title":"Examples"},{"location":"opcodes/pitcheg_vel2release/","text":"Examples ampeg_release=1.34 fileg_release=0.2 In many instruments, pitcheg_vel2release will need to be set to avoid the sound cutting off unrealistically quickly when a note ends (unless the instrument uses loop_mode set to one_shot , in which case the entire sample will always play) even if amplifier envelopes are not used otherwise to shape the sound. Also, pitcheg_vel2release is used when off_mode is set to normal.","title":"Pitcheg vel2release"},{"location":"opcodes/pitcheg_vel2release/#examples","text":"ampeg_release=1.34 fileg_release=0.2 In many instruments, pitcheg_vel2release will need to be set to avoid the sound cutting off unrealistically quickly when a note ends (unless the instrument uses loop_mode set to one_shot , in which case the entire sample will always play) even if amplifier envelopes are not used otherwise to shape the sound. Also, pitcheg_vel2release is used when off_mode is set to normal.","title":"Examples"},{"location":"opcodes/pitcheg_vel2sustain/","text":"Examples ampeg_sustain=40.34 pitcheg_sustain=10","title":"Pitcheg vel2sustain"},{"location":"opcodes/pitcheg_vel2sustain/#examples","text":"ampeg_sustain=40.34 pitcheg_sustain=10","title":"Examples"},{"location":"opcodes/pitchlfo_delay/","text":"Examples pitchlfo_delay=1 amplfo_delay=0.4 This is very useful, as many instruments and vocals don't trigger vibrato immediately when a note starts, but slightly later.","title":"Pitchlfo delay"},{"location":"opcodes/pitchlfo_delay/#examples","text":"pitchlfo_delay=1 amplfo_delay=0.4 This is very useful, as many instruments and vocals don't trigger vibrato immediately when a note starts, but slightly later.","title":"Examples"},{"location":"opcodes/pitchlfo_depth/","text":"Examples amplfo_depth=1 pitchlfo_depth=40 For amplifier LFO, this is measured in decibels and can range from -10 to 10. For pitch and filter LFO, this is measured in cents and can range from -1200 to 1200. Whether these values are negative or positive, the LFO will oscillate both up and down around the center value of the amplitude, pitch or filter cutoff - a negative sign for depth only inverts the phase. For cases where an LFO needs to oscillate only in one direction from the normal value (for example: typical guitar vibrato which only bends the pitch upwards, or saxophone vibrato which only bends the pitch down), an offset to the center pitch value will need to be added using the appropriate opcode such as tune. In SFZ2 LFOs add the ability to set the starting phase, making this much easier.","title":"Pitchlfo depth"},{"location":"opcodes/pitchlfo_depth/#examples","text":"amplfo_depth=1 pitchlfo_depth=40 For amplifier LFO, this is measured in decibels and can range from -10 to 10. For pitch and filter LFO, this is measured in cents and can range from -1200 to 1200. Whether these values are negative or positive, the LFO will oscillate both up and down around the center value of the amplitude, pitch or filter cutoff - a negative sign for depth only inverts the phase. For cases where an LFO needs to oscillate only in one direction from the normal value (for example: typical guitar vibrato which only bends the pitch upwards, or saxophone vibrato which only bends the pitch down), an offset to the center pitch value will need to be added using the appropriate opcode such as tune. In SFZ2 LFOs add the ability to set the starting phase, making this much easier.","title":"Examples"},{"location":"opcodes/pitchlfo_depth_onccN/","text":"Examples amplfo_depth=1 pitchlfo_depth=40 For amplifier LFO, this is measured in decibels and can range from -10 to 10. For pitch and filter LFO, this is measured in cents and can range from -1200 to 1200. Whether these values are negative or positive, the LFO will oscillate both up and down around the center value of the amplitude, pitch or filter cutoff - a negative sign for depth only inverts the phase. For cases where an LFO needs to oscillate only in one direction from the normal value (for example: typical guitar vibrato which only bends the pitch upwards, or saxophone vibrato which only bends the pitch down), an offset to the center pitch value will need to be added using the appropriate opcode such as tune. In SFZ2 LFOs add the ability to set the starting phase, making this much easier.","title":"pitchlfo depth onccN"},{"location":"opcodes/pitchlfo_depth_onccN/#examples","text":"amplfo_depth=1 pitchlfo_depth=40 For amplifier LFO, this is measured in decibels and can range from -10 to 10. For pitch and filter LFO, this is measured in cents and can range from -1200 to 1200. Whether these values are negative or positive, the LFO will oscillate both up and down around the center value of the amplitude, pitch or filter cutoff - a negative sign for depth only inverts the phase. For cases where an LFO needs to oscillate only in one direction from the normal value (for example: typical guitar vibrato which only bends the pitch upwards, or saxophone vibrato which only bends the pitch down), an offset to the center pitch value will need to be added using the appropriate opcode such as tune. In SFZ2 LFOs add the ability to set the starting phase, making this much easier.","title":"Examples"},{"location":"opcodes/pitchlfo_depthccN/","text":"Examples amplfo_depth=1 pitchlfo_depth=40 For amplifier LFO, this is measured in decibels and can range from -10 to 10. For pitch and filter LFO, this is measured in cents and can range from -1200 to 1200. Whether these values are negative or positive, the LFO will oscillate both up and down around the center value of the amplitude, pitch or filter cutoff - a negative sign for depth only inverts the phase. For cases where an LFO needs to oscillate only in one direction from the normal value (for example: typical guitar vibrato which only bends the pitch upwards, or saxophone vibrato which only bends the pitch down), an offset to the center pitch value will need to be added using the appropriate opcode such as tune. In SFZ2 LFOs add the ability to set the starting phase, making this much easier.","title":"pitchlfo depthccN"},{"location":"opcodes/pitchlfo_depthccN/#examples","text":"amplfo_depth=1 pitchlfo_depth=40 For amplifier LFO, this is measured in decibels and can range from -10 to 10. For pitch and filter LFO, this is measured in cents and can range from -1200 to 1200. Whether these values are negative or positive, the LFO will oscillate both up and down around the center value of the amplitude, pitch or filter cutoff - a negative sign for depth only inverts the phase. For cases where an LFO needs to oscillate only in one direction from the normal value (for example: typical guitar vibrato which only bends the pitch upwards, or saxophone vibrato which only bends the pitch down), an offset to the center pitch value will need to be added using the appropriate opcode such as tune. In SFZ2 LFOs add the ability to set the starting phase, making this much easier.","title":"Examples"},{"location":"opcodes/pitchlfo_depthchanaft/","text":"Examples amplfo_depth=1 pitchlfo_depth=40 For amplifier LFO, this is measured in decibels and can range from -10 to 10. For pitch and filter LFO, this is measured in cents and can range from -1200 to 1200. Whether these values are negative or positive, the LFO will oscillate both up and down around the center value of the amplitude, pitch or filter cutoff - a negative sign for depth only inverts the phase. For cases where an LFO needs to oscillate only in one direction from the normal value (for example: typical guitar vibrato which only bends the pitch upwards, or saxophone vibrato which only bends the pitch down), an offset to the center pitch value will need to be added using the appropriate opcode such as tune. In SFZ2 LFOs add the ability to set the starting phase, making this much easier.","title":"Pitchlfo depthchanaft"},{"location":"opcodes/pitchlfo_depthchanaft/#examples","text":"amplfo_depth=1 pitchlfo_depth=40 For amplifier LFO, this is measured in decibels and can range from -10 to 10. For pitch and filter LFO, this is measured in cents and can range from -1200 to 1200. Whether these values are negative or positive, the LFO will oscillate both up and down around the center value of the amplitude, pitch or filter cutoff - a negative sign for depth only inverts the phase. For cases where an LFO needs to oscillate only in one direction from the normal value (for example: typical guitar vibrato which only bends the pitch upwards, or saxophone vibrato which only bends the pitch down), an offset to the center pitch value will need to be added using the appropriate opcode such as tune. In SFZ2 LFOs add the ability to set the starting phase, making this much easier.","title":"Examples"},{"location":"opcodes/pitchlfo_depthpolyaft/","text":"Examples amplfo_depth=1 pitchlfo_depth=40 For amplifier LFO, this is measured in decibels and can range from -10 to 10. For pitch and filter LFO, this is measured in cents and can range from -1200 to 1200. Whether these values are negative or positive, the LFO will oscillate both up and down around the center value of the amplitude, pitch or filter cutoff - a negative sign for depth only inverts the phase. For cases where an LFO needs to oscillate only in one direction from the normal value (for example: typical guitar vibrato which only bends the pitch upwards, or saxophone vibrato which only bends the pitch down), an offset to the center pitch value will need to be added using the appropriate opcode such as tune. In SFZ2 LFOs add the ability to set the starting phase, making this much easier.","title":"Pitchlfo depthpolyaft"},{"location":"opcodes/pitchlfo_depthpolyaft/#examples","text":"amplfo_depth=1 pitchlfo_depth=40 For amplifier LFO, this is measured in decibels and can range from -10 to 10. For pitch and filter LFO, this is measured in cents and can range from -1200 to 1200. Whether these values are negative or positive, the LFO will oscillate both up and down around the center value of the amplitude, pitch or filter cutoff - a negative sign for depth only inverts the phase. For cases where an LFO needs to oscillate only in one direction from the normal value (for example: typical guitar vibrato which only bends the pitch upwards, or saxophone vibrato which only bends the pitch down), an offset to the center pitch value will need to be added using the appropriate opcode such as tune. In SFZ2 LFOs add the ability to set the starting phase, making this much easier.","title":"Examples"},{"location":"opcodes/pitchlfo_fade/","text":"Examples amplfo_fade=1 pitchfo_fade=0.4 Useful for vibrato which grows in intensity gradually, as commonly performed by bowed string players.","title":"Pitchlfo fade"},{"location":"opcodes/pitchlfo_fade/#examples","text":"amplfo_fade=1 pitchfo_fade=0.4 Useful for vibrato which grows in intensity gradually, as commonly performed by bowed string players.","title":"Examples"},{"location":"opcodes/pitchlfo_freq/","text":"Examples amplfo_freq=0.4 amplfo_freq=10 Range is 0 to 20 Hertz, according to the SFZ spec, which means audio-rate LFOs, similar to what is found in some classic hardware synthesizers, are not possible. Some players may in fact be able to utilize higher rates, but 20 Hz is the upper limit required by the SFZ specification.","title":"Pitchlfo freq"},{"location":"opcodes/pitchlfo_freq/#examples","text":"amplfo_freq=0.4 amplfo_freq=10 Range is 0 to 20 Hertz, according to the SFZ spec, which means audio-rate LFOs, similar to what is found in some classic hardware synthesizers, are not possible. Some players may in fact be able to utilize higher rates, but 20 Hz is the upper limit required by the SFZ specification.","title":"Examples"},{"location":"opcodes/pitchlfo_freqccN/","text":"Examples amplfo_freq=0.4 amplfo_freq=10 Range is 0 to 20 Hertz, according to the SFZ spec, which means audio-rate LFOs, similar to what is found in some classic hardware synthesizers, are not possible. Some players may in fact be able to utilize higher rates, but 20 Hz is the upper limit required by the SFZ specification.","title":"pitchlfo freqccN"},{"location":"opcodes/pitchlfo_freqccN/#examples","text":"amplfo_freq=0.4 amplfo_freq=10 Range is 0 to 20 Hertz, according to the SFZ spec, which means audio-rate LFOs, similar to what is found in some classic hardware synthesizers, are not possible. Some players may in fact be able to utilize higher rates, but 20 Hz is the upper limit required by the SFZ specification.","title":"Examples"},{"location":"opcodes/pitchlfo_freqchanaft/","text":"Examples amplfo_freq=0.4 amplfo_freq=10 Range is 0 to 20 Hertz, according to the SFZ spec, which means audio-rate LFOs, similar to what is found in some classic hardware synthesizers, are not possible. Some players may in fact be able to utilize higher rates, but 20 Hz is the upper limit required by the SFZ specification.","title":"Pitchlfo freqchanaft"},{"location":"opcodes/pitchlfo_freqchanaft/#examples","text":"amplfo_freq=0.4 amplfo_freq=10 Range is 0 to 20 Hertz, according to the SFZ spec, which means audio-rate LFOs, similar to what is found in some classic hardware synthesizers, are not possible. Some players may in fact be able to utilize higher rates, but 20 Hz is the upper limit required by the SFZ specification.","title":"Examples"},{"location":"opcodes/pitchlfo_freqpolyaft/","text":"Examples amplfo_freq=0.4 amplfo_freq=10 Range is 0 to 20 Hertz, according to the SFZ spec, which means audio-rate LFOs, similar to what is found in some classic hardware synthesizers, are not possible. Some players may in fact be able to utilize higher rates, but 20 Hz is the upper limit required by the SFZ specification.","title":"Pitchlfo freqpolyaft"},{"location":"opcodes/pitchlfo_freqpolyaft/#examples","text":"amplfo_freq=0.4 amplfo_freq=10 Range is 0 to 20 Hertz, according to the SFZ spec, which means audio-rate LFOs, similar to what is found in some classic hardware synthesizers, are not possible. Some players may in fact be able to utilize higher rates, but 20 Hz is the upper limit required by the SFZ specification.","title":"Examples"},{"location":"opcodes/polyphony/","text":"This can be applied to all regions under a header such as \u2039global\u203a or \u2039group\u203a or to regions which have the same group opcode value set. The below examples all use the group opcode, not the group header, but that is not the only way to use the polyphony opcode. In addition to positive integer values, polyphony can also be set to one of three special text values. With all of these, the polyphony limit is set to 1, and the following behavior is also triggered: legato_high : the highest note played sounds and lower notes are muted. legato_last : the most recent note played sounds (typical legato behavior). legato_low : the lowest note played sounds. Examples polyphony=12 polyphony=5 polyphony=legato_low An example limiting a crash cymbal to four polyphony voices. group=1 polyphony=4 <region> key=49 sample=crash.wav Here is a ride limited to a total of seven voices, with both bow and bell articulations sharing the same polyphony group and the same seven-voice limit. group=2 polyphony=7 <region> key=51 sample=ride_bow.wav <region> key=53 sample=ride_bell.wav This opcode is useful for controlling sound buildup, limiting resource use, and for emulating the behavior of vintage keyboards with limited polyphony. It's also possible to use note_polyphony instead when all the sounds we want to mute each other are mapped to the same pitch, or use both in combination. An alternative for controlling sound buildup is using ampeg_release with off_mode set to normal. It's also possible to have a group with limited polyphony which can be muted by another group, such as a cymbal with edge chokes. <group> group=2 off_by=3 polyphony=7 <region> key=51 sample=ride_bow.wav <region> key=53 sample=ride_bell.wav <group> group=3 <region> key=54 sample=ride.choke.wav An alternative is note_polyphony . The difference between applying polyphony across one note and using note_polyphony is that note_polyphony also uses note_selfmask which opens up some additional options. With the default setting, lower-velocity notes do not mute higher-velocity ones. This is useful for long-ringing instruments such as piano with the sustain pedal pressed down or hammered dulcimer. It can also be useful for cymbals, although especially with hi-hats, those will often use different notes for different articulations, and note_polyphony would be limited to working within an articulation.","title":"Polyphony"},{"location":"opcodes/polyphony/#examples","text":"polyphony=12 polyphony=5 polyphony=legato_low An example limiting a crash cymbal to four polyphony voices. group=1 polyphony=4 <region> key=49 sample=crash.wav Here is a ride limited to a total of seven voices, with both bow and bell articulations sharing the same polyphony group and the same seven-voice limit. group=2 polyphony=7 <region> key=51 sample=ride_bow.wav <region> key=53 sample=ride_bell.wav This opcode is useful for controlling sound buildup, limiting resource use, and for emulating the behavior of vintage keyboards with limited polyphony. It's also possible to use note_polyphony instead when all the sounds we want to mute each other are mapped to the same pitch, or use both in combination. An alternative for controlling sound buildup is using ampeg_release with off_mode set to normal. It's also possible to have a group with limited polyphony which can be muted by another group, such as a cymbal with edge chokes. <group> group=2 off_by=3 polyphony=7 <region> key=51 sample=ride_bow.wav <region> key=53 sample=ride_bell.wav <group> group=3 <region> key=54 sample=ride.choke.wav An alternative is note_polyphony . The difference between applying polyphony across one note and using note_polyphony is that note_polyphony also uses note_selfmask which opens up some additional options. With the default setting, lower-velocity notes do not mute higher-velocity ones. This is useful for long-ringing instruments such as piano with the sustain pedal pressed down or hammered dulcimer. It can also be useful for cymbals, although especially with hi-hats, those will often use different notes for different articulations, and note_polyphony would be limited to working within an articulation.","title":"Examples"},{"location":"opcodes/polyphony_group/","text":"ARIA adds also the polyphony_group alias to reduce the confusion between the group opcode and the \u2039 group \u203a header. Examples group=3 group=334 The group opcode is used together with off_by to make something monophonic. For example, the flute is by nature a monophonic instrument, so if a flute were recorded with one microphone and had one set of samples, it would make sense to set all its samples to have one group. A guitar is polyphonic, but each string is monophonic, so a six-string guitar would naturally be split into six groups - one per string. In these cases, the group number will be equal to the off_by number. This is also commonly used with hi-hats - this is an example of where things can get more sophisticated with a large number of groups involved, as it's possible to set more closed hi-hat sounds mute more open ones, but not vice-versa, and it's also quite possible that there are separate close mic, overhead and room samples. group and off_by can also be used in other contexts where one sound should cause another to stop but enforcing monophony is not the goal - for example, a crash cymbal doesn't need to be monophonic, as allowing the sound to build up is reasonably natural, but if we wanted to implement a cymbal choke, then the crash sounds would be in one group, the choke samples in another. Practical Considerations The actual minimum and maximum values are not currently known. Some players will treat numbers outside a certain range as equivalent to group=0, and ARIA/Sforzando will also do this with text strings. The behavior of non-integer numbers is also currently unknown. This makes it possible to use an extremely large number for one group, but it's obviously not recommended.","title":"Polyphony group"},{"location":"opcodes/polyphony_group/#examples","text":"group=3 group=334 The group opcode is used together with off_by to make something monophonic. For example, the flute is by nature a monophonic instrument, so if a flute were recorded with one microphone and had one set of samples, it would make sense to set all its samples to have one group. A guitar is polyphonic, but each string is monophonic, so a six-string guitar would naturally be split into six groups - one per string. In these cases, the group number will be equal to the off_by number. This is also commonly used with hi-hats - this is an example of where things can get more sophisticated with a large number of groups involved, as it's possible to set more closed hi-hat sounds mute more open ones, but not vice-versa, and it's also quite possible that there are separate close mic, overhead and room samples. group and off_by can also be used in other contexts where one sound should cause another to stop but enforcing monophony is not the goal - for example, a crash cymbal doesn't need to be monophonic, as allowing the sound to build up is reasonably natural, but if we wanted to implement a cymbal choke, then the crash sounds would be in one group, the choke samples in another.","title":"Examples"},{"location":"opcodes/polyphony_group/#practical-considerations","text":"The actual minimum and maximum values are not currently known. Some players will treat numbers outside a certain range as equivalent to group=0, and ARIA/Sforzando will also do this with text strings. The behavior of non-integer numbers is also currently unknown. This makes it possible to use an extremely large number for one group, but it's obviously not recommended.","title":"Practical Considerations"},{"location":"opcodes/polyphony_stealing/","text":"","title":"Polyphony stealing"},{"location":"opcodes/position/","text":"A value of zero means centered, negative values move the panoramic to the left, positive to the right. Examples // mix both channels and play the result at left width=0 position=-100 // make the stereo image narrower and play it // slightly right width=50 position=30 // position modulated by MIDI CC 40 width=50 position_oncc40=-50","title":"Position"},{"location":"opcodes/position/#examples","text":"// mix both channels and play the result at left width=0 position=-100 // make the stereo image narrower and play it // slightly right width=50 position=30 // position modulated by MIDI CC 40 width=50 position_oncc40=-50","title":"Examples"},{"location":"opcodes/position_curveccN/","text":"A value of zero means centered, negative values move the panoramic to the left, positive to the right. Examples // mix both channels and play the result at left width=0 position=-100 // make the stereo image narrower and play it // slightly right width=50 position=30 // position modulated by MIDI CC 40 width=50 position_oncc40=-50","title":"position curveccN"},{"location":"opcodes/position_curveccN/#examples","text":"// mix both channels and play the result at left width=0 position=-100 // make the stereo image narrower and play it // slightly right width=50 position=30 // position modulated by MIDI CC 40 width=50 position_oncc40=-50","title":"Examples"},{"location":"opcodes/position_keycenter/","text":"","title":"Position keycenter"},{"location":"opcodes/position_keytrack/","text":"","title":"Position keytrack"},{"location":"opcodes/position_onccN/","text":"A value of zero means centered, negative values move the panoramic to the left, positive to the right. Examples // mix both channels and play the result at left width=0 position=-100 // make the stereo image narrower and play it // slightly right width=50 position=30 // position modulated by MIDI CC 40 width=50 position_oncc40=-50","title":"position onccN"},{"location":"opcodes/position_onccN/#examples","text":"// mix both channels and play the result at left width=0 position=-100 // make the stereo image narrower and play it // slightly right width=50 position=30 // position modulated by MIDI CC 40 width=50 position_oncc40=-50","title":"Examples"},{"location":"opcodes/position_random/","text":"","title":"Position random"},{"location":"opcodes/position_smoothccN/","text":"A value of zero means centered, negative values move the panoramic to the left, positive to the right. Examples // mix both channels and play the result at left width=0 position=-100 // make the stereo image narrower and play it // slightly right width=50 position=30 // position modulated by MIDI CC 40 width=50 position_oncc40=-50","title":"position smoothccN"},{"location":"opcodes/position_smoothccN/#examples","text":"// mix both channels and play the result at left width=0 position=-100 // make the stereo image narrower and play it // slightly right width=50 position=30 // position modulated by MIDI CC 40 width=50 position_oncc40=-50","title":"Examples"},{"location":"opcodes/position_stepccN/","text":"A value of zero means centered, negative values move the panoramic to the left, positive to the right. Examples // mix both channels and play the result at left width=0 position=-100 // make the stereo image narrower and play it // slightly right width=50 position=30 // position modulated by MIDI CC 40 width=50 position_oncc40=-50","title":"position stepccN"},{"location":"opcodes/position_stepccN/#examples","text":"// mix both channels and play the result at left width=0 position=-100 // make the stereo image narrower and play it // slightly right width=50 position=30 // position modulated by MIDI CC 40 width=50 position_oncc40=-50","title":"Examples"},{"location":"opcodes/position_veltrack/","text":"","title":"Position veltrack"},{"location":"opcodes/region_label/","text":"Useful for debugging. In order to work properly, generally needs to be set under a \u2039region\u203a header. If not set, the info tab will display the file path of the most recently played sample. Example <region> sample=china2_30_01.flac seq_position=1 region_label=30 one // ... <region> sample=china2_30_09.flac seq_position=9 region_label=30 nine <region> sample=china2_30_10.flac seq_position=10 region_label=30 ten","title":"Region label"},{"location":"opcodes/region_label/#example","text":"<region> sample=china2_30_01.flac seq_position=1 region_label=30 one // ... <region> sample=china2_30_09.flac seq_position=9 region_label=30 nine <region> sample=china2_30_10.flac seq_position=10 region_label=30 ten","title":"Example"},{"location":"opcodes/resonance/","text":"Example resonance=4 resonance_oncc100=3 resonance2=3.2 There are two filters in series - the resonance of one is controlled by resonance, that of the second by resonance2. Raising this can easily result in a very large boost to frequencies around the cutoff, which can result in extremely loud output!","title":"resonance / resonance2"},{"location":"opcodes/resonance/#example","text":"resonance=4 resonance_oncc100=3 resonance2=3.2 There are two filters in series - the resonance of one is controlled by resonance, that of the second by resonance2. Raising this can easily result in a very large boost to frequencies around the cutoff, which can result in extremely loud output!","title":"Example"},{"location":"opcodes/resonance2/","text":"Example resonance=4 resonance_oncc100=3 resonance2=3.2 There are two filters in series - the resonance of one is controlled by resonance, that of the second by resonance2. Raising this can easily result in a very large boost to frequencies around the cutoff, which can result in extremely loud output!","title":"resonance / resonance2"},{"location":"opcodes/resonance2/#example","text":"resonance=4 resonance_oncc100=3 resonance2=3.2 There are two filters in series - the resonance of one is controlled by resonance, that of the second by resonance2. Raising this can easily result in a very large boost to frequencies around the cutoff, which can result in extremely loud output!","title":"Example"},{"location":"opcodes/resonance2_ccN/","text":"Example resonance=4 resonance_oncc100=3 resonance2=3.2 There are two filters in series - the resonance of one is controlled by resonance, that of the second by resonance2. Raising this can easily result in a very large boost to frequencies around the cutoff, which can result in extremely loud output!","title":"resonance / resonance2"},{"location":"opcodes/resonance2_ccN/#example","text":"resonance=4 resonance_oncc100=3 resonance2=3.2 There are two filters in series - the resonance of one is controlled by resonance, that of the second by resonance2. Raising this can easily result in a very large boost to frequencies around the cutoff, which can result in extremely loud output!","title":"Example"},{"location":"opcodes/resonance2_curveccN/","text":"Example resonance=4 resonance_oncc100=3 resonance2=3.2 There are two filters in series - the resonance of one is controlled by resonance, that of the second by resonance2. Raising this can easily result in a very large boost to frequencies around the cutoff, which can result in extremely loud output!","title":"resonance / resonance2"},{"location":"opcodes/resonance2_curveccN/#example","text":"resonance=4 resonance_oncc100=3 resonance2=3.2 There are two filters in series - the resonance of one is controlled by resonance, that of the second by resonance2. Raising this can easily result in a very large boost to frequencies around the cutoff, which can result in extremely loud output!","title":"Example"},{"location":"opcodes/resonance2_onccN/","text":"Example resonance=4 resonance_oncc100=3 resonance2=3.2 There are two filters in series - the resonance of one is controlled by resonance, that of the second by resonance2. Raising this can easily result in a very large boost to frequencies around the cutoff, which can result in extremely loud output!","title":"resonance / resonance2"},{"location":"opcodes/resonance2_onccN/#example","text":"resonance=4 resonance_oncc100=3 resonance2=3.2 There are two filters in series - the resonance of one is controlled by resonance, that of the second by resonance2. Raising this can easily result in a very large boost to frequencies around the cutoff, which can result in extremely loud output!","title":"Example"},{"location":"opcodes/resonance2_smoothccN/","text":"Example resonance=4 resonance_oncc100=3 resonance2=3.2 There are two filters in series - the resonance of one is controlled by resonance, that of the second by resonance2. Raising this can easily result in a very large boost to frequencies around the cutoff, which can result in extremely loud output!","title":"resonance / resonance2"},{"location":"opcodes/resonance2_smoothccN/#example","text":"resonance=4 resonance_oncc100=3 resonance2=3.2 There are two filters in series - the resonance of one is controlled by resonance, that of the second by resonance2. Raising this can easily result in a very large boost to frequencies around the cutoff, which can result in extremely loud output!","title":"Example"},{"location":"opcodes/resonance2_stepccN/","text":"Example resonance=4 resonance_oncc100=3 resonance2=3.2 There are two filters in series - the resonance of one is controlled by resonance, that of the second by resonance2. Raising this can easily result in a very large boost to frequencies around the cutoff, which can result in extremely loud output!","title":"resonance / resonance2"},{"location":"opcodes/resonance2_stepccN/#example","text":"resonance=4 resonance_oncc100=3 resonance2=3.2 There are two filters in series - the resonance of one is controlled by resonance, that of the second by resonance2. Raising this can easily result in a very large boost to frequencies around the cutoff, which can result in extremely loud output!","title":"Example"},{"location":"opcodes/resonance_ccN/","text":"Example resonance=4 resonance_oncc100=3 resonance2=3.2 There are two filters in series - the resonance of one is controlled by resonance, that of the second by resonance2. Raising this can easily result in a very large boost to frequencies around the cutoff, which can result in extremely loud output!","title":"resonance / resonance2"},{"location":"opcodes/resonance_ccN/#example","text":"resonance=4 resonance_oncc100=3 resonance2=3.2 There are two filters in series - the resonance of one is controlled by resonance, that of the second by resonance2. Raising this can easily result in a very large boost to frequencies around the cutoff, which can result in extremely loud output!","title":"Example"},{"location":"opcodes/resonance_curveccN/","text":"Example resonance=4 resonance_oncc100=3 resonance2=3.2 There are two filters in series - the resonance of one is controlled by resonance, that of the second by resonance2. Raising this can easily result in a very large boost to frequencies around the cutoff, which can result in extremely loud output!","title":"resonance / resonance2"},{"location":"opcodes/resonance_curveccN/#example","text":"resonance=4 resonance_oncc100=3 resonance2=3.2 There are two filters in series - the resonance of one is controlled by resonance, that of the second by resonance2. Raising this can easily result in a very large boost to frequencies around the cutoff, which can result in extremely loud output!","title":"Example"},{"location":"opcodes/resonance_onccN/","text":"Example resonance=4 resonance_oncc100=3 resonance2=3.2 There are two filters in series - the resonance of one is controlled by resonance, that of the second by resonance2. Raising this can easily result in a very large boost to frequencies around the cutoff, which can result in extremely loud output!","title":"resonance / resonance2"},{"location":"opcodes/resonance_onccN/#example","text":"resonance=4 resonance_oncc100=3 resonance2=3.2 There are two filters in series - the resonance of one is controlled by resonance, that of the second by resonance2. Raising this can easily result in a very large boost to frequencies around the cutoff, which can result in extremely loud output!","title":"Example"},{"location":"opcodes/resonance_random/","text":"","title":"Resonance random"},{"location":"opcodes/resonance_smoothccN/","text":"Example resonance=4 resonance_oncc100=3 resonance2=3.2 There are two filters in series - the resonance of one is controlled by resonance, that of the second by resonance2. Raising this can easily result in a very large boost to frequencies around the cutoff, which can result in extremely loud output!","title":"resonance / resonance2"},{"location":"opcodes/resonance_smoothccN/#example","text":"resonance=4 resonance_oncc100=3 resonance2=3.2 There are two filters in series - the resonance of one is controlled by resonance, that of the second by resonance2. Raising this can easily result in a very large boost to frequencies around the cutoff, which can result in extremely loud output!","title":"Example"},{"location":"opcodes/resonance_stepccN/","text":"Example resonance=4 resonance_oncc100=3 resonance2=3.2 There are two filters in series - the resonance of one is controlled by resonance, that of the second by resonance2. Raising this can easily result in a very large boost to frequencies around the cutoff, which can result in extremely loud output!","title":"resonance / resonance2"},{"location":"opcodes/resonance_stepccN/#example","text":"resonance=4 resonance_oncc100=3 resonance2=3.2 There are two filters in series - the resonance of one is controlled by resonance, that of the second by resonance2. Raising this can easily result in a very large boost to frequencies around the cutoff, which can result in extremely loud output!","title":"Example"},{"location":"opcodes/reverb_damp/","text":"Used under the \u2039effect\u203a header, with type = fverb .","title":"Reverb damp"},{"location":"opcodes/reverb_damp_onccN/","text":"Used under the \u2039effect\u203a header, with type = fverb .","title":"reverb damp onccN"},{"location":"opcodes/reverb_dry/","text":"Used under the \u2039effect\u203a header, with type = fverb .","title":"Reverb dry"},{"location":"opcodes/reverb_dry_onccN/","text":"Used under the \u2039effect\u203a header, with type = fverb .","title":"reverb dry onccN"},{"location":"opcodes/reverb_input/","text":"Used under the \u2039effect\u203a header, with type = fverb .","title":"Reverb input"},{"location":"opcodes/reverb_input_onccN/","text":"Used under the \u2039effect\u203a header, with type = fverb .","title":"reverb input onccN"},{"location":"opcodes/reverb_predelay/","text":"Used under the \u2039effect\u203a header, with type = fverb .","title":"Reverb predelay"},{"location":"opcodes/reverb_predelay_onccN/","text":"Used under the \u2039effect\u203a header, with type = fverb .","title":"reverb predelay onccN"},{"location":"opcodes/reverb_size/","text":"Used under the \u2039effect\u203a header, with type = fverb .","title":"Reverb size"},{"location":"opcodes/reverb_size_onccN/","text":"Used under the \u2039effect\u203a header, with type = fverb .","title":"reverb size onccN"},{"location":"opcodes/reverb_tone/","text":"Used under the \u2039effect\u203a header, with type = fverb .","title":"Reverb tone"},{"location":"opcodes/reverb_tone_onccN/","text":"Used under the \u2039effect\u203a header, with type = fverb .","title":"reverb tone onccN"},{"location":"opcodes/reverb_type/","text":"Used under the \u2039effect\u203a header, with type = fverb .","title":"Reverb type"},{"location":"opcodes/reverb_wet/","text":"Used under the \u2039effect\u203a header, with type = fverb .","title":"Reverb wet"},{"location":"opcodes/reverb_wet_onccN/","text":"Used under the \u2039effect\u203a header, with type = fverb .","title":"reverb wet onccN"},{"location":"opcodes/reverse_hiccN/","text":"Example reverse_locc1=64 reverse_hicc1=127 Practical Considerations On Cakewalk, the CC does not take effect once region playback started. Not implemented in ARIA, but an alternative is to use two regions, one with direction=reverse then switch region with loccN / hiccN .","title":"reverse_loccN / reverse_hiccN"},{"location":"opcodes/reverse_hiccN/#example","text":"reverse_locc1=64 reverse_hicc1=127","title":"Example"},{"location":"opcodes/reverse_hiccN/#practical-considerations","text":"On Cakewalk, the CC does not take effect once region playback started. Not implemented in ARIA, but an alternative is to use two regions, one with direction=reverse then switch region with loccN / hiccN .","title":"Practical Considerations"},{"location":"opcodes/reverse_loccN/","text":"Example reverse_locc1=64 reverse_hicc1=127 Practical Considerations On Cakewalk, the CC does not take effect once region playback started. Not implemented in ARIA, but an alternative is to use two regions, one with direction=reverse then switch region with loccN / hiccN .","title":"reverse_loccN / reverse_hiccN"},{"location":"opcodes/reverse_loccN/#example","text":"reverse_locc1=64 reverse_hicc1=127","title":"Example"},{"location":"opcodes/reverse_loccN/#practical-considerations","text":"On Cakewalk, the CC does not take effect once region playback started. Not implemented in ARIA, but an alternative is to use two regions, one with direction=reverse then switch region with loccN / hiccN .","title":"Practical Considerations"},{"location":"opcodes/rt_dead/","text":"Allowed values are on and off, default is off, so by default, release samples do not play if their sustain samples have expired. Example rt_dead=on Although the default behavior makes sense for instrument such as pianos, with guitars there is still some noise when a finger releases a fretted note, so it can make sense to use rt_dead=on there. Also, if using release samples to emulate tremolo playing (so that the note plays when the key is pressed, and again when the key is released - this can be useful for vibraphone, marimba etc.), rt_dead=on can also be useful.","title":"Rt dead"},{"location":"opcodes/rt_dead/#example","text":"rt_dead=on Although the default behavior makes sense for instrument such as pianos, with guitars there is still some noise when a finger releases a fretted note, so it can make sense to use rt_dead=on there. Also, if using release samples to emulate tremolo playing (so that the note plays when the key is pressed, and again when the key is released - this can be useful for vibraphone, marimba etc.), rt_dead=on can also be useful.","title":"Example"},{"location":"opcodes/rt_decay/","text":"Example <region> sample=pianoA4.wav trigger=attack <region> sample=keyup_noise.wav trigger=release rt_decay=3 //The sample keyup_noise.wav will play 3db quieter for every second the key has been on. Range is 0 to 200. In general, higher values mean high decrease of the release sample volume with time, which makes sense for release samples associated with sounds which decay quickly when held. For example, higher piano notes decay much faster than lower ones, so the higher notes will need higher rt_decay values. Release samples for sounds which do not naturally decay, such as organs or guitar feedback, do not need their volume to decrease based on note duration, and can use the default value of 0. Practical Considerations In ARIA, extended MIDI CC 151 can be used alongside rt_decay to select different release samples for different time ranges. However, CCs have one value across the entire instrument. CC 151 is time since the last note-on message in seconds. This can give undesired results in arpeggios. The ARIA extension rt_decayN does not allow different release samples to be selected, but it does allow different values of the volume decrease rate to be used for different time ranges. Unlike CC 151, this is not affected by subsequently played notes.","title":"Rt decay"},{"location":"opcodes/rt_decay/#example","text":"<region> sample=pianoA4.wav trigger=attack <region> sample=keyup_noise.wav trigger=release rt_decay=3 //The sample keyup_noise.wav will play 3db quieter for every second the key has been on. Range is 0 to 200. In general, higher values mean high decrease of the release sample volume with time, which makes sense for release samples associated with sounds which decay quickly when held. For example, higher piano notes decay much faster than lower ones, so the higher notes will need higher rt_decay values. Release samples for sounds which do not naturally decay, such as organs or guitar feedback, do not need their volume to decrease based on note duration, and can use the default value of 0.","title":"Example"},{"location":"opcodes/rt_decay/#practical-considerations","text":"In ARIA, extended MIDI CC 151 can be used alongside rt_decay to select different release samples for different time ranges. However, CCs have one value across the entire instrument. CC 151 is time since the last note-on message in seconds. This can give undesired results in arpeggios. The ARIA extension rt_decayN does not allow different release samples to be selected, but it does allow different values of the volume decrease rate to be used for different time ranges. Unlike CC 151, this is not affected by subsequently played notes.","title":"Practical Considerations"},{"location":"opcodes/rt_decayN/","text":"This works similarly to rt_decay, but with a multisegment volume decrease curve. The duration of each segment and a different decrease rate for each segment can be set. Example <region> sample=pianoA4.wav trigger=attack <region> sample=keyup_noise.wav trigger=release rt_decay1=3 rt_decay1_time=2 rt_decay2=1.5 //The sample keyup_noise.wav will play 3db quieter for every second the key has been on. Practical Considerations In ARIA, extended MIDI CC 151 can be used alongside (or instead of) rt_decay to select different release samples for different time ranges. However, CCs have one value across the entire instrument. CC 151 is time since the last note-on message in seconds. This can give undesired results in arpeggios. The rt_decayN opcode does have the advantage of not being affected by subsequently played notes, but unlike CC 151, it cannot be used to select completely different release samples for different time ranges.","title":"rt decayN"},{"location":"opcodes/rt_decayN/#example","text":"<region> sample=pianoA4.wav trigger=attack <region> sample=keyup_noise.wav trigger=release rt_decay1=3 rt_decay1_time=2 rt_decay2=1.5 //The sample keyup_noise.wav will play 3db quieter for every second the key has been on.","title":"Example"},{"location":"opcodes/rt_decayN/#practical-considerations","text":"In ARIA, extended MIDI CC 151 can be used alongside (or instead of) rt_decay to select different release samples for different time ranges. However, CCs have one value across the entire instrument. CC 151 is time since the last note-on message in seconds. This can give undesired results in arpeggios. The rt_decayN opcode does have the advantage of not being affected by subsequently played notes, but unlike CC 151, it cannot be used to select completely different release samples for different time ranges.","title":"Practical Considerations"},{"location":"opcodes/rt_decayN_time/","text":"Example <region> sample=pianoA4.wav trigger=attack <region> sample=keyup_noise.wav trigger=release rt_decay1=3 rt_decay1_time=2 rt_decay2=1.5 //The sample keyup_noise.wav will play 3db quieter for every second the key has been on.","title":"rt decayN time"},{"location":"opcodes/rt_decayN_time/#example","text":"<region> sample=pianoA4.wav trigger=attack <region> sample=keyup_noise.wav trigger=release rt_decay1=3 rt_decay1_time=2 rt_decay2=1.5 //The sample keyup_noise.wav will play 3db quieter for every second the key has been on.","title":"Example"},{"location":"opcodes/sample/","text":"Possibly the most important opcode, this is the one that tells the sampler which sample file to actually play. This should include a relative file path from the folder where the SFZ file is. In most cases, there will be a sample opcode in every region of an SFZ file, though not always. If the sample file is not found, the player will ignore the whole region contents as there's nothing to play. Long names and names with blank spaces and other special characters (excepting the = character) are allowed in the sample definition. Getting the sample to play back at the correct pitch is not automatic, and generally can't be done with the sample opcode alone, even if the file name includes pitch information. Assuming that the tune or transpose opcodes are not used to change the pitch, the sample will play unchanged in pitch when a note equal to the pitch_keycenter opcode value is played. If pitch_keycenter is not defined for the region, sample will play unchanged on note 60 (middle C). If pitch_keytrack is set to 0, the sample will also play unchanged in pitch, regardless of how pitch_keycenter is set. If the key opcode is used to define the range of the sample (instead of lokey , hikey and pitch_keycenter ) the sample will also be unchanged in pitch. Formats At the SFZ1 specification level, the supported sample formats are: + WAV of any sample rate + Ogg Vorbis compressed samples For SFZ2, the Cakewalk book specifies the following sample types in addition of the above: + AIFF of any sample rate + FLAC support is not specified as mandatory, though FLAC was supported by Cakewalk Session Drummer, and is supported by ARIA See also Features section in the home page. WAV is usually the first choice, or perhaps AIFF when using macOS. FLAC is the second choice, as it is lossless compression audio is always preferable, though it needs to be decoded which can cause slower performance compared to WAV. Other compressed formats can be used for test cases or situations where keeping the file size small is more important than audio quality. See also the table of supported sample formats by some engines for more details. Examples sample=A3.wav sample=..\\Samples\\close\\c4_pp_rr3.wav Each engine can also support custom oscillators. For example, ARIA supports using this opcode for some basic synthesized sound waves such as: sample=*sine sample=*saw sample=*square sample=*triangle sample=*tri sample=*noise sample=*silence Tri is an alias for triangle. For cases where we don't want to actually play a sample but want a region to exist and be played (for example, to mute other sounds when using group and off_by , the silence value can be very convenient). Note that in this case the * is a real character and not a wildcard.","title":"Sample"},{"location":"opcodes/sample/#formats","text":"At the SFZ1 specification level, the supported sample formats are: + WAV of any sample rate + Ogg Vorbis compressed samples For SFZ2, the Cakewalk book specifies the following sample types in addition of the above: + AIFF of any sample rate + FLAC support is not specified as mandatory, though FLAC was supported by Cakewalk Session Drummer, and is supported by ARIA See also Features section in the home page. WAV is usually the first choice, or perhaps AIFF when using macOS. FLAC is the second choice, as it is lossless compression audio is always preferable, though it needs to be decoded which can cause slower performance compared to WAV. Other compressed formats can be used for test cases or situations where keeping the file size small is more important than audio quality. See also the table of supported sample formats by some engines for more details.","title":"Formats"},{"location":"opcodes/sample/#examples","text":"sample=A3.wav sample=..\\Samples\\close\\c4_pp_rr3.wav Each engine can also support custom oscillators. For example, ARIA supports using this opcode for some basic synthesized sound waves such as: sample=*sine sample=*saw sample=*square sample=*triangle sample=*tri sample=*noise sample=*silence Tri is an alias for triangle. For cases where we don't want to actually play a sample but want a region to exist and be played (for example, to mute other sounds when using group and off_by , the silence value can be very convenient). Note that in this case the * is a real character and not a wildcard.","title":"Examples"},{"location":"opcodes/sample_dyn_paramN/","text":"This is used for the parameter modulations in TableWarp2 , as well as in some commercial ARIA-based products which use sfz internally in their configuration.","title":"sample dyn paramN"},{"location":"opcodes/sample_dyn_paramN_onccX/","text":"This is used for the parameter modulations in TableWarp2 , as well as in some commercial ARIA-based products which use sfz internally in their configuration.","title":"sample dyn paramN onccX"},{"location":"opcodes/sample_fadeout/","text":"The fadeout end coincides with playback end. (Source: Peter L. Jones SFZ page ) Example <region> sample=4_seconds_c3.wav loop_mode=no_loop sample_fadeout=2.5 The curve used for fading out is linear. Practical Considerations This opcode is supported in RGC sfz and Cakewalk products, where at least in DropZone uses sample units instead seconds.","title":"Sample fadeout"},{"location":"opcodes/sample_fadeout/#example","text":"<region> sample=4_seconds_c3.wav loop_mode=no_loop sample_fadeout=2.5 The curve used for fading out is linear.","title":"Example"},{"location":"opcodes/sample_fadeout/#practical-considerations","text":"This opcode is supported in RGC sfz and Cakewalk products, where at least in DropZone uses sample units instead seconds.","title":"Practical Considerations"},{"location":"opcodes/sample_quality/","text":"Defines the interpolation algorithm used for samples. The higher the setting, the better the algorithm is in terms of sound quality, at the expense of processing speed. 1: linear interpolation 2: higher quality interpolation, for example a polynomial interpolator 3-10: windowed sinc interpolation, using increasingly larger window sizes","title":"Sample quality"},{"location":"opcodes/script/","text":"This is an extension to the SFZ file format which is currently only available with LinuxSampler v2.0.0.svn37 or higher. Find out more about Instrument Scripts . The mandatory path parameter defines the file system path to the real-time instrument script file that shall be loaded and executed, which may either be an absolute path or a relative path. A relative path is always interpreted relative to the SFZ file's location. May only be used in \u2039global\u203a section. Example Loads the WAV file \"some_sound.wav\" and assigns it to the entire key range of the instrument, and loads the real-time instrument script file \"my_nksp_script.txt\" from the subdirectory \"myscripts\". The script will be executed on the respective events the script file provides event handlers for. <global> script=myscripts/my_nksp_script.txt <group> sample=some_sound.wav Source: LinuxSampler Documentation","title":"Script"},{"location":"opcodes/script/#example","text":"Loads the WAV file \"some_sound.wav\" and assigns it to the entire key range of the instrument, and loads the real-time instrument script file \"my_nksp_script.txt\" from the subdirectory \"myscripts\". The script will be executed on the respective events the script file provides event handlers for. <global> script=myscripts/my_nksp_script.txt <group> sample=some_sound.wav Source: LinuxSampler Documentation","title":"Example"},{"location":"opcodes/seq_length/","text":"The player will keep an internal counter creating a consecutive note-on sequence for each region, starting at 1 and resetting at seq_length . Example seq_length=3 A typical usage for a kick drum with four round robins, and a snare with three round robins, would look like this: <group>key=36 seq_length=4 <region>seq_position=1 sample=kick_rr1.wav <region>seq_position=2 sample=kick_rr2.wav <region>seq_position=3 sample=kick_rr3.wav <region>seq_position=4 sample=kick_rr4.wav <group>key=38 seq_length=3 <region>seq_position=1 sample=snare_rr1.wav <region>seq_position=2 sample=snare_rr2.wav <region>seq_position=3 sample=snare_rr3.wav An alternative to this is using lorand / hirand for random, instead of sequential, round robins. If there are enough samples available, both methods can also be combined - the combination is described on the lorand / hirand page. However, lorand/hirand might not be a good idea to use with samples which have multiple microphone positions, and sticking to seq_position and seq_length might be necessary. Practical Considerations In the ARIA implementation of SFZ, sequence position is not tracked together for all regions, which means sequential round robins is not a practical way to implement alternating left/right hand or up/down bowing samples. Setting seq_length to 0 behaves the same as setting it to 1 in Cakewalk players, sfizz and BassMIDI, but a setting of 0 in ARIA will cause each round robin in the sequence to be played once, and playing more notes once the counter exceeds the highest seq_position will result in no sound.","title":"Seq length"},{"location":"opcodes/seq_length/#example","text":"seq_length=3 A typical usage for a kick drum with four round robins, and a snare with three round robins, would look like this: <group>key=36 seq_length=4 <region>seq_position=1 sample=kick_rr1.wav <region>seq_position=2 sample=kick_rr2.wav <region>seq_position=3 sample=kick_rr3.wav <region>seq_position=4 sample=kick_rr4.wav <group>key=38 seq_length=3 <region>seq_position=1 sample=snare_rr1.wav <region>seq_position=2 sample=snare_rr2.wav <region>seq_position=3 sample=snare_rr3.wav An alternative to this is using lorand / hirand for random, instead of sequential, round robins. If there are enough samples available, both methods can also be combined - the combination is described on the lorand / hirand page. However, lorand/hirand might not be a good idea to use with samples which have multiple microphone positions, and sticking to seq_position and seq_length might be necessary.","title":"Example"},{"location":"opcodes/seq_length/#practical-considerations","text":"In the ARIA implementation of SFZ, sequence position is not tracked together for all regions, which means sequential round robins is not a practical way to implement alternating left/right hand or up/down bowing samples. Setting seq_length to 0 behaves the same as setting it to 1 in Cakewalk players, sfizz and BassMIDI, but a setting of 0 in ARIA will cause each round robin in the sequence to be played once, and playing more notes once the counter exceeds the highest seq_position will result in no sound.","title":"Practical Considerations"},{"location":"opcodes/seq_position/","text":"This is used together with seq_length to use samples as round robins. The player will keep an internal counter creating a consecutive note-on sequence for each region, starting at 1 and resetting at seq_length. Maximum allowed value is 100. Example seq_length=4 seq_position=2 In above example, the region will play on the second note every four notes. A typical usage for a kick drum with four round robins, and a snare with three round robins, would look like this: <group>key=36 seq_length=4 <region>seq_position=1 sample=kick_rr1.wav <region>seq_position=2 sample=kick_rr2.wav <region>seq_position=3 sample=kick_rr3.wav <region>seq_position=4 sample=kick_rr4.wav <group>key=38 seq_length=3 <region>seq_position=1 sample=snare_rr1.wav <region>seq_position=2 sample=snare_rr2.wav <region>seq_position=3 sample=snare_rr3.wav An alternative to this is using lorand / hirand for random, instead of sequential, round robins. If there are enough samples available, both methods can also be combined - the combination is described on the lorand / hirand page. However, lorand/hirand might not be a good idea to use with samples which have multiple microphone positions, and sticking to seq_position and seq_length might be necessary. Practical Considerations In at least some SFZ players, sequence position is not tracked together for all regions, which means seq_position is not a practical way to implement alternating left/right hand or up/down bowing samples. Some players also match velocity ranges for each step in the sequence, which can cause problems when the sequence steps do not have the same velocity layer split points. For example, this can produce occasional silence, depending on the velocity of incoming MIDI notes, the velocity of the previous MIDI note, and the current point in the sequence: <global> seq_length=2 key=48 <group> seq_position=1 <region> lovel=1 hivel=31 sample=*noise <region> lovel=32 hivel=127 sample=*saw <group> seq_position=2 <region> lovel=1 hivel=95 sample=*noise <region> lovel=96 hivel=127 sample=*saw This will also happen in cases where, for example, one step in the sequence has three velocity layers and the other step has four, as it's not possible to make the layer split points match then. In those players, this is a workaround: <global> seq_length=2 key=48 <group> seq_position=1 <region> lovel=1 hivel=31 sample=*noise <region> lovel=32 hivel=95 sample=*saw <region> lovel=96 hivel=127 sample=*saw <group> seq_position=2 <region> lovel=1 hivel=31 sample=*noise <region> lovel=32 hivel=95 sample=*noise <region> lovel=96 hivel=127 sample=*saw Setting seq_position to 0 will cause the region to not play in most sfz player, except for sfizz where it will behave the same as setting seq_position to 1.","title":"Seq position"},{"location":"opcodes/seq_position/#example","text":"seq_length=4 seq_position=2 In above example, the region will play on the second note every four notes. A typical usage for a kick drum with four round robins, and a snare with three round robins, would look like this: <group>key=36 seq_length=4 <region>seq_position=1 sample=kick_rr1.wav <region>seq_position=2 sample=kick_rr2.wav <region>seq_position=3 sample=kick_rr3.wav <region>seq_position=4 sample=kick_rr4.wav <group>key=38 seq_length=3 <region>seq_position=1 sample=snare_rr1.wav <region>seq_position=2 sample=snare_rr2.wav <region>seq_position=3 sample=snare_rr3.wav An alternative to this is using lorand / hirand for random, instead of sequential, round robins. If there are enough samples available, both methods can also be combined - the combination is described on the lorand / hirand page. However, lorand/hirand might not be a good idea to use with samples which have multiple microphone positions, and sticking to seq_position and seq_length might be necessary.","title":"Example"},{"location":"opcodes/seq_position/#practical-considerations","text":"In at least some SFZ players, sequence position is not tracked together for all regions, which means seq_position is not a practical way to implement alternating left/right hand or up/down bowing samples. Some players also match velocity ranges for each step in the sequence, which can cause problems when the sequence steps do not have the same velocity layer split points. For example, this can produce occasional silence, depending on the velocity of incoming MIDI notes, the velocity of the previous MIDI note, and the current point in the sequence: <global> seq_length=2 key=48 <group> seq_position=1 <region> lovel=1 hivel=31 sample=*noise <region> lovel=32 hivel=127 sample=*saw <group> seq_position=2 <region> lovel=1 hivel=95 sample=*noise <region> lovel=96 hivel=127 sample=*saw This will also happen in cases where, for example, one step in the sequence has three velocity layers and the other step has four, as it's not possible to make the layer split points match then. In those players, this is a workaround: <global> seq_length=2 key=48 <group> seq_position=1 <region> lovel=1 hivel=31 sample=*noise <region> lovel=32 hivel=95 sample=*saw <region> lovel=96 hivel=127 sample=*saw <group> seq_position=2 <region> lovel=1 hivel=31 sample=*noise <region> lovel=32 hivel=95 sample=*noise <region> lovel=96 hivel=127 sample=*saw Setting seq_position to 0 will cause the region to not play in most sfz player, except for sfizz where it will behave the same as setting seq_position to 1.","title":"Practical Considerations"},{"location":"opcodes/set_ccN/","text":"Used under the \u2039 control \u203a header. Examples set_cc40=127 set_cc100=30","title":"set ccN"},{"location":"opcodes/set_ccN/#examples","text":"set_cc40=127 set_cc100=30","title":"Examples"},{"location":"opcodes/set_hdccN/","text":"Sets a default initial value for MIDI CC number N using a floating point value, when the instrument is initially loaded. Used under the \u2039 control \u203a header. Examples <control> set_hdcc16=0.5 <master> amplitude_oncc16=100 <region> sample=*sine Practical Considerations set_realccN is a deprecated alias for set_hdccN .","title":"set hdccN"},{"location":"opcodes/set_hdccN/#examples","text":"<control> set_hdcc16=0.5 <master> amplitude_oncc16=100 <region> sample=*sine","title":"Examples"},{"location":"opcodes/set_hdccN/#practical-considerations","text":"set_realccN is a deprecated alias for set_hdccN .","title":"Practical Considerations"},{"location":"opcodes/set_realccN/","text":"Sets a default initial value for MIDI CC number N using a floating point value, when the instrument is initially loaded. Used under the \u2039 control \u203a header. Examples <control> set_hdcc16=0.5 <master> amplitude_oncc16=100 <region> sample=*sine Practical Considerations set_realccN is a deprecated alias for set_hdccN .","title":"set realccN"},{"location":"opcodes/set_realccN/#examples","text":"<control> set_hdcc16=0.5 <master> amplitude_oncc16=100 <region> sample=*sine","title":"Examples"},{"location":"opcodes/set_realccN/#practical-considerations","text":"set_realccN is a deprecated alias for set_hdccN .","title":"Practical Considerations"},{"location":"opcodes/sostenuto_cc/","text":"The default is 66, the standard sustain pedal assignment in the MIDI specification. Examples sostenuto_cc=12 sostenuto_cc=122","title":"Sostenuto cc"},{"location":"opcodes/sostenuto_cc/#examples","text":"sostenuto_cc=12 sostenuto_cc=122","title":"Examples"},{"location":"opcodes/sostenuto_lo/","text":"Default is 0.5, meaning the sustain pedal is down as long as the CC value is anything above 0. To make the pedal only act as \"down\" past the halfway point, set this to 64 - then the pedal is considered \"up\" from CC value 0 to 63, and \"down\" from 64 to 127. Leaving this at the default value of 1, or setting it to some other low number such as 10, is useful when the piano supports half-pedaling. Setting it to 64 is preferred by some users who want to use the sostenuto pedal as an on/off switch for instruments with no half-pedaling. Examples sostenuto_lo=64 sostenuto_lo=20","title":"Sostenuto lo"},{"location":"opcodes/sostenuto_lo/#examples","text":"sostenuto_lo=64 sostenuto_lo=20","title":"Examples"},{"location":"opcodes/sostenuto_sw/","text":"Example sostenuto_sw=off","title":"Sostenuto sw"},{"location":"opcodes/sostenuto_sw/#example","text":"sostenuto_sw=off","title":"Example"},{"location":"opcodes/start_hiccN/","text":"Sample trigger on MIDI continuous control N. This does not involve playing any MIDI notes. Example on_locc64=127 on_hicc64=127 Region will play when a MIDI CC64 (sustain pedal) message with 127 value is received. So, basically, when the sustain pedal is pressed down, this region will play. This is useful with piano pedals - in the above example, on_loccN and on_hiccN could be used to trigger a mechanical noise sample, whether any keys are being played or not. It would not typically be used with hi-hat pedals, as most electronic drum kits will send a MIDI note when the pedal hits bottom. Practical Considerations on_locc/on_hicc effectively replaces the default trigger =attack. The behavior of a region which has on_locc/on_hicc and trigger=attack both explicitly specified is not defined by the SFZ specification, and that combination should be used. In ARIA if on_locc/on_hicc and trigger=release or trigger=release_key is used, the on_locc/on_hicc opcode will be effectively disregarded, and the region will behave like a normal release or release_key region.","title":"on_loccN / on_hiccN"},{"location":"opcodes/start_hiccN/#example","text":"on_locc64=127 on_hicc64=127 Region will play when a MIDI CC64 (sustain pedal) message with 127 value is received. So, basically, when the sustain pedal is pressed down, this region will play. This is useful with piano pedals - in the above example, on_loccN and on_hiccN could be used to trigger a mechanical noise sample, whether any keys are being played or not. It would not typically be used with hi-hat pedals, as most electronic drum kits will send a MIDI note when the pedal hits bottom.","title":"Example"},{"location":"opcodes/start_hiccN/#practical-considerations","text":"on_locc/on_hicc effectively replaces the default trigger =attack. The behavior of a region which has on_locc/on_hicc and trigger=attack both explicitly specified is not defined by the SFZ specification, and that combination should be used. In ARIA if on_locc/on_hicc and trigger=release or trigger=release_key is used, the on_locc/on_hicc opcode will be effectively disregarded, and the region will behave like a normal release or release_key region.","title":"Practical Considerations"},{"location":"opcodes/start_hihdccN/","text":"Example on_lohdcc64=1 on_hihdcc64=1","title":"on_lohdccN / on_hihdccN"},{"location":"opcodes/start_hihdccN/#example","text":"on_lohdcc64=1 on_hihdcc64=1","title":"Example"},{"location":"opcodes/start_loccN/","text":"Sample trigger on MIDI continuous control N. This does not involve playing any MIDI notes. Example on_locc64=127 on_hicc64=127 Region will play when a MIDI CC64 (sustain pedal) message with 127 value is received. So, basically, when the sustain pedal is pressed down, this region will play. This is useful with piano pedals - in the above example, on_loccN and on_hiccN could be used to trigger a mechanical noise sample, whether any keys are being played or not. It would not typically be used with hi-hat pedals, as most electronic drum kits will send a MIDI note when the pedal hits bottom. Practical Considerations on_locc/on_hicc effectively replaces the default trigger =attack. The behavior of a region which has on_locc/on_hicc and trigger=attack both explicitly specified is not defined by the SFZ specification, and that combination should be used. In ARIA if on_locc/on_hicc and trigger=release or trigger=release_key is used, the on_locc/on_hicc opcode will be effectively disregarded, and the region will behave like a normal release or release_key region.","title":"on_loccN / on_hiccN"},{"location":"opcodes/start_loccN/#example","text":"on_locc64=127 on_hicc64=127 Region will play when a MIDI CC64 (sustain pedal) message with 127 value is received. So, basically, when the sustain pedal is pressed down, this region will play. This is useful with piano pedals - in the above example, on_loccN and on_hiccN could be used to trigger a mechanical noise sample, whether any keys are being played or not. It would not typically be used with hi-hat pedals, as most electronic drum kits will send a MIDI note when the pedal hits bottom.","title":"Example"},{"location":"opcodes/start_loccN/#practical-considerations","text":"on_locc/on_hicc effectively replaces the default trigger =attack. The behavior of a region which has on_locc/on_hicc and trigger=attack both explicitly specified is not defined by the SFZ specification, and that combination should be used. In ARIA if on_locc/on_hicc and trigger=release or trigger=release_key is used, the on_locc/on_hicc opcode will be effectively disregarded, and the region will behave like a normal release or release_key region.","title":"Practical Considerations"},{"location":"opcodes/start_lohdccN/","text":"Example on_lohdcc64=1 on_hihdcc64=1","title":"on_lohdccN / on_hihdccN"},{"location":"opcodes/start_lohdccN/#example","text":"on_lohdcc64=1 on_hihdcc64=1","title":"Example"},{"location":"opcodes/static_cyclic_level/","text":"Used under the \u2039effect\u203a header, with type = static .","title":"Static cyclic level"},{"location":"opcodes/static_cyclic_time/","text":"Used under the \u2039effect\u203a header, with type = static .","title":"Static cyclic time"},{"location":"opcodes/static_filter/","text":"Used under the \u2039effect\u203a header, with type = static .","title":"Static filter"},{"location":"opcodes/static_level/","text":"Used under the \u2039effect\u203a header, with type = static .","title":"Static level"},{"location":"opcodes/static_level_onccN/","text":"Used under the \u2039effect\u203a header, with type = static .","title":"static level onccN"},{"location":"opcodes/static_random_level/","text":"Used under the \u2039effect\u203a header, with type = static .","title":"Static random level"},{"location":"opcodes/static_random_maxtime/","text":"Used under the \u2039effect\u203a header, with type = static .","title":"Static random maxtime"},{"location":"opcodes/static_random_mintime/","text":"Used under the \u2039effect\u203a header, with type = static .","title":"Static random mintime"},{"location":"opcodes/static_stereo/","text":"Used under the \u2039effect\u203a header, with type = static .","title":"Static stereo"},{"location":"opcodes/static_tone/","text":"Used under the \u2039effect\u203a header, with type = static .","title":"Static tone"},{"location":"opcodes/stop_beats/","text":"Used in Cakewalk Dimension Pro and DropZone, alongside delay_beats , to play slices of loops at specific points in the bar. Examples delay_beats=1 stop_beats=1.5 delay_beats=25.9922 stop_beats=26.0964 Practical Considerations Intended to be a counterpart to delay_beats and used in Cakewalk Dimension Pro and DropZone. This opcode appears to be not implemented in ARIA - it passes the parser in ARIA but seems to have no effect on its region.","title":"Stop beats"},{"location":"opcodes/stop_beats/#examples","text":"delay_beats=1 stop_beats=1.5 delay_beats=25.9922 stop_beats=26.0964","title":"Examples"},{"location":"opcodes/stop_beats/#practical-considerations","text":"Intended to be a counterpart to delay_beats and used in Cakewalk Dimension Pro and DropZone. This opcode appears to be not implemented in ARIA - it passes the parser in ARIA but seems to have no effect on its region.","title":"Practical Considerations"},{"location":"opcodes/stop_hiccN/","text":"Practical Considerations This was intended to be used together with start_loccN / start_hiccN , but has not yet been implemented, which means this opcode passes the parser in ARIA but has no effect on the region.","title":"stop_loccN / stop_hiccN"},{"location":"opcodes/stop_hiccN/#practical-considerations","text":"This was intended to be used together with start_loccN / start_hiccN , but has not yet been implemented, which means this opcode passes the parser in ARIA but has no effect on the region.","title":"Practical Considerations"},{"location":"opcodes/stop_hihdccN/","text":"","title":"stop_lohdccN / stop_hihdccN"},{"location":"opcodes/stop_loccN/","text":"Practical Considerations This was intended to be used together with start_loccN / start_hiccN , but has not yet been implemented, which means this opcode passes the parser in ARIA but has no effect on the region.","title":"stop_loccN / stop_hiccN"},{"location":"opcodes/stop_loccN/#practical-considerations","text":"This was intended to be used together with start_loccN / start_hiccN , but has not yet been implemented, which means this opcode passes the parser in ARIA but has no effect on the region.","title":"Practical Considerations"},{"location":"opcodes/stop_lohdccN/","text":"","title":"stop_lohdccN / stop_hihdccN"},{"location":"opcodes/strings_number/","text":"Used under the \u2039effect\u203a header, with type = strings .","title":"Strings number"},{"location":"opcodes/strings_wet_onccN/","text":"Used under the \u2039effect\u203a header, with type = strings .","title":"strings wet onccN"},{"location":"opcodes/sustain_cc/","text":"The default is 64, the standard sustain pedal assignment in the MIDI specification. Examples sustain_cc=4 sustain_cc=120","title":"Sustain cc"},{"location":"opcodes/sustain_cc/#examples","text":"sustain_cc=4 sustain_cc=120","title":"Examples"},{"location":"opcodes/sustain_lo/","text":"This ARIA extension sets the minimum point at which the sustain pedal (MIDI CC 64) is considered \"down\". Default is 0.5, meaning the sustain pedal is down as long as the CC value is anything above 0. To make the pedal only act as \"down\" past the halfway point, set this to 64 - then the pedal is considered \"up\" from CC value 0 to 63, and \"down\" from 64 to 127. Leaving this at the default value of 1, or setting it to some other low number such as 10, is useful when the piano supports half-pedaling. Setting it to 64 is preferred by some users who want to use the sustain pedal as an on/off sustain switch for instruments with no half-pedaling. Please note that the direction of the MIDI CC values is normally from 0 at the top of the pedal to 127 when it is at the bottom, meaning that physically \"down\" on the pedal is up in terms of MIDI CC value. It is possible to set this to different values for different regions, so that for example mechanical noises and notes will not be affected by the sustain pedal in the same way. Examples sustain_lo=64 sustain_lo=20","title":"Sustain lo"},{"location":"opcodes/sustain_lo/#examples","text":"sustain_lo=64 sustain_lo=20","title":"Examples"},{"location":"opcodes/sustain_sw/","text":"Example sustain_sw=off","title":"Sustain sw"},{"location":"opcodes/sustain_sw/#example","text":"sustain_sw=off","title":"Example"},{"location":"opcodes/sw_default/","text":"sw_default sets a default value for sw_last . In a guitar instrument which uses keyswitches to select articulations, this can be used to for example make the picked articulation active by default when the instrument is first loaded. Without sw_default , this instrument would be silent until a keyswitch is manually used to select an articulation. Example // ********************************************************************** // A Keyswitching Example // // Notes 36,38 and 40 serve as switches to trigger sine, triangle or saw oscillators. // you can expand on this concept to create your own KeySwitching instruments. // ********************************************************************** <global> sw_lokey=36 sw_hikey=40 sw_default=36 <region> sw_last=36 sw_label=Sine lokey=41 sample=*sine <region> sw_last=38 sw_label=Triangle lokey=41 sample=*triangle <region> sw_last=40 sw_label=Saw lokey=41 sample=*saw Practical Considerations sw_label causes ARIA/Sforzando to display the most recent selected keyswitch label appear on its interface. This apparently needs to be set for all regions for which that sw_last value is set, which can mean setting the label in multiple places in an sfz file.","title":"sw_default / sw_label"},{"location":"opcodes/sw_default/#example","text":"// ********************************************************************** // A Keyswitching Example // // Notes 36,38 and 40 serve as switches to trigger sine, triangle or saw oscillators. // you can expand on this concept to create your own KeySwitching instruments. // ********************************************************************** <global> sw_lokey=36 sw_hikey=40 sw_default=36 <region> sw_last=36 sw_label=Sine lokey=41 sample=*sine <region> sw_last=38 sw_label=Triangle lokey=41 sample=*triangle <region> sw_last=40 sw_label=Saw lokey=41 sample=*saw","title":"Example"},{"location":"opcodes/sw_default/#practical-considerations","text":"sw_label causes ARIA/Sforzando to display the most recent selected keyswitch label appear on its interface. This apparently needs to be set for all regions for which that sw_last value is set, which can mean setting the label in multiple places in an sfz file.","title":"Practical Considerations"},{"location":"opcodes/sw_down/","text":"Can be entered in either MIDI note numbers (0 to 127) or in MIDI note names (C-1 to G9) Example sw_down=C3 sw_down=24 sw_up=25 The difference between sw_down and sw_last is that sw_last is a \"sticky\" keyswitch - after releasing the keyswitch note, it continues to affect notes until another keyswitch is pressed. sw_down , on the other hand, is \"non-sticky\" and only affects notes played while the switch is held down. It could also possibly be used for true legato instead of sw_previous . If there is a default articulation which should sound when no sw_down keys are pressed, sw_up should be defined for those regions. For example, if there is a flute with a default sustain articulation which should not sound when an ornamentation is selected using sw_down , the default sustain articulation can use sw_up so it only sounds when no ornamentation keyswitch is held down. In ARIA, either sw_down or sw_up can be a note in the playable range, regardless of whether sw_lokey / hikey is defined or not. In rgc sfz, they can be in the playable range if sw_lokey/hikey are not defined, but if they are defined, then sw_down and sw_up notes must fall in the sw_lokey/hikey range.","title":"sw_down / sw_up"},{"location":"opcodes/sw_down/#example","text":"sw_down=C3 sw_down=24 sw_up=25 The difference between sw_down and sw_last is that sw_last is a \"sticky\" keyswitch - after releasing the keyswitch note, it continues to affect notes until another keyswitch is pressed. sw_down , on the other hand, is \"non-sticky\" and only affects notes played while the switch is held down. It could also possibly be used for true legato instead of sw_previous . If there is a default articulation which should sound when no sw_down keys are pressed, sw_up should be defined for those regions. For example, if there is a flute with a default sustain articulation which should not sound when an ornamentation is selected using sw_down , the default sustain articulation can use sw_up so it only sounds when no ornamentation keyswitch is held down. In ARIA, either sw_down or sw_up can be a note in the playable range, regardless of whether sw_lokey / hikey is defined or not. In rgc sfz, they can be in the playable range if sw_lokey/hikey are not defined, but if they are defined, then sw_down and sw_up notes must fall in the sw_lokey/hikey range.","title":"Example"},{"location":"opcodes/sw_hikey/","text":"Basically, this tells the SFZ player where the keyswitches are. As such, it's normally going to be the same for the entire instrument, so sw_lokey and sw_hikey will be set under the \u2039global\u203a header. This affects sw_last keyswitches. On the other hand, sw_previous keyswitches can be outside of this range - and indeed often must be, as sw_previous is often used for legato instruments. With sw_down / sw_up this behavior is implementation-dependent. In ARIA, either sw_down or sw_up can be a note in the playable range, regardless of whether sw_lokey / hikey is defined or not. In rgc sfz, they can be in the playable range if sw_lokey/hikey are not defined, but if they are defined, then sw_down and sw_up notes must fall in the sw_lokey/hikey range. sw_lokey and sw_hikey can be entered in either MIDI note numbers (0 to 127) or in MIDI note names (C-1 to G9) Example sw_lokey=48 sw_hikey=53","title":"sw_lokey / sw_hikey"},{"location":"opcodes/sw_hikey/#example","text":"sw_lokey=48 sw_hikey=53","title":"Example"},{"location":"opcodes/sw_hilast/","text":"sw_lolast specifies the bottom of the range, and sw_hilast the high. Example sw_lolast=24 sw_hilast=25 This is useful when there are multiple regions being triggered, and some of them are common across several keyswitches - for example, fretting noises triggered on note release on a guitar might be the same across both normal, hammer-on and slide articulations, but should not be triggered for harmonics.","title":"sw_lolast / sw_hilast"},{"location":"opcodes/sw_hilast/#example","text":"sw_lolast=24 sw_hilast=25 This is useful when there are multiple regions being triggered, and some of them are common across several keyswitches - for example, fretting noises triggered on note release on a guitar might be the same across both normal, hammer-on and slide articulations, but should not be triggered for harmonics.","title":"Example"},{"location":"opcodes/sw_label/","text":"sw_default sets a default value for sw_last . In a guitar instrument which uses keyswitches to select articulations, this can be used to for example make the picked articulation active by default when the instrument is first loaded. Without sw_default , this instrument would be silent until a keyswitch is manually used to select an articulation. Example // ********************************************************************** // A Keyswitching Example // // Notes 36,38 and 40 serve as switches to trigger sine, triangle or saw oscillators. // you can expand on this concept to create your own KeySwitching instruments. // ********************************************************************** <global> sw_lokey=36 sw_hikey=40 sw_default=36 <region> sw_last=36 sw_label=Sine lokey=41 sample=*sine <region> sw_last=38 sw_label=Triangle lokey=41 sample=*triangle <region> sw_last=40 sw_label=Saw lokey=41 sample=*saw Practical Considerations sw_label causes ARIA/Sforzando to display the most recent selected keyswitch label appear on its interface. This apparently needs to be set for all regions for which that sw_last value is set, which can mean setting the label in multiple places in an sfz file.","title":"sw_default / sw_label"},{"location":"opcodes/sw_label/#example","text":"// ********************************************************************** // A Keyswitching Example // // Notes 36,38 and 40 serve as switches to trigger sine, triangle or saw oscillators. // you can expand on this concept to create your own KeySwitching instruments. // ********************************************************************** <global> sw_lokey=36 sw_hikey=40 sw_default=36 <region> sw_last=36 sw_label=Sine lokey=41 sample=*sine <region> sw_last=38 sw_label=Triangle lokey=41 sample=*triangle <region> sw_last=40 sw_label=Saw lokey=41 sample=*saw","title":"Example"},{"location":"opcodes/sw_label/#practical-considerations","text":"sw_label causes ARIA/Sforzando to display the most recent selected keyswitch label appear on its interface. This apparently needs to be set for all regions for which that sw_last value is set, which can mean setting the label in multiple places in an sfz file.","title":"Practical Considerations"},{"location":"opcodes/sw_last/","text":"sw_last can be entered in either MIDI note numbers (0 to 127) or in MIDI note names (C-1 to G9) Example sw_last=49 This is commonly used to select articulations, for example to switch between sustain, staccato, spiccato and pizzicato in a violin. With the SFZ 1 or SFZ 2 spec, an instrument which uses sw_last to select articulations will not have a default articulation preselected, meaning when loaded, it will play no sound until one of the keyswitches is pressed - only after that will the instrument respond to notes. The ARIA extensions include sw_default as a solution to this. The difference between this and sw_down is that sw_last is a \"sticky\" keyswitch - after releasing the keyswitch note, it continues to affect notes until another keyswitch is pressed. sw_down , on the other hand, is \"non-sticky\" and only affects notes played while the switch is held down. This makes sw_last a good choice for keyswitching articulations which are often used for many notes in a row, such as sustain or staccato. An example of using sw_last to select oscillator waves, with sw_default used to set the sine to default as well. // ********************************************************************** // A Keyswitching Example // // Notes 36,38 and 40 serve as switches to trigger sine, triangle or saw oscillators. // you can expand on this concept to create your own KeySwitching instruments. // ********************************************************************** <global> sw_lokey=36 sw_hikey=40 sw_default=36 <region> sw_last=36 sw_label=Sine lokey=41 sample=*sine <region> sw_last=38 sw_label=Triangle lokey=41 sample=*triangle <region> sw_last=40 sw_label=Saw lokey=41 sample=*saw","title":"Sw last"},{"location":"opcodes/sw_last/#example","text":"sw_last=49 This is commonly used to select articulations, for example to switch between sustain, staccato, spiccato and pizzicato in a violin. With the SFZ 1 or SFZ 2 spec, an instrument which uses sw_last to select articulations will not have a default articulation preselected, meaning when loaded, it will play no sound until one of the keyswitches is pressed - only after that will the instrument respond to notes. The ARIA extensions include sw_default as a solution to this. The difference between this and sw_down is that sw_last is a \"sticky\" keyswitch - after releasing the keyswitch note, it continues to affect notes until another keyswitch is pressed. sw_down , on the other hand, is \"non-sticky\" and only affects notes played while the switch is held down. This makes sw_last a good choice for keyswitching articulations which are often used for many notes in a row, such as sustain or staccato. An example of using sw_last to select oscillator waves, with sw_default used to set the sine to default as well. // ********************************************************************** // A Keyswitching Example // // Notes 36,38 and 40 serve as switches to trigger sine, triangle or saw oscillators. // you can expand on this concept to create your own KeySwitching instruments. // ********************************************************************** <global> sw_lokey=36 sw_hikey=40 sw_default=36 <region> sw_last=36 sw_label=Sine lokey=41 sample=*sine <region> sw_last=38 sw_label=Triangle lokey=41 sample=*triangle <region> sw_last=40 sw_label=Saw lokey=41 sample=*saw","title":"Example"},{"location":"opcodes/sw_lokey/","text":"Basically, this tells the SFZ player where the keyswitches are. As such, it's normally going to be the same for the entire instrument, so sw_lokey and sw_hikey will be set under the \u2039global\u203a header. This affects sw_last keyswitches. On the other hand, sw_previous keyswitches can be outside of this range - and indeed often must be, as sw_previous is often used for legato instruments. With sw_down / sw_up this behavior is implementation-dependent. In ARIA, either sw_down or sw_up can be a note in the playable range, regardless of whether sw_lokey / hikey is defined or not. In rgc sfz, they can be in the playable range if sw_lokey/hikey are not defined, but if they are defined, then sw_down and sw_up notes must fall in the sw_lokey/hikey range. sw_lokey and sw_hikey can be entered in either MIDI note numbers (0 to 127) or in MIDI note names (C-1 to G9) Example sw_lokey=48 sw_hikey=53","title":"sw_lokey / sw_hikey"},{"location":"opcodes/sw_lokey/#example","text":"sw_lokey=48 sw_hikey=53","title":"Example"},{"location":"opcodes/sw_lolast/","text":"sw_lolast specifies the bottom of the range, and sw_hilast the high. Example sw_lolast=24 sw_hilast=25 This is useful when there are multiple regions being triggered, and some of them are common across several keyswitches - for example, fretting noises triggered on note release on a guitar might be the same across both normal, hammer-on and slide articulations, but should not be triggered for harmonics.","title":"sw_lolast / sw_hilast"},{"location":"opcodes/sw_lolast/#example","text":"sw_lolast=24 sw_hilast=25 This is useful when there are multiple regions being triggered, and some of them are common across several keyswitches - for example, fretting noises triggered on note release on a guitar might be the same across both normal, hammer-on and slide articulations, but should not be triggered for harmonics.","title":"Example"},{"location":"opcodes/sw_note_offset/","text":"Used under the \u2039 control \u203a header.","title":"Sw note offset"},{"location":"opcodes/sw_octave_offset/","text":"Used under the \u2039 control \u203a header.","title":"Sw octave offset"},{"location":"opcodes/sw_previous/","text":"sw_previous can be entered in either MIDI note numbers (0 to 127) or in MIDI note names (C-1 to G9) Example sw_previous=60 Note that unlike sw_last , the note specified by sw_previous doesn't need to fall in the sw_lokey / sw_hikey range. This is useful for true sampled legato.","title":"Sw previous"},{"location":"opcodes/sw_previous/#example","text":"sw_previous=60 Note that unlike sw_last , the note specified by sw_previous doesn't need to fall in the sw_lokey / sw_hikey range. This is useful for true sampled legato.","title":"Example"},{"location":"opcodes/sw_up/","text":"Can be entered in either MIDI note numbers (0 to 127) or in MIDI note names (C-1 to G9) Example sw_down=C3 sw_down=24 sw_up=25 The difference between sw_down and sw_last is that sw_last is a \"sticky\" keyswitch - after releasing the keyswitch note, it continues to affect notes until another keyswitch is pressed. sw_down , on the other hand, is \"non-sticky\" and only affects notes played while the switch is held down. It could also possibly be used for true legato instead of sw_previous . If there is a default articulation which should sound when no sw_down keys are pressed, sw_up should be defined for those regions. For example, if there is a flute with a default sustain articulation which should not sound when an ornamentation is selected using sw_down , the default sustain articulation can use sw_up so it only sounds when no ornamentation keyswitch is held down. In ARIA, either sw_down or sw_up can be a note in the playable range, regardless of whether sw_lokey / hikey is defined or not. In rgc sfz, they can be in the playable range if sw_lokey/hikey are not defined, but if they are defined, then sw_down and sw_up notes must fall in the sw_lokey/hikey range.","title":"sw_down / sw_up"},{"location":"opcodes/sw_up/#example","text":"sw_down=C3 sw_down=24 sw_up=25 The difference between sw_down and sw_last is that sw_last is a \"sticky\" keyswitch - after releasing the keyswitch note, it continues to affect notes until another keyswitch is pressed. sw_down , on the other hand, is \"non-sticky\" and only affects notes played while the switch is held down. It could also possibly be used for true legato instead of sw_previous . If there is a default articulation which should sound when no sw_down keys are pressed, sw_up should be defined for those regions. For example, if there is a flute with a default sustain articulation which should not sound when an ornamentation is selected using sw_down , the default sustain articulation can use sw_up so it only sounds when no ornamentation keyswitch is held down. In ARIA, either sw_down or sw_up can be a note in the playable range, regardless of whether sw_lokey / hikey is defined or not. In rgc sfz, they can be in the playable range if sw_lokey/hikey are not defined, but if they are defined, then sw_down and sw_up notes must fall in the sw_lokey/hikey range.","title":"Example"},{"location":"opcodes/sw_vel/","text":"Values can be: current : Region uses the velocity of current note. previous : Region uses the velocity of the previous note. Example sw_vel=previous With sw_vel set to previous, a newly played region will be the triggered using the previous region's velocity. For example, if the previous velocity is 100 and the velocity of the new note-on message is 60, the new region will play as if its velocity was 100. Setting this to previous is useful for making certain legato instruments sound smoother and more consistent. Practical Considerations At least in ARIA, this affects only volume, and using velocity to modulate pitch or filter cutoff will use the current note's velocity regardless of how sw_vel is set. Also in ARIA, sw_vel can work even if sw_previous is not defined. To have sw_vel working in sfz.dll and DropZone and other Cakewalk players, sw_previous need to be defined. Fil_veltrack, pitch_veltrack and other velocity modulation e.g. ampeg_vel2attack, etc, also affected by sw_vel.","title":"Sw vel"},{"location":"opcodes/sw_vel/#example","text":"sw_vel=previous With sw_vel set to previous, a newly played region will be the triggered using the previous region's velocity. For example, if the previous velocity is 100 and the velocity of the new note-on message is 60, the new region will play as if its velocity was 100. Setting this to previous is useful for making certain legato instruments sound smoother and more consistent.","title":"Example"},{"location":"opcodes/sw_vel/#practical-considerations","text":"At least in ARIA, this affects only volume, and using velocity to modulate pitch or filter cutoff will use the current note's velocity regardless of how sw_vel is set. Also in ARIA, sw_vel can work even if sw_previous is not defined. To have sw_vel working in sfz.dll and DropZone and other Cakewalk players, sw_previous need to be defined. Fil_veltrack, pitch_veltrack and other velocity modulation e.g. ampeg_vel2attack, etc, also affected by sw_vel.","title":"Practical Considerations"},{"location":"opcodes/sync_beats/","text":"When sync_beats is specified and after input controls instruct the region to play, the playback will be postponed until the next multiple of the specified value is crossed. Example sync_beats=4 In this example, if note is pressed in beat 2 of current track, note won't be played until beat 4 reaches. This opcode will only work in hosts featuring song position information (vstTimeInfo ppqPos).","title":"Sync beats"},{"location":"opcodes/sync_beats/#example","text":"sync_beats=4 In this example, if note is pressed in beat 2 of current track, note won't be played until beat 4 reaches. This opcode will only work in hosts featuring song position information (vstTimeInfo ppqPos).","title":"Example"},{"location":"opcodes/sync_offset/","text":"When sync_beats is specified and after input controls instruct the region to play, the playback will be postponed until the next multiple of the specified value plus the sync_offset value is crossed. Example sync_beats=4 sync_offset=1 In this example, if note is pressed in beat 2 of current track, note won't be played until beat 5 reaches. This opcode will only work in hosts featuring song position information (vstTimeInfo ppqPos).","title":"Sync offset"},{"location":"opcodes/sync_offset/#example","text":"sync_beats=4 sync_offset=1 In this example, if note is pressed in beat 2 of current track, note won't be played until beat 5 reaches. This opcode will only work in hosts featuring song position information (vstTimeInfo ppqPos).","title":"Example"},{"location":"opcodes/tdfir_dry/","text":"Used under the \u2039effect\u203a header, with type = tdfir .","title":"Tdfir dry"},{"location":"opcodes/tdfir_dry_onccN/","text":"Used under the \u2039effect\u203a header, with type = tdfir .","title":"tdfir dry onccN"},{"location":"opcodes/tdfir_gain/","text":"Used under the \u2039effect\u203a header, with type = tdfir .","title":"Tdfir gain"},{"location":"opcodes/tdfir_impulse/","text":"Used under the \u2039effect\u203a header, with type = tdfir .","title":"Tdfir impulse"},{"location":"opcodes/tdfir_wet/","text":"Used under the \u2039effect\u203a header, with type = tdfir .","title":"Tdfir wet"},{"location":"opcodes/tdfir_wet_onccN/","text":"Used under the \u2039effect\u203a header, with type = tdfir .","title":"tdfir wet onccN"},{"location":"opcodes/transpose/","text":"Examples transpose=3 transpose=-4 transpose=24 Uses include creating layered instruments by transposing samples at different pitches to all play the same note, and (combined with locc and hicc ) octave selection controls in synthesizer-style instruments.","title":"Transpose"},{"location":"opcodes/transpose/#examples","text":"transpose=3 transpose=-4 transpose=24 Uses include creating layered instruments by transposing samples at different pitches to all play the same note, and (combined with locc and hicc ) octave selection controls in synthesizer-style instruments.","title":"Examples"},{"location":"opcodes/trigger/","text":"Values can be: attack : (Default): Region will play on note-on. release : Region will play on note-off or sustain pedal off. The velocity used to play the note-off sample is the velocity value of the corresponding (previous) note-on message. first : Region will play on note-on, but if there's no other note going on (commonly used for or first note in a legato phrase). legato : Region will play on note-on, but only if there's a note going on (notes after first note in a legato phrase). release_key : Region will play on note-off. Ignores sustain pedal. Practical Considerations This entire section is dedicated to release triggers, which can get quite complex. Setting trigger to release or release_key will cause the region to play as if loop_mode was set to one_shot . Beyond that, release region behavior varies considerably between SFZ players. rcg sfz: Both release or release_key regions play whether there is a previous attack region or not. Release_key regions won't play when releasing the sustain pedal. Release samples only play when sustain pedal is up (not depressed). In sfz v1, there is no polyphony or note_polyphony for limiting the number of simultaneous release regions playing, which can result in a very large number of release regions triggered when the sustain pedal is raised. DropZone and other Cakewalk players: Both release or release_key require a previous attack region. Release_key regions won't play when releasing the sustain pedal. Release samples only play when sustain pedal is up (not depressed). To make release or release_key plays without any previous attack region, set rt_dead to on. note_polyphony is now available to control the accumulation of release voices of repeated notes when Sustain pedal is down. ARIA and Sforzando: release requires a previous attack region. release_key doesn't require a previous attack region. release responds to Sustain Pedal position. release_key ignores Sustain Pedal completely. rt_dead is not supported, and defaults to off. note_polyphony is available to control the accumulation of release voices. Release samples can require a corresponding region with trigger set to attack to be active at the moment when the note-off message is received, or the release region will never play. In rgc sfz, this is not required. In DropZone and other Cakewalk players, it is required unless rt_dead is set to on. In ARIA, it is required for trigger=release regions but not for trigger=release_key regions. For cases where a corresponding attack region is required, here is more detail. An attack region is considered corresponding if it has the same MIDI note number, and the same velocity range, as the release region. The velocity which matters here is the note-on velocity of the initial region - not the velocity of the note-off message which triggers the release region. Round robins do not need to match, so it is possible to for example have five round robins for releases and only four round robins for attacks. This corresponding attack region is then used to calculate the volume of the release region based on the attack region's velocity and rt_decay . If there is no corresponding attack region, or the corresponding attack region has finished playing due to reaching sample end etc, then the release region will not play. This is designed primarily designed for piano release samples. Triggering a release sample without a corresponding attack region is is useful for release samples which are noises not dependent on the volume of any corresponding note, such as hurdy-gurdy key returns, which will sound the same whether the wheel is turning or not. Note that at least in ARIA and Sforzando, a note-on event which triggers multiple regions (for example a multimic instrument, or one with simulated unison) will have multiple corresponding regions for the release region, causing the release region to be triggered multiple times. With seven mics and a separate release for each mic, this would mean a key release would trigger a total of 49 samples if not controlled with note_polyphony . However, setting note_polyphony=1 and giving each mic a different [group] number solves this. When using releases with round robins and multiple voices, it can be tricky to make the release sample round robin counter advance correctly. When there are 2 matching regions playing, ARIA appears to advance the counter for the releases by 2, and if there are 4 release round robins, only 2 of them will actually be used. One workaround for that is triggering an extra region of silence to make the round robin counter advance by 3, but this will only work if the number of regions is consistent and predictable. With instruments that have release samples with a number of microphone positions or organ stops, any of which could be on or off, the total number of matching regions is very difficult to assess, and it's far easier to use lorand/hirand to select the release samples instead. on_loccN / on_hiccN effectively replace the default trigger=attack, as it is used for regions which are to be triggered by MIDI CC messages and not MIDI note messages. For regions which use these opcodes, trigger should be left unspecified. Examples trigger=release trigger=legato","title":"Trigger"},{"location":"opcodes/trigger/#practical-considerations","text":"This entire section is dedicated to release triggers, which can get quite complex. Setting trigger to release or release_key will cause the region to play as if loop_mode was set to one_shot . Beyond that, release region behavior varies considerably between SFZ players. rcg sfz: Both release or release_key regions play whether there is a previous attack region or not. Release_key regions won't play when releasing the sustain pedal. Release samples only play when sustain pedal is up (not depressed). In sfz v1, there is no polyphony or note_polyphony for limiting the number of simultaneous release regions playing, which can result in a very large number of release regions triggered when the sustain pedal is raised. DropZone and other Cakewalk players: Both release or release_key require a previous attack region. Release_key regions won't play when releasing the sustain pedal. Release samples only play when sustain pedal is up (not depressed). To make release or release_key plays without any previous attack region, set rt_dead to on. note_polyphony is now available to control the accumulation of release voices of repeated notes when Sustain pedal is down. ARIA and Sforzando: release requires a previous attack region. release_key doesn't require a previous attack region. release responds to Sustain Pedal position. release_key ignores Sustain Pedal completely. rt_dead is not supported, and defaults to off. note_polyphony is available to control the accumulation of release voices. Release samples can require a corresponding region with trigger set to attack to be active at the moment when the note-off message is received, or the release region will never play. In rgc sfz, this is not required. In DropZone and other Cakewalk players, it is required unless rt_dead is set to on. In ARIA, it is required for trigger=release regions but not for trigger=release_key regions. For cases where a corresponding attack region is required, here is more detail. An attack region is considered corresponding if it has the same MIDI note number, and the same velocity range, as the release region. The velocity which matters here is the note-on velocity of the initial region - not the velocity of the note-off message which triggers the release region. Round robins do not need to match, so it is possible to for example have five round robins for releases and only four round robins for attacks. This corresponding attack region is then used to calculate the volume of the release region based on the attack region's velocity and rt_decay . If there is no corresponding attack region, or the corresponding attack region has finished playing due to reaching sample end etc, then the release region will not play. This is designed primarily designed for piano release samples. Triggering a release sample without a corresponding attack region is is useful for release samples which are noises not dependent on the volume of any corresponding note, such as hurdy-gurdy key returns, which will sound the same whether the wheel is turning or not. Note that at least in ARIA and Sforzando, a note-on event which triggers multiple regions (for example a multimic instrument, or one with simulated unison) will have multiple corresponding regions for the release region, causing the release region to be triggered multiple times. With seven mics and a separate release for each mic, this would mean a key release would trigger a total of 49 samples if not controlled with note_polyphony . However, setting note_polyphony=1 and giving each mic a different [group] number solves this. When using releases with round robins and multiple voices, it can be tricky to make the release sample round robin counter advance correctly. When there are 2 matching regions playing, ARIA appears to advance the counter for the releases by 2, and if there are 4 release round robins, only 2 of them will actually be used. One workaround for that is triggering an extra region of silence to make the round robin counter advance by 3, but this will only work if the number of regions is consistent and predictable. With instruments that have release samples with a number of microphone positions or organ stops, any of which could be on or off, the total number of matching regions is very difficult to assess, and it's far easier to use lorand/hirand to select the release samples instead. on_loccN / on_hiccN effectively replace the default trigger=attack, as it is used for regions which are to be triggered by MIDI CC messages and not MIDI note messages. For regions which use these opcodes, trigger should be left unspecified.","title":"Practical Considerations"},{"location":"opcodes/trigger/#examples","text":"trigger=release trigger=legato","title":"Examples"},{"location":"opcodes/tune/","text":"Range of tune in the SFZ1 spec is \u00b11 semitone, from -100 to 100, though at least in ARIA, it seems a broader range is supported, at least -2400 to 2400 cents. Examples tune=33 tune=-30 tune=94 Uses include correcting the intonation of naturally off-pitch samples, and detuning unison voices. Modulating pitch with MIDI CC to create a tune control is possible in SFZ2. If the control needs to go both up and down, there are two ways to do this. One is to move the pitch down by the tuning range, then have modulation move it up by twice the tuning range, so that when the control is at the midpoint, the region will play at its orignal, unmodulated pitch. For a range of 100 cents this would look like this: tune=-100 pitch_oncc27=200 Another way is to use default \u2039curve\u203a 1 which ranges from -1 to 1, and set the pitch control to the tuning range. pitch_oncc27=100 pitch_curvecc27=1 Practical Considerations In ARIA, tune_*ccN can also be used as an alias for pitch_*ccN (see below).","title":"tune / pitch"},{"location":"opcodes/tune/#examples","text":"tune=33 tune=-30 tune=94 Uses include correcting the intonation of naturally off-pitch samples, and detuning unison voices. Modulating pitch with MIDI CC to create a tune control is possible in SFZ2. If the control needs to go both up and down, there are two ways to do this. One is to move the pitch down by the tuning range, then have modulation move it up by twice the tuning range, so that when the control is at the midpoint, the region will play at its orignal, unmodulated pitch. For a range of 100 cents this would look like this: tune=-100 pitch_oncc27=200 Another way is to use default \u2039curve\u203a 1 which ranges from -1 to 1, and set the pitch control to the tuning range. pitch_oncc27=100 pitch_curvecc27=1","title":"Examples"},{"location":"opcodes/tune/#practical-considerations","text":"In ARIA, tune_*ccN can also be used as an alias for pitch_*ccN (see below).","title":"Practical Considerations"},{"location":"opcodes/tune_ccN/","text":"Range of tune in the SFZ1 spec is \u00b11 semitone, from -100 to 100, though at least in ARIA, it seems a broader range is supported, at least -2400 to 2400 cents. Examples tune=33 tune=-30 tune=94 Uses include correcting the intonation of naturally off-pitch samples, and detuning unison voices. Modulating pitch with MIDI CC to create a tune control is possible in SFZ2. If the control needs to go both up and down, there are two ways to do this. One is to move the pitch down by the tuning range, then have modulation move it up by twice the tuning range, so that when the control is at the midpoint, the region will play at its orignal, unmodulated pitch. For a range of 100 cents this would look like this: tune=-100 pitch_oncc27=200 Another way is to use default \u2039curve\u203a 1 which ranges from -1 to 1, and set the pitch control to the tuning range. pitch_oncc27=100 pitch_curvecc27=1 Practical Considerations In ARIA, tune_*ccN can also be used as an alias for pitch_*ccN (see below).","title":"tune / pitch"},{"location":"opcodes/tune_ccN/#examples","text":"tune=33 tune=-30 tune=94 Uses include correcting the intonation of naturally off-pitch samples, and detuning unison voices. Modulating pitch with MIDI CC to create a tune control is possible in SFZ2. If the control needs to go both up and down, there are two ways to do this. One is to move the pitch down by the tuning range, then have modulation move it up by twice the tuning range, so that when the control is at the midpoint, the region will play at its orignal, unmodulated pitch. For a range of 100 cents this would look like this: tune=-100 pitch_oncc27=200 Another way is to use default \u2039curve\u203a 1 which ranges from -1 to 1, and set the pitch control to the tuning range. pitch_oncc27=100 pitch_curvecc27=1","title":"Examples"},{"location":"opcodes/tune_ccN/#practical-considerations","text":"In ARIA, tune_*ccN can also be used as an alias for pitch_*ccN (see below).","title":"Practical Considerations"},{"location":"opcodes/tune_curveccN/","text":"Range of tune in the SFZ1 spec is \u00b11 semitone, from -100 to 100, though at least in ARIA, it seems a broader range is supported, at least -2400 to 2400 cents. Examples tune=33 tune=-30 tune=94 Uses include correcting the intonation of naturally off-pitch samples, and detuning unison voices. Modulating pitch with MIDI CC to create a tune control is possible in SFZ2. If the control needs to go both up and down, there are two ways to do this. One is to move the pitch down by the tuning range, then have modulation move it up by twice the tuning range, so that when the control is at the midpoint, the region will play at its orignal, unmodulated pitch. For a range of 100 cents this would look like this: tune=-100 pitch_oncc27=200 Another way is to use default \u2039curve\u203a 1 which ranges from -1 to 1, and set the pitch control to the tuning range. pitch_oncc27=100 pitch_curvecc27=1 Practical Considerations In ARIA, tune_*ccN can also be used as an alias for pitch_*ccN (see below).","title":"tune / pitch"},{"location":"opcodes/tune_curveccN/#examples","text":"tune=33 tune=-30 tune=94 Uses include correcting the intonation of naturally off-pitch samples, and detuning unison voices. Modulating pitch with MIDI CC to create a tune control is possible in SFZ2. If the control needs to go both up and down, there are two ways to do this. One is to move the pitch down by the tuning range, then have modulation move it up by twice the tuning range, so that when the control is at the midpoint, the region will play at its orignal, unmodulated pitch. For a range of 100 cents this would look like this: tune=-100 pitch_oncc27=200 Another way is to use default \u2039curve\u203a 1 which ranges from -1 to 1, and set the pitch control to the tuning range. pitch_oncc27=100 pitch_curvecc27=1","title":"Examples"},{"location":"opcodes/tune_curveccN/#practical-considerations","text":"In ARIA, tune_*ccN can also be used as an alias for pitch_*ccN (see below).","title":"Practical Considerations"},{"location":"opcodes/tune_keytrack/","text":"Default value is 100, which means pitch will change one hundred cents (one semitone) per played note. Setting this value to zero means that all notes in the region will play the same pitch, particularly useful when mapping drum sounds. Examples pitch_keytrack=20 pitch_keytrack=0 Most of the time, this will either be 100 (default) or 0, but intermediate values, values above 100 or negative values are occasionally useful.","title":"Tune keytrack"},{"location":"opcodes/tune_keytrack/#examples","text":"pitch_keytrack=20 pitch_keytrack=0 Most of the time, this will either be 100 (default) or 0, but intermediate values, values above 100 or negative values are occasionally useful.","title":"Examples"},{"location":"opcodes/tune_onccN/","text":"Range of tune in the SFZ1 spec is \u00b11 semitone, from -100 to 100, though at least in ARIA, it seems a broader range is supported, at least -2400 to 2400 cents. Examples tune=33 tune=-30 tune=94 Uses include correcting the intonation of naturally off-pitch samples, and detuning unison voices. Modulating pitch with MIDI CC to create a tune control is possible in SFZ2. If the control needs to go both up and down, there are two ways to do this. One is to move the pitch down by the tuning range, then have modulation move it up by twice the tuning range, so that when the control is at the midpoint, the region will play at its orignal, unmodulated pitch. For a range of 100 cents this would look like this: tune=-100 pitch_oncc27=200 Another way is to use default \u2039curve\u203a 1 which ranges from -1 to 1, and set the pitch control to the tuning range. pitch_oncc27=100 pitch_curvecc27=1 Practical Considerations In ARIA, tune_*ccN can also be used as an alias for pitch_*ccN (see below).","title":"tune / pitch"},{"location":"opcodes/tune_onccN/#examples","text":"tune=33 tune=-30 tune=94 Uses include correcting the intonation of naturally off-pitch samples, and detuning unison voices. Modulating pitch with MIDI CC to create a tune control is possible in SFZ2. If the control needs to go both up and down, there are two ways to do this. One is to move the pitch down by the tuning range, then have modulation move it up by twice the tuning range, so that when the control is at the midpoint, the region will play at its orignal, unmodulated pitch. For a range of 100 cents this would look like this: tune=-100 pitch_oncc27=200 Another way is to use default \u2039curve\u203a 1 which ranges from -1 to 1, and set the pitch control to the tuning range. pitch_oncc27=100 pitch_curvecc27=1","title":"Examples"},{"location":"opcodes/tune_onccN/#practical-considerations","text":"In ARIA, tune_*ccN can also be used as an alias for pitch_*ccN (see below).","title":"Practical Considerations"},{"location":"opcodes/tune_random/","text":"Examples Computed when the note is triggered, remains the same for that region for as long as the region plays. pitch_random=10 pitch_random=400 Useful for humanizing the pitch of instruments with naturally imprecise intonation, especially when playing multiple regions in unison. Practical Considerations In ARIA this is unipolar, and equivalent to pitch_oncc135 . So, if pitch_random is set to 20, the region will play at pitches tuned by an amount in the range from 0 cents to +20 cents. In order to get pitch to fluctuate between -20 and +20 cents, there would be two ways to get there, either by applying a fixed shift of -20 cents and a random shift of up to 40 cents: pitch=-20 pitch_random=40 Or use CC136, which is bipolar random from -1 to 1: pitch_oncc136=20 In rcg sfz and Cakewalk, this is bipolar.","title":"Tune random"},{"location":"opcodes/tune_random/#examples","text":"Computed when the note is triggered, remains the same for that region for as long as the region plays. pitch_random=10 pitch_random=400 Useful for humanizing the pitch of instruments with naturally imprecise intonation, especially when playing multiple regions in unison.","title":"Examples"},{"location":"opcodes/tune_random/#practical-considerations","text":"In ARIA this is unipolar, and equivalent to pitch_oncc135 . So, if pitch_random is set to 20, the region will play at pitches tuned by an amount in the range from 0 cents to +20 cents. In order to get pitch to fluctuate between -20 and +20 cents, there would be two ways to get there, either by applying a fixed shift of -20 cents and a random shift of up to 40 cents: pitch=-20 pitch_random=40 Or use CC136, which is bipolar random from -1 to 1: pitch_oncc136=20 In rcg sfz and Cakewalk, this is bipolar.","title":"Practical Considerations"},{"location":"opcodes/tune_smoothccN/","text":"Range of tune in the SFZ1 spec is \u00b11 semitone, from -100 to 100, though at least in ARIA, it seems a broader range is supported, at least -2400 to 2400 cents. Examples tune=33 tune=-30 tune=94 Uses include correcting the intonation of naturally off-pitch samples, and detuning unison voices. Modulating pitch with MIDI CC to create a tune control is possible in SFZ2. If the control needs to go both up and down, there are two ways to do this. One is to move the pitch down by the tuning range, then have modulation move it up by twice the tuning range, so that when the control is at the midpoint, the region will play at its orignal, unmodulated pitch. For a range of 100 cents this would look like this: tune=-100 pitch_oncc27=200 Another way is to use default \u2039curve\u203a 1 which ranges from -1 to 1, and set the pitch control to the tuning range. pitch_oncc27=100 pitch_curvecc27=1 Practical Considerations In ARIA, tune_*ccN can also be used as an alias for pitch_*ccN (see below).","title":"tune / pitch"},{"location":"opcodes/tune_smoothccN/#examples","text":"tune=33 tune=-30 tune=94 Uses include correcting the intonation of naturally off-pitch samples, and detuning unison voices. Modulating pitch with MIDI CC to create a tune control is possible in SFZ2. If the control needs to go both up and down, there are two ways to do this. One is to move the pitch down by the tuning range, then have modulation move it up by twice the tuning range, so that when the control is at the midpoint, the region will play at its orignal, unmodulated pitch. For a range of 100 cents this would look like this: tune=-100 pitch_oncc27=200 Another way is to use default \u2039curve\u203a 1 which ranges from -1 to 1, and set the pitch control to the tuning range. pitch_oncc27=100 pitch_curvecc27=1","title":"Examples"},{"location":"opcodes/tune_smoothccN/#practical-considerations","text":"In ARIA, tune_*ccN can also be used as an alias for pitch_*ccN (see below).","title":"Practical Considerations"},{"location":"opcodes/tune_stepccN/","text":"Range of tune in the SFZ1 spec is \u00b11 semitone, from -100 to 100, though at least in ARIA, it seems a broader range is supported, at least -2400 to 2400 cents. Examples tune=33 tune=-30 tune=94 Uses include correcting the intonation of naturally off-pitch samples, and detuning unison voices. Modulating pitch with MIDI CC to create a tune control is possible in SFZ2. If the control needs to go both up and down, there are two ways to do this. One is to move the pitch down by the tuning range, then have modulation move it up by twice the tuning range, so that when the control is at the midpoint, the region will play at its orignal, unmodulated pitch. For a range of 100 cents this would look like this: tune=-100 pitch_oncc27=200 Another way is to use default \u2039curve\u203a 1 which ranges from -1 to 1, and set the pitch control to the tuning range. pitch_oncc27=100 pitch_curvecc27=1 Practical Considerations In ARIA, tune_*ccN can also be used as an alias for pitch_*ccN (see below).","title":"tune / pitch"},{"location":"opcodes/tune_stepccN/#examples","text":"tune=33 tune=-30 tune=94 Uses include correcting the intonation of naturally off-pitch samples, and detuning unison voices. Modulating pitch with MIDI CC to create a tune control is possible in SFZ2. If the control needs to go both up and down, there are two ways to do this. One is to move the pitch down by the tuning range, then have modulation move it up by twice the tuning range, so that when the control is at the midpoint, the region will play at its orignal, unmodulated pitch. For a range of 100 cents this would look like this: tune=-100 pitch_oncc27=200 Another way is to use default \u2039curve\u203a 1 which ranges from -1 to 1, and set the pitch control to the tuning range. pitch_oncc27=100 pitch_curvecc27=1","title":"Examples"},{"location":"opcodes/tune_stepccN/#practical-considerations","text":"In ARIA, tune_*ccN can also be used as an alias for pitch_*ccN (see below).","title":"Practical Considerations"},{"location":"opcodes/tune_veltrack/","text":"Examples pitch_veltrack=0 pitch_veltrack=1200 This can be useful when trying to emulate dynamic response on drum samples recorded at only one velocity.","title":"Tune veltrack"},{"location":"opcodes/tune_veltrack/#examples","text":"pitch_veltrack=0 pitch_veltrack=1200 This can be useful when trying to emulate dynamic response on drum samples recorded at only one velocity.","title":"Examples"},{"location":"opcodes/type/","text":"ARIA Extensions In the PC version of ARIA, the MDA effects are bundled. That means that under the \u2039effect\u203a header, any of these effect types can be set. com.mda.Limiter com.mda.Overdrive com.mda.Leslie com.mda.RingMod com.mda.Delay com.mda.Bandisto com.mda.Ambience com.mda.DubDelay com.mda.Detune com.mda.Dither com.mda.Combo com.mda.Degrade com.mda.SubSynth com.mda.RezFilter Also see param_offset for how to configure the parameters for these effects in ARIA. The order of the parameters is the same as at the plugin version of the MDA effects . These effects are not part of the SFZ engine, so it is not possible to, for example, have one MIDI CC parameter control two parameters in the same effect, or use custom curves . Example usage below: <control> set_cc300=64 set_cc301=127 <effect> param_offset=300 type=com.mda.Overdrive Cakewalk implementation In Cakewalk, each of the effect types has its own set of opcodes controlling its parameters. Here is a list of what is currently known. The effect routing logic in Rapture is as follows: apan Automatic panning with LFO: apan_depth apan_dry apan_freq apan_phase apan_waveform apan_wet comp Compressor: comp_attack comp_gain comp_ratio comp_release comp_stlink comp_threshold delay Multi-purpose delay line: delay_cutoff delay_damphi delay_damplo delay_dry delay_feedback delay_filter delay_input delay_levelc delay_levell delay_levelr delay_lfofreq delay_moddepth delay_mode delay_panc delay_panl delay_panr delay_resonance delay_spread delay_syncc_onccN delay_syncl_onccN delay_syncr_onccN delay_time_tap delay_timec delay_timel delay_timer delay_wet disto Asymmetric distorsion with tone control: disto_depth disto_dry disto_stages disto_tone disto_wet eq Equalizer (Same opcode meanings as ordinary EQ): eq_bw eq_freq eq_gain eq_type filter (Same opcode meanings as ordinary filter): filter_cutoff filter_resonance filter_type fverb Algorithmic reverberation: reverb_damp reverb_dry reverb_input reverb_predelay reverb_size reverb_tone reverb_type reverb_wet gate Signal gate: gate_onccN gate_attack gate_release gate_stlink gate_threshold limiter No opcodes for this type. lofi Bit depth reducer and decimator combined: bitred decim mverb Present in some Cakewalk products only, undocumented. phaser Dual-notch phaser with LFO: phaser_depth phaser_feedback phaser_freq phaser_phase_onccN phaser_stages phaser_waveform phaser_wet static Static noise generator: static_cyclic_level static_cyclic_time static_filter static_level static_random_level static_random_maxtime static_random_mintime static_stereo static_tone strings Sympathetic resonance with waveguide synthesis: strings_number strings_wet_onccN tdfir Impulse response convolver: tdfir_dry tdfir_gain tdfir_impulse tdfir_wet Note that the Cakewalk book has some typos in opcode names, such as EffectN (capital letter) or \u2039effects\u203a . On this site, non-working effect types mentioned in the book were replaced with tested ones. For example, autopan does not appear to work in any Cakewalk product, while apan works. Same for lofi instead bitred and decim , and disto instead of distortion .","title":"Type"},{"location":"opcodes/type/#aria-extensions","text":"In the PC version of ARIA, the MDA effects are bundled. That means that under the \u2039effect\u203a header, any of these effect types can be set. com.mda.Limiter com.mda.Overdrive com.mda.Leslie com.mda.RingMod com.mda.Delay com.mda.Bandisto com.mda.Ambience com.mda.DubDelay com.mda.Detune com.mda.Dither com.mda.Combo com.mda.Degrade com.mda.SubSynth com.mda.RezFilter Also see param_offset for how to configure the parameters for these effects in ARIA. The order of the parameters is the same as at the plugin version of the MDA effects . These effects are not part of the SFZ engine, so it is not possible to, for example, have one MIDI CC parameter control two parameters in the same effect, or use custom curves . Example usage below: <control> set_cc300=64 set_cc301=127 <effect> param_offset=300 type=com.mda.Overdrive","title":"ARIA Extensions"},{"location":"opcodes/type/#cakewalk-implementation","text":"In Cakewalk, each of the effect types has its own set of opcodes controlling its parameters. Here is a list of what is currently known. The effect routing logic in Rapture is as follows:","title":"Cakewalk implementation"},{"location":"opcodes/type/#apan","text":"Automatic panning with LFO: apan_depth apan_dry apan_freq apan_phase apan_waveform apan_wet","title":"apan"},{"location":"opcodes/type/#comp","text":"Compressor: comp_attack comp_gain comp_ratio comp_release comp_stlink comp_threshold","title":"comp"},{"location":"opcodes/type/#delay","text":"Multi-purpose delay line: delay_cutoff delay_damphi delay_damplo delay_dry delay_feedback delay_filter delay_input delay_levelc delay_levell delay_levelr delay_lfofreq delay_moddepth delay_mode delay_panc delay_panl delay_panr delay_resonance delay_spread delay_syncc_onccN delay_syncl_onccN delay_syncr_onccN delay_time_tap delay_timec delay_timel delay_timer delay_wet","title":"delay"},{"location":"opcodes/type/#disto","text":"Asymmetric distorsion with tone control: disto_depth disto_dry disto_stages disto_tone disto_wet","title":"disto"},{"location":"opcodes/type/#eq","text":"Equalizer (Same opcode meanings as ordinary EQ): eq_bw eq_freq eq_gain eq_type","title":"eq"},{"location":"opcodes/type/#filter","text":"(Same opcode meanings as ordinary filter): filter_cutoff filter_resonance filter_type","title":"filter"},{"location":"opcodes/type/#fverb","text":"Algorithmic reverberation: reverb_damp reverb_dry reverb_input reverb_predelay reverb_size reverb_tone reverb_type reverb_wet","title":"fverb"},{"location":"opcodes/type/#gate","text":"Signal gate: gate_onccN gate_attack gate_release gate_stlink gate_threshold","title":"gate"},{"location":"opcodes/type/#limiter","text":"No opcodes for this type.","title":"limiter"},{"location":"opcodes/type/#lofi","text":"Bit depth reducer and decimator combined: bitred decim","title":"lofi"},{"location":"opcodes/type/#mverb","text":"Present in some Cakewalk products only, undocumented.","title":"mverb"},{"location":"opcodes/type/#phaser","text":"Dual-notch phaser with LFO: phaser_depth phaser_feedback phaser_freq phaser_phase_onccN phaser_stages phaser_waveform phaser_wet","title":"phaser"},{"location":"opcodes/type/#static","text":"Static noise generator: static_cyclic_level static_cyclic_time static_filter static_level static_random_level static_random_maxtime static_random_mintime static_stereo static_tone","title":"static"},{"location":"opcodes/type/#strings","text":"Sympathetic resonance with waveguide synthesis: strings_number strings_wet_onccN","title":"strings"},{"location":"opcodes/type/#tdfir","text":"Impulse response convolver: tdfir_dry tdfir_gain tdfir_impulse tdfir_wet Note that the Cakewalk book has some typos in opcode names, such as EffectN (capital letter) or \u2039effects\u203a . On this site, non-working effect types mentioned in the book were replaced with tested ones. For example, autopan does not appear to work in any Cakewalk product, while apan works. Same for lofi instead bitred and decim , and disto instead of distortion .","title":"tdfir"},{"location":"opcodes/vN/","text":"One curve header is used to define each curve. The values for various points along the curve can then be set, from v000 to v127 . The default is v000=0 and v127=1 . Any points along the curve not defined explicitly will be interpolated linearly between points which are defined. There are default built-in curves in ARIA. If no curve is specified for a modulation, curve 0 is used. The built-in ARIA curves are: Default curve (number 0). linear, from 0 to 1 1. bipolar, from -1 to 1 (useful for things such as tuning and panning, used by CC10 panning by default) 2. linear inverted, from 1 to 0 3. bipolar inverted, from 1 to -1 4. concave (used for CC7 volume tracking and amp_veltrack) 5. Xfin power curve 6. Xfout power curve These can be overwritten, but as they are used by the engine for their normal functions, it's safer to use curve_index numbers of 7 and above for custom curves. Curve_index in ARIA can be any integer from 0 to 255. Examples <curve>curve_index=17 v000=0 v095=1 v127=1 <curve>curve_index=18 v000=0 v095=0.5 v127=1 Here's a scenario using one MIDI CC to control the amplitude of two samples along two different curves. <region> amplitude_oncc110=100 amplitude_curvecc110=9 sample=bigger.wav <region> amplitude_oncc110=100 amplitude_curvecc110=10 sample=smaller.wav //The curves for the room ambiences - bigger room first <curve>curve_index=9 v000=0 v063=0 v127=1 <curve>curve_index=10 v000=0 v063=1 v127=0.1 And how to use the default curve 1 to create a tuning control which goes down and up, with the pitch unmodulated when the control is in the middle. pitch_oncc27=100 pitch_curvecc27=1","title":"\u2039curve\u203a"},{"location":"opcodes/vN/#examples","text":"<curve>curve_index=17 v000=0 v095=1 v127=1 <curve>curve_index=18 v000=0 v095=0.5 v127=1 Here's a scenario using one MIDI CC to control the amplitude of two samples along two different curves. <region> amplitude_oncc110=100 amplitude_curvecc110=9 sample=bigger.wav <region> amplitude_oncc110=100 amplitude_curvecc110=10 sample=smaller.wav //The curves for the room ambiences - bigger room first <curve>curve_index=9 v000=0 v063=0 v127=1 <curve>curve_index=10 v000=0 v063=1 v127=0.1 And how to use the default curve 1 to create a tuning control which goes down and up, with the pitch unmodulated when the control is in the middle. pitch_oncc27=100 pitch_curvecc27=1","title":"Examples"},{"location":"opcodes/vNNN/","text":"One curve header is used to define each curve. The values for various points along the curve can then be set, from v000 to v127 . The default is v000=0 and v127=1 . Any points along the curve not defined explicitly will be interpolated linearly between points which are defined. There are default built-in curves in ARIA. If no curve is specified for a modulation, curve 0 is used. The built-in ARIA curves are: Default curve (number 0). linear, from 0 to 1 1. bipolar, from -1 to 1 (useful for things such as tuning and panning, used by CC10 panning by default) 2. linear inverted, from 1 to 0 3. bipolar inverted, from 1 to -1 4. concave (used for CC7 volume tracking and amp_veltrack) 5. Xfin power curve 6. Xfout power curve These can be overwritten, but as they are used by the engine for their normal functions, it's safer to use curve_index numbers of 7 and above for custom curves. Curve_index in ARIA can be any integer from 0 to 255. Examples <curve>curve_index=17 v000=0 v095=1 v127=1 <curve>curve_index=18 v000=0 v095=0.5 v127=1 Here's a scenario using one MIDI CC to control the amplitude of two samples along two different curves. <region> amplitude_oncc110=100 amplitude_curvecc110=9 sample=bigger.wav <region> amplitude_oncc110=100 amplitude_curvecc110=10 sample=smaller.wav //The curves for the room ambiences - bigger room first <curve>curve_index=9 v000=0 v063=0 v127=1 <curve>curve_index=10 v000=0 v063=1 v127=0.1 And how to use the default curve 1 to create a tuning control which goes down and up, with the pitch unmodulated when the control is in the middle. pitch_oncc27=100 pitch_curvecc27=1","title":"\u2039curve\u203a"},{"location":"opcodes/vNNN/#examples","text":"<curve>curve_index=17 v000=0 v095=1 v127=1 <curve>curve_index=18 v000=0 v095=0.5 v127=1 Here's a scenario using one MIDI CC to control the amplitude of two samples along two different curves. <region> amplitude_oncc110=100 amplitude_curvecc110=9 sample=bigger.wav <region> amplitude_oncc110=100 amplitude_curvecc110=10 sample=smaller.wav //The curves for the room ambiences - bigger room first <curve>curve_index=9 v000=0 v063=0 v127=1 <curve>curve_index=10 v000=0 v063=1 v127=0.1 And how to use the default curve 1 to create a tuning control which goes down and up, with the pitch unmodulated when the control is in the middle. pitch_oncc27=100 pitch_curvecc27=1","title":"Examples"},{"location":"opcodes/varNN_/","text":"Example var01_cutoff=4800 var02_pitch=400 Here is how this could be used, together with varNN_mod and varNN_onccX to control velocity tracking on a filter cutoff: //Lowpass filter cutoff=120 cutoff_cc102=8400 fil_keytrack=100 resonance=0 resonance_cc103=24 var01_cutoff=4800 //Velocity track var01_mod=mult var01_oncc131=1 var01_oncc111=1 Available targets The list of possible modulation targets is basically the same standard list as for LFOs or envelopes, though variables can't modulate other modulators, so it's not currently possible to use a variable to modulate an LFO, or to modulate another variable. This list has not been verified by testing. It was created by cutting down the list of available targets for modulation by LFO. Decim and bitred might not actually be implemented.","title":"varNN "},{"location":"opcodes/varNN_/#example","text":"var01_cutoff=4800 var02_pitch=400 Here is how this could be used, together with varNN_mod and varNN_onccX to control velocity tracking on a filter cutoff: //Lowpass filter cutoff=120 cutoff_cc102=8400 fil_keytrack=100 resonance=0 resonance_cc103=24 var01_cutoff=4800 //Velocity track var01_mod=mult var01_oncc131=1 var01_oncc111=1","title":"Example"},{"location":"opcodes/varNN_/#available-targets","text":"The list of possible modulation targets is basically the same standard list as for LFOs or envelopes, though variables can't modulate other modulators, so it's not currently possible to use a variable to modulate an LFO, or to modulate another variable. This list has not been verified by testing. It was created by cutting down the list of available targets for modulation by LFO. Decim and bitred might not actually be implemented.","title":"Available targets"},{"location":"opcodes/varNN_curveccX/","text":"mult : multiplication, with 1 being full scale - 0 at a CC value of 0, and 1 at CC value of 127. This is how the amplitude opcode works. add : addition, how volume , cutoff and all other modulation destinations work by default when modulated. Example var01_mod=mult var02_mod=add Here is how multiplication could be used, together with varNN_* (in this case, var01_cutoff as 01 is the variable number and cutoff is the target) and varNN_onccX to control velocity tracking on a filter cutoff: //Lowpass filter cutoff=120 cutoff_cc102=8400 fil_keytrack=100 resonance=0 resonance_cc103=24 var01_cutoff=4800 //Velocity track var01_mod=mult var01_oncc131=1 var01_oncc111=1","title":"varNN curveccX"},{"location":"opcodes/varNN_curveccX/#example","text":"var01_mod=mult var02_mod=add Here is how multiplication could be used, together with varNN_* (in this case, var01_cutoff as 01 is the variable number and cutoff is the target) and varNN_onccX to control velocity tracking on a filter cutoff: //Lowpass filter cutoff=120 cutoff_cc102=8400 fil_keytrack=100 resonance=0 resonance_cc103=24 var01_cutoff=4800 //Velocity track var01_mod=mult var01_oncc131=1 var01_oncc111=1","title":"Example"},{"location":"opcodes/varNN_mod/","text":"mult : multiplication, with 1 being full scale - 0 at a CC value of 0, and 1 at CC value of 127. This is how the amplitude opcode works. add : addition, how volume , cutoff and all other modulation destinations work by default when modulated. Example var01_mod=mult var02_mod=add Here is how multiplication could be used, together with varNN_* (in this case, var01_cutoff as 01 is the variable number and cutoff is the target) and varNN_onccX to control velocity tracking on a filter cutoff: //Lowpass filter cutoff=120 cutoff_cc102=8400 fil_keytrack=100 resonance=0 resonance_cc103=24 var01_cutoff=4800 //Velocity track var01_mod=mult var01_oncc131=1 var01_oncc111=1","title":"varNN mod"},{"location":"opcodes/varNN_mod/#example","text":"var01_mod=mult var02_mod=add Here is how multiplication could be used, together with varNN_* (in this case, var01_cutoff as 01 is the variable number and cutoff is the target) and varNN_onccX to control velocity tracking on a filter cutoff: //Lowpass filter cutoff=120 cutoff_cc102=8400 fil_keytrack=100 resonance=0 resonance_cc103=24 var01_cutoff=4800 //Velocity track var01_mod=mult var01_oncc131=1 var01_oncc111=1","title":"Example"},{"location":"opcodes/varNN_onccX/","text":"mult : multiplication, with 1 being full scale - 0 at a CC value of 0, and 1 at CC value of 127. This is how the amplitude opcode works. add : addition, how volume , cutoff and all other modulation destinations work by default when modulated. Example var01_mod=mult var02_mod=add Here is how multiplication could be used, together with varNN_* (in this case, var01_cutoff as 01 is the variable number and cutoff is the target) and varNN_onccX to control velocity tracking on a filter cutoff: //Lowpass filter cutoff=120 cutoff_cc102=8400 fil_keytrack=100 resonance=0 resonance_cc103=24 var01_cutoff=4800 //Velocity track var01_mod=mult var01_oncc131=1 var01_oncc111=1","title":"varNN onccX"},{"location":"opcodes/varNN_onccX/#example","text":"var01_mod=mult var02_mod=add Here is how multiplication could be used, together with varNN_* (in this case, var01_cutoff as 01 is the variable number and cutoff is the target) and varNN_onccX to control velocity tracking on a filter cutoff: //Lowpass filter cutoff=120 cutoff_cc102=8400 fil_keytrack=100 resonance=0 resonance_cc103=24 var01_cutoff=4800 //Velocity track var01_mod=mult var01_oncc131=1 var01_oncc111=1","title":"Example"},{"location":"opcodes/vendor_specific/","text":"","title":"Vendor specific"},{"location":"opcodes/volume/","text":"Range is -144.6 to 6 in the specification, but many SFZ players can utilize values above 6. Sfz.dll, Rapture and Dimension have a +24 dB maximum, and ARIA has an upper limit of at least +144, perhaps even more. Examples volume=-24 volume=0 volume=3.5 gain_cc1=12 This will play the sample at unchanged volume when CC1 is at 0, and apply a 12 dB boost when CC1 is at maximum. gain_ccN / volume_onccN is useful for creating volume controls. In Aria, either gain or volume can be used in modulations; however, gain by itself (for example gain=5) is not valid. For a fixed volume change wihtout modulation, only volume works.","title":"Volume"},{"location":"opcodes/volume/#examples","text":"volume=-24 volume=0 volume=3.5 gain_cc1=12 This will play the sample at unchanged volume when CC1 is at 0, and apply a 12 dB boost when CC1 is at maximum. gain_ccN / volume_onccN is useful for creating volume controls. In Aria, either gain or volume can be used in modulations; however, gain by itself (for example gain=5) is not valid. For a fixed volume change wihtout modulation, only volume works.","title":"Examples"},{"location":"opcodes/volume_curveccN/","text":"Range is -144.6 to 6 in the specification, but many SFZ players can utilize values above 6. Sfz.dll, Rapture and Dimension have a +24 dB maximum, and ARIA has an upper limit of at least +144, perhaps even more. Examples volume=-24 volume=0 volume=3.5 gain_cc1=12 This will play the sample at unchanged volume when CC1 is at 0, and apply a 12 dB boost when CC1 is at maximum. gain_ccN / volume_onccN is useful for creating volume controls. In Aria, either gain or volume can be used in modulations; however, gain by itself (for example gain=5) is not valid. For a fixed volume change wihtout modulation, only volume works.","title":"volume curveccN"},{"location":"opcodes/volume_curveccN/#examples","text":"volume=-24 volume=0 volume=3.5 gain_cc1=12 This will play the sample at unchanged volume when CC1 is at 0, and apply a 12 dB boost when CC1 is at maximum. gain_ccN / volume_onccN is useful for creating volume controls. In Aria, either gain or volume can be used in modulations; however, gain by itself (for example gain=5) is not valid. For a fixed volume change wihtout modulation, only volume works.","title":"Examples"},{"location":"opcodes/volume_onccN/","text":"Range is -144.6 to 6 in the specification, but many SFZ players can utilize values above 6. Sfz.dll, Rapture and Dimension have a +24 dB maximum, and ARIA has an upper limit of at least +144, perhaps even more. Examples volume=-24 volume=0 volume=3.5 gain_cc1=12 This will play the sample at unchanged volume when CC1 is at 0, and apply a 12 dB boost when CC1 is at maximum. gain_ccN / volume_onccN is useful for creating volume controls. In Aria, either gain or volume can be used in modulations; however, gain by itself (for example gain=5) is not valid. For a fixed volume change wihtout modulation, only volume works.","title":"volume onccN"},{"location":"opcodes/volume_onccN/#examples","text":"volume=-24 volume=0 volume=3.5 gain_cc1=12 This will play the sample at unchanged volume when CC1 is at 0, and apply a 12 dB boost when CC1 is at maximum. gain_ccN / volume_onccN is useful for creating volume controls. In Aria, either gain or volume can be used in modulations; however, gain by itself (for example gain=5) is not valid. For a fixed volume change wihtout modulation, only volume works.","title":"Examples"},{"location":"opcodes/volume_smoothccN/","text":"Range is -144.6 to 6 in the specification, but many SFZ players can utilize values above 6. Sfz.dll, Rapture and Dimension have a +24 dB maximum, and ARIA has an upper limit of at least +144, perhaps even more. Examples volume=-24 volume=0 volume=3.5 gain_cc1=12 This will play the sample at unchanged volume when CC1 is at 0, and apply a 12 dB boost when CC1 is at maximum. gain_ccN / volume_onccN is useful for creating volume controls. In Aria, either gain or volume can be used in modulations; however, gain by itself (for example gain=5) is not valid. For a fixed volume change wihtout modulation, only volume works.","title":"volume smoothccN"},{"location":"opcodes/volume_smoothccN/#examples","text":"volume=-24 volume=0 volume=3.5 gain_cc1=12 This will play the sample at unchanged volume when CC1 is at 0, and apply a 12 dB boost when CC1 is at maximum. gain_ccN / volume_onccN is useful for creating volume controls. In Aria, either gain or volume can be used in modulations; however, gain by itself (for example gain=5) is not valid. For a fixed volume change wihtout modulation, only volume works.","title":"Examples"},{"location":"opcodes/volume_stepccN/","text":"Range is -144.6 to 6 in the specification, but many SFZ players can utilize values above 6. Sfz.dll, Rapture and Dimension have a +24 dB maximum, and ARIA has an upper limit of at least +144, perhaps even more. Examples volume=-24 volume=0 volume=3.5 gain_cc1=12 This will play the sample at unchanged volume when CC1 is at 0, and apply a 12 dB boost when CC1 is at maximum. gain_ccN / volume_onccN is useful for creating volume controls. In Aria, either gain or volume can be used in modulations; however, gain by itself (for example gain=5) is not valid. For a fixed volume change wihtout modulation, only volume works.","title":"volume stepccN"},{"location":"opcodes/volume_stepccN/#examples","text":"volume=-24 volume=0 volume=3.5 gain_cc1=12 This will play the sample at unchanged volume when CC1 is at 0, and apply a 12 dB boost when CC1 is at maximum. gain_ccN / volume_onccN is useful for creating volume controls. In Aria, either gain or volume can be used in modulations; however, gain by itself (for example gain=5) is not valid. For a fixed volume change wihtout modulation, only volume works.","title":"Examples"},{"location":"opcodes/waveguide/","text":"Not properly documented, but apparently supported in Dimension Pro, Rapture, and the Cakewalk sfz player at some point. Example waveguide=on","title":"Waveguide"},{"location":"opcodes/waveguide/#example","text":"waveguide=on","title":"Example"},{"location":"opcodes/width/","text":"A width value of 0 makes a stereo sample play as if it were mono (adding both channels and compensating for the resulting volume change). A value of 100 will make the stereo sample play as original. Any value in between will mix left and right channels with a part of the other, resulting in a narrower stereo field image. Negative width values will reverse left and right channels. Note: Range in the table is specified as -100 to 100. Some players, such as Aria/Sforzando, do not clamp the range. Values over 100 expand the stereo width. For example, for a mono signal panned 6dB to the left, a value of 200 produces the mono signal panned 12dB to the left. Examples width=100 // stereo width=0 // play this stereo sample as mono width=50 // mix 50% of one channel with the other","title":"Width"},{"location":"opcodes/width/#examples","text":"width=100 // stereo width=0 // play this stereo sample as mono width=50 // mix 50% of one channel with the other","title":"Examples"},{"location":"opcodes/width_curveccN/","text":"A width value of 0 makes a stereo sample play as if it were mono (adding both channels and compensating for the resulting volume change). A value of 100 will make the stereo sample play as original. Any value in between will mix left and right channels with a part of the other, resulting in a narrower stereo field image. Negative width values will reverse left and right channels. Note: Range in the table is specified as -100 to 100. Some players, such as Aria/Sforzando, do not clamp the range. Values over 100 expand the stereo width. For example, for a mono signal panned 6dB to the left, a value of 200 produces the mono signal panned 12dB to the left. Examples width=100 // stereo width=0 // play this stereo sample as mono width=50 // mix 50% of one channel with the other","title":"width curveccN"},{"location":"opcodes/width_curveccN/#examples","text":"width=100 // stereo width=0 // play this stereo sample as mono width=50 // mix 50% of one channel with the other","title":"Examples"},{"location":"opcodes/width_onccN/","text":"A width value of 0 makes a stereo sample play as if it were mono (adding both channels and compensating for the resulting volume change). A value of 100 will make the stereo sample play as original. Any value in between will mix left and right channels with a part of the other, resulting in a narrower stereo field image. Negative width values will reverse left and right channels. Note: Range in the table is specified as -100 to 100. Some players, such as Aria/Sforzando, do not clamp the range. Values over 100 expand the stereo width. For example, for a mono signal panned 6dB to the left, a value of 200 produces the mono signal panned 12dB to the left. Examples width=100 // stereo width=0 // play this stereo sample as mono width=50 // mix 50% of one channel with the other","title":"width onccN"},{"location":"opcodes/width_onccN/#examples","text":"width=100 // stereo width=0 // play this stereo sample as mono width=50 // mix 50% of one channel with the other","title":"Examples"},{"location":"opcodes/width_smoothccN/","text":"A width value of 0 makes a stereo sample play as if it were mono (adding both channels and compensating for the resulting volume change). A value of 100 will make the stereo sample play as original. Any value in between will mix left and right channels with a part of the other, resulting in a narrower stereo field image. Negative width values will reverse left and right channels. Note: Range in the table is specified as -100 to 100. Some players, such as Aria/Sforzando, do not clamp the range. Values over 100 expand the stereo width. For example, for a mono signal panned 6dB to the left, a value of 200 produces the mono signal panned 12dB to the left. Examples width=100 // stereo width=0 // play this stereo sample as mono width=50 // mix 50% of one channel with the other","title":"width smoothccN"},{"location":"opcodes/width_smoothccN/#examples","text":"width=100 // stereo width=0 // play this stereo sample as mono width=50 // mix 50% of one channel with the other","title":"Examples"},{"location":"opcodes/width_stepccN/","text":"A width value of 0 makes a stereo sample play as if it were mono (adding both channels and compensating for the resulting volume change). A value of 100 will make the stereo sample play as original. Any value in between will mix left and right channels with a part of the other, resulting in a narrower stereo field image. Negative width values will reverse left and right channels. Note: Range in the table is specified as -100 to 100. Some players, such as Aria/Sforzando, do not clamp the range. Values over 100 expand the stereo width. For example, for a mono signal panned 6dB to the left, a value of 200 produces the mono signal panned 12dB to the left. Examples width=100 // stereo width=0 // play this stereo sample as mono width=50 // mix 50% of one channel with the other","title":"width stepccN"},{"location":"opcodes/width_stepccN/#examples","text":"width=100 // stereo width=0 // play this stereo sample as mono width=50 // mix 50% of one channel with the other","title":"Examples"},{"location":"opcodes/xf_cccurve/","text":"Values can be: gain : Linear gain crossfade. This setting is best when crossfading phase-aligned material. Linear gain crossfades keep constant amplitude during the crossfade, preventing clipping. power : Equal-power RMS crossfade. This setting works better to mix very different material, as a constant power level is kept during the crossfade.","title":"Xf cccurve"},{"location":"opcodes/xf_keycurve/","text":"Values can be: gain : Linear gain crossfade. This setting is best when crossfading phase-aligned material. Linear gain crossfades keep constant amplitude during the crossfade, preventing clipping. power : Equal-power RMS crossfade. This setting works better to mix very different material, as a constant power level is kept during the crossfade.","title":"Xf keycurve"},{"location":"opcodes/xf_velcurve/","text":"Values can be: gain : Linear gain crossfade. This setting is best when crossfading phase-aligned material. Linear gain crossfades keep constant amplitude during the crossfade, preventing clipping. power : Equal-power RMS crossfade. This setting works better to mix very different material, as a constant power level is kept during the crossfade.","title":"Xf velcurve"},{"location":"opcodes/xfin_hiccN/","text":"xfin_loccN and xfin_hiccN set the range of values in the MIDI continuous controller N which will perform a fade-in in the region. The volume of the region will be zero for values of the MIDI continuous controller N lower than or equal to xfin_loccN , and maximum (as defined by the volume opcode) for values greater than or equal to xfin_hiccN . Examples xfin_locc1=64 xfin_hicc1=127 This is used alongside xfout_loccN / xfout_hiccN to create crossfaded dynamic layers for sustained instruments, for example to use the mod wheel to crossfade quiet tuba sustain samples to loud tuba sustain samples. It could also be used to crossfade wavetable samples, use one control to blend multiple microphone perspectives etc. When there are multiple regions under the same note wtih xfin_loccN , xfin_hiccN , xfout_loccN / xfout_hiccN used to determine which regions are currently heard (and at what volume), all regions will be triggered - but some of them may play at zero volume, and therefore be inaudible. In some cases where these controls are not used for dynamic expressive performance but rather for setting a static mix (for example of microphone perspectives), it can make sense to use them alongside loccN / hiccN to keep the regions which would be at zero volume from being triggered and consuming resources.","title":"xfin_loccN / xfin_hiccN"},{"location":"opcodes/xfin_hiccN/#examples","text":"xfin_locc1=64 xfin_hicc1=127 This is used alongside xfout_loccN / xfout_hiccN to create crossfaded dynamic layers for sustained instruments, for example to use the mod wheel to crossfade quiet tuba sustain samples to loud tuba sustain samples. It could also be used to crossfade wavetable samples, use one control to blend multiple microphone perspectives etc. When there are multiple regions under the same note wtih xfin_loccN , xfin_hiccN , xfout_loccN / xfout_hiccN used to determine which regions are currently heard (and at what volume), all regions will be triggered - but some of them may play at zero volume, and therefore be inaudible. In some cases where these controls are not used for dynamic expressive performance but rather for setting a static mix (for example of microphone perspectives), it can make sense to use them alongside loccN / hiccN to keep the regions which would be at zero volume from being triggered and consuming resources.","title":"Examples"},{"location":"opcodes/xfin_hikey/","text":"xfin_lokey and xfin_hikey define the fade-in keyboard zone for the region. The volume of the region will be zero for keys lower than or equal to xfin_lokey , and maximum (as defined by the volume opcode) for keys greater than or equal to xfin_hikey . Example xfin_lokey=c3 xfin_hikey=c4","title":"xfin_lokey / xfin_hikey"},{"location":"opcodes/xfin_hikey/#example","text":"xfin_lokey=c3 xfin_hikey=c4","title":"Example"},{"location":"opcodes/xfin_hivel/","text":"xfin_lovel and xfin_hivel define the fade-in velocity range for the region. The volume of the region will be zero for velocities lower than or equal to xfin_lovel , and maximum (as defined by the volume opcode) for velocities greater than or equal to xfin_hivel . Example xfin_lovel=0 xfin_hivel=31 This is useful for having velocity-based dynamic layers which are gradually crossfaded based on velocity, instead of having hard lovel / hivel cutoffs between the layers.","title":"xfin_lovel / xfin_hivel"},{"location":"opcodes/xfin_hivel/#example","text":"xfin_lovel=0 xfin_hivel=31 This is useful for having velocity-based dynamic layers which are gradually crossfaded based on velocity, instead of having hard lovel / hivel cutoffs between the layers.","title":"Example"},{"location":"opcodes/xfin_loccN/","text":"xfin_loccN and xfin_hiccN set the range of values in the MIDI continuous controller N which will perform a fade-in in the region. The volume of the region will be zero for values of the MIDI continuous controller N lower than or equal to xfin_loccN , and maximum (as defined by the volume opcode) for values greater than or equal to xfin_hiccN . Examples xfin_locc1=64 xfin_hicc1=127 This is used alongside xfout_loccN / xfout_hiccN to create crossfaded dynamic layers for sustained instruments, for example to use the mod wheel to crossfade quiet tuba sustain samples to loud tuba sustain samples. It could also be used to crossfade wavetable samples, use one control to blend multiple microphone perspectives etc. When there are multiple regions under the same note wtih xfin_loccN , xfin_hiccN , xfout_loccN / xfout_hiccN used to determine which regions are currently heard (and at what volume), all regions will be triggered - but some of them may play at zero volume, and therefore be inaudible. In some cases where these controls are not used for dynamic expressive performance but rather for setting a static mix (for example of microphone perspectives), it can make sense to use them alongside loccN / hiccN to keep the regions which would be at zero volume from being triggered and consuming resources.","title":"xfin_loccN / xfin_hiccN"},{"location":"opcodes/xfin_loccN/#examples","text":"xfin_locc1=64 xfin_hicc1=127 This is used alongside xfout_loccN / xfout_hiccN to create crossfaded dynamic layers for sustained instruments, for example to use the mod wheel to crossfade quiet tuba sustain samples to loud tuba sustain samples. It could also be used to crossfade wavetable samples, use one control to blend multiple microphone perspectives etc. When there are multiple regions under the same note wtih xfin_loccN , xfin_hiccN , xfout_loccN / xfout_hiccN used to determine which regions are currently heard (and at what volume), all regions will be triggered - but some of them may play at zero volume, and therefore be inaudible. In some cases where these controls are not used for dynamic expressive performance but rather for setting a static mix (for example of microphone perspectives), it can make sense to use them alongside loccN / hiccN to keep the regions which would be at zero volume from being triggered and consuming resources.","title":"Examples"},{"location":"opcodes/xfin_lokey/","text":"xfin_lokey and xfin_hikey define the fade-in keyboard zone for the region. The volume of the region will be zero for keys lower than or equal to xfin_lokey , and maximum (as defined by the volume opcode) for keys greater than or equal to xfin_hikey . Example xfin_lokey=c3 xfin_hikey=c4","title":"xfin_lokey / xfin_hikey"},{"location":"opcodes/xfin_lokey/#example","text":"xfin_lokey=c3 xfin_hikey=c4","title":"Example"},{"location":"opcodes/xfin_lovel/","text":"xfin_lovel and xfin_hivel define the fade-in velocity range for the region. The volume of the region will be zero for velocities lower than or equal to xfin_lovel , and maximum (as defined by the volume opcode) for velocities greater than or equal to xfin_hivel . Example xfin_lovel=0 xfin_hivel=31 This is useful for having velocity-based dynamic layers which are gradually crossfaded based on velocity, instead of having hard lovel / hivel cutoffs between the layers.","title":"xfin_lovel / xfin_hivel"},{"location":"opcodes/xfin_lovel/#example","text":"xfin_lovel=0 xfin_hivel=31 This is useful for having velocity-based dynamic layers which are gradually crossfaded based on velocity, instead of having hard lovel / hivel cutoffs between the layers.","title":"Example"},{"location":"opcodes/xfout_hiccN/","text":"xfout_loccN and xfout_hiccN set the range of values in the MIDI continuous controller N which will perform a fade-out in the region. The volume of the region will be maximum (as defined by the volume opcode) for values of the MIDI continuous controller N lower than or equal to xfout_loccN , and zero for values greater than or equal to xfout_hiccN . Examples xfout_locc1=64 xfout_hicc1=127","title":"xfout_loccN / xfout_hiccN"},{"location":"opcodes/xfout_hiccN/#examples","text":"xfout_locc1=64 xfout_hicc1=127","title":"Examples"},{"location":"opcodes/xfout_hikey/","text":"xfout_lokey and xfout_hikey define the fade-out keyboard zone for the region. The volume of the region will be maximum (as defined by the volume opcode) for keys lower than or equal to xfout_lokey , and zero for keys greater than or equal to xfout_hikey . Example xfout_lokey=72 xfout_hikey=84 As with the [key] opcode, the values can also be MIDI note names: xfout_lokey=c5 xfout_hikey=c6","title":"xfout_lokey / xfout_hikey"},{"location":"opcodes/xfout_hikey/#example","text":"xfout_lokey=72 xfout_hikey=84 As with the [key] opcode, the values can also be MIDI note names: xfout_lokey=c5 xfout_hikey=c6","title":"Example"},{"location":"opcodes/xfout_hivel/","text":"xfout_lokey and xfout_hikey define the fade-out velocity range for the region. The volume of the region will be maximum (as defined by the volume opcode) for velocities lower than or equal to xfout_lovel , and zero for velocities greater than or equal to xfout_hivel . Example xfout_lovel=32 xfout_hivel=63","title":"xfout_lovel / xfout_hivel"},{"location":"opcodes/xfout_hivel/#example","text":"xfout_lovel=32 xfout_hivel=63","title":"Example"},{"location":"opcodes/xfout_loccN/","text":"xfout_loccN and xfout_hiccN set the range of values in the MIDI continuous controller N which will perform a fade-out in the region. The volume of the region will be maximum (as defined by the volume opcode) for values of the MIDI continuous controller N lower than or equal to xfout_loccN , and zero for values greater than or equal to xfout_hiccN . Examples xfout_locc1=64 xfout_hicc1=127","title":"xfout_loccN / xfout_hiccN"},{"location":"opcodes/xfout_loccN/#examples","text":"xfout_locc1=64 xfout_hicc1=127","title":"Examples"},{"location":"opcodes/xfout_lokey/","text":"xfout_lokey and xfout_hikey define the fade-out keyboard zone for the region. The volume of the region will be maximum (as defined by the volume opcode) for keys lower than or equal to xfout_lokey , and zero for keys greater than or equal to xfout_hikey . Example xfout_lokey=72 xfout_hikey=84 As with the [key] opcode, the values can also be MIDI note names: xfout_lokey=c5 xfout_hikey=c6","title":"xfout_lokey / xfout_hikey"},{"location":"opcodes/xfout_lokey/#example","text":"xfout_lokey=72 xfout_hikey=84 As with the [key] opcode, the values can also be MIDI note names: xfout_lokey=c5 xfout_hikey=c6","title":"Example"},{"location":"opcodes/xfout_lovel/","text":"xfout_lokey and xfout_hikey define the fade-out velocity range for the region. The volume of the region will be maximum (as defined by the volume opcode) for velocities lower than or equal to xfout_lovel , and zero for velocities greater than or equal to xfout_hivel . Example xfout_lovel=32 xfout_hivel=63","title":"xfout_lovel / xfout_hivel"},{"location":"opcodes/xfout_lovel/#example","text":"xfout_lovel=32 xfout_hivel=63","title":"Example"},{"location":"software/engines/","text":"Name AIFF FLAC MP3 Ogg WAV WavPack ARIA \u2022 \u2022 \u2022 \u2022 Calfbox \u2022 \u2022 \u2022 \u2022 sfizz \u2022 \u2022 \u2022 \u2022 \u2022 \u2022","title":"Engines sample formats support"},{"location":"software/players/","text":"There are several SFZ players, which are used to play samples as defined in SFZ files. Sforzando currently offers the most complete SFZ standard support, including ARIA extensions , but SFZ files which only use the SFZ v1 or SFZ v2 standard will work with multiple SFZ players. We use \"Free and Open Source\" (FOSS) as defined by the OSI as \"software to be freely used, modified, and shared.\" Supported Opcodes Below are the known links to the various lists of supported opcodes:\\ BassMIDI , Bitwig , HISE , LinuxSampler , liquidsfz , OpenMPT , sfizz , zerberus (MuseScore <= v3.6.2) or else in our Wiki . Players Name License Linux macOS Windows Description Calfbox GPL-3.0-or-later \u2713 \u2713 \u2713 C library and Python module to build audio applications like MIDI sequencers or samplers (SFZ or SF2 via Fluidsynth). Carla (SFZero) GPL-2.0-or-later \u2713 \u2713 \u2713 Fully-featured audio plugin host, with support for many audio drivers and plugin formats. Grace MIT X X \u2713 liquidsfz LGPL-2.1 \u2713 X X SFZ sampler library with LV2 and JACK support. sfizz BSD-2-Clause \u2713 \u2713 \u2713 SFZ library, AU/LV2/VST3 plugin with JACK support. SFZero FOSS \u2713 \u2713 \u2713 An SFZ (and SF2) player and Juce module. Zerberus FOSS \u2713 \u2713 \u2713 MuseScore SFZ synthesizer. LinuxSampler Custom \u2713 \u2713 \u2713 BassMIDI VSTi Freeware X X \u2713 Extension to the BASS audio library, enabling the playing of MIDI files and custom event sequences, using SF2 soundfonts and/or SFZ to provide the sounds. MIDI input is also supported. HighLife Freeware \u2713 \u2713 \u2713 A sampler with integrated effects and wave editor, with support for WAV, MP3, OGG, RAW, FLAC, SND (Akai MPC 2000) and even AKP (Akai S5000/S6000) audio formats. sforzando Freeware X \u2713 \u2713 A free, highly SFZ 2.0 compliant sample player. Supports almost all SFZ v1 and v2 opcodes, plus ARIA extensions. TX16Wx Sampler Freeware X \u2713 \u2713 Zampler Freeware X \u2713 \u2713 Synth-based sample player using SFZ format as its sound generator. It supports very minimal SFZ v1 opcodes, only for key-range and velocity-range mapping. ARIA OEM X \u2713 \u2713 An audio sampling and synthesis Engine based on the SFZ 1.0 / SFZ 2.0 open file formats for instrument programming and the Scala open file format to define scales and temperaments. Bliss Sampler Commercial \u2713 \u2713 \u2713 An UI themable sampler and wave editor in VST2/3 and AU audio plugin format with selectable high quality interpolation and integrated effects. Samplelord Commercial X X \u2713 Sample player as standalone or VSTi plugin for Windows 32-bit OS that can load different sounds in different formats. Has basic parameter controls, supports only SFZ v1 opcodes. TAL-Sampler Commercial \u2713 \u2713 \u2713 Unify Commercial X \u2713 \u2713 Falcon Commercial X \u2713 \u2713 Wusik 8008, Wusik One, Wusik EVE V5 Commercial X X \u2713 sfz-web-player CC0-1.0 \u2713 \u2713 \u2713 TypeScript/JavaScript SFZ player using the Web Audio API. Import from SFZ Name License Linux macOS Windows Description Bitwig Studio Commercial \u2713 \u2713 \u2713 Sampler device supports the import of SFZ. Also via drag & drop. HISE GPL-3.0 \u2713 \u2713 \u2713 MSoundFactory Commercial X \u2713 \u2713 Sampler module imports/exports SFZ. OpenMPT BSD-3-Clause X X \u2713 Poise Freeware X X \u2713 Simple 16 drum pads percussion sampler, 8 layers. Very limited SFZ support. Renoise (Redux) Commercial \u2713 \u2713 \u2713 No longer available Alchemy (Camel Audio was acquired by Apple, and the current incarnation of Alchemy no longer supports SFZ.) Cakewalk sfz (backup on web.archive.org) Equator 2 (per Equator 2 FAQ , \"SFZ import is not currently supported\")","title":"SFZ Players"},{"location":"software/players/#supported-opcodes","text":"Below are the known links to the various lists of supported opcodes:\\ BassMIDI , Bitwig , HISE , LinuxSampler , liquidsfz , OpenMPT , sfizz , zerberus (MuseScore <= v3.6.2) or else in our Wiki .","title":"Supported Opcodes"},{"location":"software/players/#no-longer-available","text":"Alchemy (Camel Audio was acquired by Apple, and the current incarnation of Alchemy no longer supports SFZ.) Cakewalk sfz (backup on web.archive.org) Equator 2 (per Equator 2 FAQ , \"SFZ import is not currently supported\")","title":"No longer available"},{"location":"software/tools/","text":"Although SFZ files can be created with any text editor, and some users have also created SFZ with spreadsheets, there are some dedicated tools which can make mapping large amounts of samples easier. As SFZ instruments can quickly grow to thousands of samples, efficiency in creating the mappings becomes important. One way of creating SFZ files is to use one of these tools to create the initial maps with keys, dynamic layers, round robins etc. defined, then add controls etc. using a text editor. Automappers Name License Linux macOS Windows Description SFZ Python Automapper Public Domain \u2713 \u2713 \u2713 Folder-to-SFZ converter Freeware \u2713 \u2713 \u2713 Bjoerns Sample Mapper Freeware X \u2713 \u2713 soundmap GPL-3.0 \u2713 \u2713 \u2713 Online automapper. Can create .sfz and .dspreset Converters Name License Linux macOS Windows Description ConvertWithMoss (Java) LGPL-3.0-only \u2713 \u2713 \u2713 Converts multisamples in a specific source format to a different destination format. exs2sfz (Python) ISC \u2713 \u2713 \u2713 EXS24 to SFZ sample library metadata converter. SFZ to HISE Converter MIT \u2713 \u2713 \u2713 Parses and translates/converts SFZ instruments to HISE samplemaps and extracts SFZ opcode data to a JS/JSON object. Runs in a web browser. EXS2SFZ Freeware X \u2713 \u2713 Imports sample mapping information from EXS24 instruments and generates SFZ files from it. TX2SFZ Freeware X X \u2713 Converts sample mapping information from TX16WX sampler to SFZ. Awave Studio Commercial X X \u2713 Multi-purpose audio tool that reads a veritable host of audio carrying file formats from different platforms, synthesizers, trackers, mobile phones. It can be used in a variety of ways; as a file format converter, as an audio editor, or as a synth instrument editor. Chicken Systems Translator Commercial X \u2713 \u2713 Extreme Sample Converter Commercial X X \u2713 sfz-tools-cli CC0-1.0 \u2713 \u2713 \u2713 Command line interface comprised of several tools to read, convert and parse SFZ and audio files. Editors Name License Linux macOS Windows Description Polyphone GPL-3.0 \u2713 \u2713 \u2713 An open-source soundfont editor for creating musical instruments. Note: being a soundfont editor (sf2) it has limited sfz support when exporting. sfZed Freeware X X \u2713 An editor for the SFZ format used by certain VST instruments. It will also convert Soundfont SF2 to SFZ and works with a midi keyboard to allow you to play and set values, including mapping drum samples. Loop Editors Name License Linux macOS Windows Description LoopAuditioneer GPL-3.0-or-later \u2713 X \u2713 Software for evaluating, creating and manipulating loops and cues and other properties of wav file metadata. Edison Commercial X \u2713 \u2713 Fully integrated audio editing and recording tool in FL Studio. Endless WAV Freeware X \u2713 \u2713 Software to create sustain loops in WAV files (8, 16 and 24 bit) with loop mix, auto loop, realtime crossfade, fade and cut functions. Wavosaur Freeware X X \u2713 Software for editing, processing and recording sounds, wav and mp3 files. Wavosaur has all the features to edit audio (cut, copy, paste, etc.) produce music loops, analyze, record, batch convert. Supports VST plugins, ASIO driver, multichannel wav files, real time effect processing. Misc Name License Linux macOS Windows Description Freepats-tools GPL-3.0 \u2713 \u2713 \u2713 Tools to manage, create and convert sound fonts, collections of sampled musical instruments and sound banks. Originally created for the FreePats project . sfzlint MIT \u2713 \u2713 \u2713 Linter and parser for .sfz files. sfz-tools-core CC0-1.0 \u2713 \u2713 \u2713 TypeScript/JavaScript library to read, convert and parse SFZ and audio files. Syntax Highlighting Name License Linux macOS Windows Description CudaText Editor MPL-2.0 \u2713 \u2713 \u2713 SFZ major mode for GNU Emacs MIT \u2713 \u2713 \u2713 for Geany FOSS \u2713 \u2713 \u2713 for gedit FOSS \u2713 \u2713 \u2713 for Kate MIT \u2713 \u2713 \u2713 for Sublime Text FOSS \u2713 \u2713 \u2713 for VSCode MIT \u2713 \u2713 \u2713 for Notepad++ FOSS X X \u2713 for Notepad++ FOSS X X \u2713 SFZ Tools for UltraEdit FOSS \u2713 \u2713 \u2713 Some Windows only software can be used under other Unix based operating systems using Wine / CrossOver or in a virtual machine software like VirtualBox .","title":"SFZ Creation Tools"},{"location":"tutorials/basic_sfz_file/","text":"Just copy the following in your preferred text editor. We also have a section in the tools page listing some text editor's SFZ syntax highlighting add-ons. Fill in the blanks and save as an SFZ: //------------------------------------------------------------------------------ // A basic sfz template //------------------------------------------------------------------------------ <control> default_path= // relative path of your samples <global> // parameters that affect the whole instrument go here. // ***************************************************************************** // Your mapping starts here // ***************************************************************************** <group> // 1 // Parameters that affect multiple regions go here fil_type= // One of the many filter types available cutoff= // freq in hertz cutoff_onccX= // variation in cents resonance= // value in db resonance_onccX= // variation in db trigger=attack // or release or first or legato loop_mode=no_loop // or loop_continuous or one_shot or loop_sustain <region> sample=/*wav or flac file*/ key=// or lokey= hikey= pitch_keycenter= <region> sample= key= <region> sample= key= <region> sample= key= <region> sample= key= <region> sample= key= <region> sample= key= <region> sample= key=","title":"Basic SFZ file"},{"location":"tutorials/basics/","text":"A SFZ file is a set of plain text, computer-readable instructions, which accompany a sample set and define how the sampler should load and work with those samples. If the samples are the strings of a piano or pipes of an organ, the SFZ file is the mechanism that connects the key to the hammer which strikes the strings or the air and signals to the pipes of the organ. SFZ files can be opened, edited, and created in any text editor application, even the default 'Notepad' in Windows. No external software is necessary to create or modify a SFZ file, though there are some pieces of software or scripts out there which greatly ease the creation or editing process. An example of this is an automapper, which is a script or application that takes a sample set and uses the names of the samples or actual audio content to determine how to map those samples. The SFZ file's role is a simple, two-part operation: 1. Explain how to filter or sort the incoming MIDI data and determine which sample(s), if any, should sound in response. 2. Instruct the Sampler how to modulate , or adapt , those samples, such as make them quieter or apply a filter. graph LR A(Incoming MIDI Data) --> B(Sampler) B --> C(Audio Output) B --> D(SFZ File) D --> E(Sample1.wav) D --> F(Sample2.wav) D --> G(Sample3.wav) E --> H(Modulation) F --> H G --> H H --> C Opcodes The primary component of any SFZ file is the opcode. Opcodes essentially define 'thing=value'. For example, the opcode 'volume=6' defines the volume of the sample as +6 decibels relative to normal. Opcodes functionally perform two different roles: (1) defining performance parameters , or (2) restricting the conditions under which that sound may be used . For example, volume=6 defines a performance property: the sample will sound 6 decibels louder. On the other hand, lokey=36 hikey=38 limits what condition the sound may play: the key to trigger the sound must be in the range 36 through 38. You can think of your SFZ file as a giant conditional filter, which systematically takes a MIDI message and attempts to perform a specific action in response. At the most basic level, if you simply type <region> sample=piano.wav Then that sample will be mapped to MIDI key 60 (middle C), and be available at ALL velocity ranges, ALL key ranges, and under ALL continuous controller values (i.e. regardless of if sustain pedal is held down or not, for example). If we add lokey=58 hikey=62 pitch_keycenter=60 to the region, then our piano note will ONLY respond if a key within the range 58-62 (Bb to D on either side of middle C) is played. We are restricting the conditions under which that specific sample will be played. We can restrict whether or not a specific sample will play by a very wide range of parameters, including which keys are pressed, at what velocity, and what MIDI continuous controller (CC) values are currently present. For example, we can have a piano sample for when the sustain pedal is down AND velocity is less than 20 AND the key pressed is between 58 and 62 as follows: <region> sample=piano.wav pitch_keycenter=60 //here we define the real \"concert\" pitch of the sample, MIDI note 60 or middle C lokey=58 //here we set the range of pitches the region will play on hikey=62 lovel=1 //here we set the range of key velocities that the region will play on hivel=20 locc64=64 //here we set that the sustain pedal, cc64, must be on for the region to play hicc64=127 If for any reason the MIDI signal DOES NOT meet ALL of the conditions, that sample will not play. That is the basic underlying framework on how SFZ files are organized. Headers Headers serve to organize and separate opcodes, and are marked with < > on either side. There are three primary headers: <region> , <group> , and <global> , from most to least restrictive. A region, for example, may only contain a single sample. A group is comprised of a series of regions, each containing a single sample. A global is comprised of a series of groups, each containing a series of regions, etc. <control> is a special purpose header used for a few special opcodes such as default_path . Generally SFZ instruments are not indented, but if they were, they would appear as such: <control> <global> <group> <region> sample= <region> sample= <group> <region> sample= <region> sample= Inheriting Note that if you entered an opcode between a <group> and its first <region> , that opcode would be inherited by the <region> s within the group. The same can be done for <global> as well, with <global> affecting all of the <group> s within it, and that being passed down to each of the <region> s within those groups as welll, allowing the parameters of dozens, hundreds, or thousands of samples to be altered with a single line. This massively cuts down on file size, as you do not need to repeat the same text in each item. <group> lovel=64 // enter stuff here if you want to apply it to all regions hivel=127 <region> sample=Trumpet_C4_v2.wav key=60 <region> sample=Trumpet_C#4_v2.wav key=61 <region> sample=Trumpet_D4_v2.wav key=62 is the same as: <region> sample=Trumpet_C4_v2.wav key=60 lovel=64 hivel=127 <region> sample=Trumpet_C#4_v2.wav key=61 lovel=64 hivel=127 <region> sample=Trumpet_D4_v2.wav key=62 lovel=64 hivel=127 This behavior can be overriden if that same opcode is specified within the lesser header with a different value. For example: <global> volume=6 //this value will be inherited by everything, unless overriden below <group> //Group A volume=5 <region> //Region 1 volume=4 <region> //Region 2 <group> //Group B <region> //Region 3 volume=2 <region> //Region 4 (indented for clarity; SFZ is not usually indented) Here's what's going on here: Region 1's volume is 4, as it has volume defined. Region 2's volume is 5, as it doesn't have volume defined, so it inherits from Group A, as Group A has volume defined. Region 3's volume is 2, as it has volume defined. Region 4's volume is 6 as it doesn't have volume defined, nor does Group B, so it inherits from the Global volume setting which is 6. Always look for opportunities to use inheriting to keep your scripts tidy by removing duplicate code. Header Nesting Unlike many popular scripting or programming languages or markup languages like HTML, XML, JSON, etc. there is no such concept as nesting in SFZ. Nesting is when a header of the same type can exist within another header of the same type. Nesting is very useful, but it can add a lot of complexity and layers to a language, and is a common source of bugs or mistakes as well as a slight impediment of speed. The downside to the lack of nesting is that the number of layers is restricted severely rather than infinite. That is why there is both <group> and <global> , and the ARIA Player/Sforzando will also use an intermediate between the two, <master> to provide one more layer. In SFZ format, a header ends when the next header of that type is started. For example, if I put a <region> after another <region> , it will end the first region automatically at the start of declaring the next. Keep in mind that group, global, and master are merely macros to reduce duplicate code. When compiled (in most SFZ players), the SFZ file will run as if everything is inside the regions themselves. Organization of Opcodes within Headers Opcodes may be listed in a row OR one per line, unofficially known as 'condensed' and 'expanded' view: <region> sample=piano_D4_vl1.wav lokey=62 hikey=63 pitch_keycenter=62 lovel=1 hivel=50 is equal to: <region> sample=piano_D4_vl1.wav lokey=62 hikey=63 pitch_keycenter=62 lovel=1 hivel=50 You can see how much space is saved in the latter case, and it allows bulk adjustments to be done easier and makes debugging slightly easier, e.g.: <region> sample=piano_D4_vl1.wav lokey=62 hikey=63 pitch_keycenter=62 lovel=1 hivel=50 <region> sample=piano_E4_vl1.wav lokey=64 hikey=65 pitch_keycenter=64 lovel=1 hivel=50 <region> sample=piano_F#4_vl1.wav lokey=66 hikey=67 pitch_keycenter=66 lovel=11 hivel=50 <region> sample=piano_G#4_vl1.wav lokey=68 hikey=69 pitch_keycenter=68 lovel=1 hivel=50 You can see there is something wrong with the third region, a typo of lovel=11 instaed of lovel=1 . These four lines would replace over 20 lines, making files much more manageable. It is possible to swap between the two by using a find-and-replace operation in your text editor (e.g. Notepad++ or equivalent) to replace new line character with a space (this can be done by selecting a blank line by clicking and dragging down on a blank so that one line is highlighted, THEN open the find/replace dialog and it will be auto-filled in the 'find' field; put a single space in the 'replace with' field. Try executing and see if it works; see the video below for a visual representation of the process). https://youtu.be/Lr7_qS2iV30 Pitch If using a pitch based instrument, you will most likely be working heavily with three opcodes: lokey , hikey , and pitch_keycenter . These opcodes define the range of MIDI note numbers or note names that will allow the note to play. It is highly recommended that you use MIDI note numbers, as pitch naming conventions are poorly standardized at best. You can remember the MIDI note numbers for the C's as follows, using International Pitch Notation , which states C4=MIDI note number 60: C1:24 C2: 36 (this is the C below bass clef) C3: 48 (this is the C in bass clef) C4: 60 (this is Middle C) C5: 72 (this is the C in treble clef) C6: 84 (this is the C above treble clef) C7: 96 (note that many, many samplers use a different standard of C3=60, in which case all numbers are shifted down one; in fact, this is probably much more commonly found) You'll notice each value is exactly 12 notes apart from the others. It's not too difficult to calculate notes between the C's, or keep a chart on your wall or desk with the note names and MIDI numbers listed out. Many hours have been saved debugging and mapping for me in this way. Velocity Layers For most instruments, it is possible to perform notes of varying intensity. For classically trained musicians, this might be called dynamics (such as piano, forte, mezzo-forte, etc.). For a piano, when a key is struck with minimal force versus a great deal of force, a rather different tone is emitted, with harder strikes having more higher frequency content present. In the MIDI world, we refer to this as Velocity , borrowing the term from the world of physics. In the original MIDI spec, velocity has a range of 1-127 (aside: a velocity value of '0' is actually an alias of 'note off' signal, so the actual range is 1-127, not 0-127). So, to make a realistic piano (or really most any instrument), it is necessary to sample the tone of the instrument at several different dynamic levels or velocities. We collectively refer to these sets of levels as Velocity Layers or Dynamic Layers . For example, let us say we record a piano with three such velocity layers. The softest layer might be what a classically trained pianist might call piano or pianissimo (p or pp marking). The moderate layer might be mezzo-forte (mf) , and the hardest layer fortissimo (ff) . In SFZ, we would assign each layer to a velocity range from the 1-127 range. For example, the lowest layer might get the range of 1-50, the medium from 51-100, and the loudest from 101-127. We express this in SFZ using lovel and hivel, for example: <region> sample=piano_C4_vl1.wav lovel=1 hivel=50 <region> sample=piano_C4_vl2.wav lovel=51 hivel=100 <region> sample=piano_C4_vl3.wav lovel=101 hivel=127 We would of course also add our lokey , hikey , and pitch_keycenter to these as well if we recorded multiple tones on the instrument. Using Velocity with Groups & Inheriting To simplify our lives and keep our SFZ files from being huge, we can also use the <group> header to organize our velocity layers, for example. Any <region> within a <group> will of course inherit whatever is listed in that <group> , so if we group our samples as shown below, we can significantly cut down on the amount of space needed in the file: <group> //velocity layer 1 (pp) lovel=1 hivel=50 <region> //C4 sample=piano_C4_vl1.wav lokey=60 hikey=61 pitch_keycenter=60 <region> //D4 sample=piano_D4_vl1.wav lokey=62 hikey=63 pitch_keycenter=62 <region> //E4 sample=piano_E4_vl1.wav lokey=64 hikey=64 pitch_keycenter=64 <region> //F4 sample=piano_F4_vl1.wav lokey=65 hikey=66 pitch_keycenter=65 <group> //velocity layer 2 (mf) lovel=51 hivel=100 <region> //C4 sample=piano_C4_vl2.wav lokey=60 hikey=61 pitch_keycenter=60 <region> //D4 sample=piano_D4_vl2.wav lokey=62 hikey=63 pitch_keycenter=62 <region> //E4 sample=piano_E4_vl2.wav lokey=64 hikey=64 pitch_keycenter=64 <region> //F4 sample=piano_F4_vl2.wav lokey=65 hikey=66 pitch_keycenter=65 <group> //velocity layer 3 (ff) lovel=101 hivel=127 <region> //C4 sample=piano_C4_vl3.wav lokey=60 hikey=61 pitch_keycenter=60 <region> //D4 sample=piano_D4_vl3.wav lokey=62 hikey=63 pitch_keycenter=62 <region> //E4 sample=piano_E4_vl3.wav lokey=64 hikey=64 pitch_keycenter=64 <region> //F4 sample=piano_F4_vl3.wav lokey=65 hikey=66 pitch_keycenter=65 Keep in mind of course that we can always override the inheriting behavior here, such as in the case of a sample for which only two velocity layers were recorded. This might happen in the case of a mistake, or in the case where time was running short in the session, or in some cases where the instrument physically has less distinction between its quietest and loudest sounds and it was desirable to save some time. You can also use group, master, and global to organize other things than velocity layers, such as keys, sustain pedal state, round robins, mic positions, and more. Just be careful as in some cases you might run out of headers to use if the file gets too complex, such as if you are using multiple mic positions, round robins, and grouping your velocity layers as well. Includes One final more advanced topic to discuss is Includes. Perhaps the dark magic of SFZ, #include allows you to take the contents of one SFZ file and import them into your current file. This allows another layer of organiziation to take place, with, for example, all of the samples for each drum in a drum kit to exist in a separate .sfz file without an assigned key range, and a single master .sfz file to inherit each of those into a <group> where their key range is assigned (see Virtuosity Drums as a good example of this process). This might also be useful for an acoustic instrument to organize by mic position or articulation. This allows you to keep an extremely tidy workflow, creating easily-managed main files where you can rapidly change key ranges and other control values to get the controls you need. .videoWrapper { position: relative; padding-bottom: 56.333%; height: 0; background: black; } .videoWrapper iframe { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: 0; } function get_youtube_id(url) { var p = /^(?:https?:\\/\\/)?(?:www\\.)?(?:youtu\\.be\\/|youtube\\.com\\/(?:embed\\/|v\\/|watch\\?v=|watch\\?.+&v=)|youtube-nocookie\\.com\\/(?:embed\\/|v\\/|watch\\?v=|watch\\?.+&v=))((\\w|-){11})(?:\\S+)?$/; return (url.match(p)) ? RegExp.$1 : false; } function vimeo_embed(url,el) { var id = false; $.ajax({ url: 'https://vimeo.com/api/oembed.json?url='+url, async: true, success: function(response) { if(response.video_id) { id = response.video_id; if(url.indexOf('autoplay=1') !== -1) var autoplay=1; else var autoplay=0; if(url.indexOf('loop=1') !== -1) var loop=1; else var loop=0; var theInnerHTML = '<div class=\"videoWrapper\"><iframe src=\"https://player.vimeo.com/video/'+id+'/?byline=0&title=0&portrait=0'; if(autoplay==1) theInnerHTML += '&autoplay=1'; if(loop==1) theInnerHTML += '&loop=1'; theInnerHTML += '\" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div>'; el.innerHTML = theInnerHTML; } } }); } function video_embed() { var p = document.getElementsByTagName('p'); for(var i = 0; i < p.length; i++) { //check if this is an external url (that starts with https:// or http:// if (p[i].innerHTML.indexOf(\"http://\") == 0 || p[i].innerHTML.indexOf(\"https://\") == 0) { var youtube_id = get_youtube_id(p[i].innerHTML); if(youtube_id) { if(p[i].innerHTML.indexOf('autoplay=1') !== -1) var autoplay=1; else var autoplay=0; if(p[i].innerHTML.indexOf('loop=1') !== -1) var loop=1; else var loop=0; var theInnerHTML = '<div class=\"videoWrapper\"><iframe width=\"720\" height=\"420\" src=\"https://www.youtube-nocookie.com/embed/' + youtube_id + '?rel=0&showinfo=0'; if(autoplay==1) theInnerHTML += '&autoplay=1'; if(loop==1) theInnerHTML += '&loop=1&playlist='+youtube_id+'&version=3'; if(p[i].innerHTML.indexOf('start=') !== -1) theInnerHTML += '&start='+p[i].innerHTML.substring(p[i].innerHTML.indexOf('start=')+6); theInnerHTML += '\" frameborder=\"0\" allowfullscreen></iframe></div>'; p[i].innerHTML = theInnerHTML; } if(p[i].innerHTML.indexOf('vimeo.com') !== -1) { //ask vimeo for the id and place the embed vimeo_embed(p[i].innerHTML,p[i]); } } } } video_embed(); function mp3_embed() { var p = document.getElementsByTagName('p'); for(var i = 0; i < p.length; i++) { if(p[i].innerHTML.indexOf('.mp3') !== -1) { var str = p[i].innerHTML.split('?'); if(str.length == 1) str[1] = ''; var str1 = str[1]; str1 = str1.replace('&','').replace('&',''); str1 = str1.replace('autoplay=1','').replace('autoplay=0',''); str1 = str1.replace('loop=1','').replace('loop=0',''); str1 = str1.replace('controls=0','').replace('controls=1',''); if (str[0].lastIndexOf('.mp3', str[0].length - 4) === str[0].length - 4 && str1.length == 0) { if(str[1].indexOf('autoplay=1') !== -1) var autoplay=1; else var autoplay=0; if(str[1].indexOf('loop=1') !== -1) var loop=1; else var loop=0; if(str[1].indexOf('controls=0') !== -1) var controls=0; else var controls=1; var newInnerHTML = '<audio'; if(autoplay==1) newInnerHTML += ' autoplay'; if(loop==1) newInnerHTML += ' loop'; if(controls==1) newInnerHTML += ' controls'; newInnerHTML += '><source src=\"'+str[0]+'\" type=\"audio/mpeg\">Your browser does not support the audio element.</audio>'; p[i].innerHTML = newInnerHTML; } } } } mp3_embed();","title":"Intro to SFZ"},{"location":"tutorials/basics/#opcodes","text":"The primary component of any SFZ file is the opcode. Opcodes essentially define 'thing=value'. For example, the opcode 'volume=6' defines the volume of the sample as +6 decibels relative to normal. Opcodes functionally perform two different roles: (1) defining performance parameters , or (2) restricting the conditions under which that sound may be used . For example, volume=6 defines a performance property: the sample will sound 6 decibels louder. On the other hand, lokey=36 hikey=38 limits what condition the sound may play: the key to trigger the sound must be in the range 36 through 38. You can think of your SFZ file as a giant conditional filter, which systematically takes a MIDI message and attempts to perform a specific action in response. At the most basic level, if you simply type <region> sample=piano.wav Then that sample will be mapped to MIDI key 60 (middle C), and be available at ALL velocity ranges, ALL key ranges, and under ALL continuous controller values (i.e. regardless of if sustain pedal is held down or not, for example). If we add lokey=58 hikey=62 pitch_keycenter=60 to the region, then our piano note will ONLY respond if a key within the range 58-62 (Bb to D on either side of middle C) is played. We are restricting the conditions under which that specific sample will be played. We can restrict whether or not a specific sample will play by a very wide range of parameters, including which keys are pressed, at what velocity, and what MIDI continuous controller (CC) values are currently present. For example, we can have a piano sample for when the sustain pedal is down AND velocity is less than 20 AND the key pressed is between 58 and 62 as follows: <region> sample=piano.wav pitch_keycenter=60 //here we define the real \"concert\" pitch of the sample, MIDI note 60 or middle C lokey=58 //here we set the range of pitches the region will play on hikey=62 lovel=1 //here we set the range of key velocities that the region will play on hivel=20 locc64=64 //here we set that the sustain pedal, cc64, must be on for the region to play hicc64=127 If for any reason the MIDI signal DOES NOT meet ALL of the conditions, that sample will not play. That is the basic underlying framework on how SFZ files are organized.","title":"Opcodes"},{"location":"tutorials/basics/#headers","text":"Headers serve to organize and separate opcodes, and are marked with < > on either side. There are three primary headers: <region> , <group> , and <global> , from most to least restrictive. A region, for example, may only contain a single sample. A group is comprised of a series of regions, each containing a single sample. A global is comprised of a series of groups, each containing a series of regions, etc. <control> is a special purpose header used for a few special opcodes such as default_path . Generally SFZ instruments are not indented, but if they were, they would appear as such: <control> <global> <group> <region> sample= <region> sample= <group> <region> sample= <region> sample=","title":"Headers"},{"location":"tutorials/basics/#inheriting","text":"Note that if you entered an opcode between a <group> and its first <region> , that opcode would be inherited by the <region> s within the group. The same can be done for <global> as well, with <global> affecting all of the <group> s within it, and that being passed down to each of the <region> s within those groups as welll, allowing the parameters of dozens, hundreds, or thousands of samples to be altered with a single line. This massively cuts down on file size, as you do not need to repeat the same text in each item. <group> lovel=64 // enter stuff here if you want to apply it to all regions hivel=127 <region> sample=Trumpet_C4_v2.wav key=60 <region> sample=Trumpet_C#4_v2.wav key=61 <region> sample=Trumpet_D4_v2.wav key=62 is the same as: <region> sample=Trumpet_C4_v2.wav key=60 lovel=64 hivel=127 <region> sample=Trumpet_C#4_v2.wav key=61 lovel=64 hivel=127 <region> sample=Trumpet_D4_v2.wav key=62 lovel=64 hivel=127 This behavior can be overriden if that same opcode is specified within the lesser header with a different value. For example: <global> volume=6 //this value will be inherited by everything, unless overriden below <group> //Group A volume=5 <region> //Region 1 volume=4 <region> //Region 2 <group> //Group B <region> //Region 3 volume=2 <region> //Region 4 (indented for clarity; SFZ is not usually indented) Here's what's going on here: Region 1's volume is 4, as it has volume defined. Region 2's volume is 5, as it doesn't have volume defined, so it inherits from Group A, as Group A has volume defined. Region 3's volume is 2, as it has volume defined. Region 4's volume is 6 as it doesn't have volume defined, nor does Group B, so it inherits from the Global volume setting which is 6. Always look for opportunities to use inheriting to keep your scripts tidy by removing duplicate code.","title":"Inheriting"},{"location":"tutorials/basics/#header-nesting","text":"Unlike many popular scripting or programming languages or markup languages like HTML, XML, JSON, etc. there is no such concept as nesting in SFZ. Nesting is when a header of the same type can exist within another header of the same type. Nesting is very useful, but it can add a lot of complexity and layers to a language, and is a common source of bugs or mistakes as well as a slight impediment of speed. The downside to the lack of nesting is that the number of layers is restricted severely rather than infinite. That is why there is both <group> and <global> , and the ARIA Player/Sforzando will also use an intermediate between the two, <master> to provide one more layer. In SFZ format, a header ends when the next header of that type is started. For example, if I put a <region> after another <region> , it will end the first region automatically at the start of declaring the next. Keep in mind that group, global, and master are merely macros to reduce duplicate code. When compiled (in most SFZ players), the SFZ file will run as if everything is inside the regions themselves.","title":"Header Nesting"},{"location":"tutorials/basics/#organization-of-opcodes-within-headers","text":"Opcodes may be listed in a row OR one per line, unofficially known as 'condensed' and 'expanded' view: <region> sample=piano_D4_vl1.wav lokey=62 hikey=63 pitch_keycenter=62 lovel=1 hivel=50 is equal to: <region> sample=piano_D4_vl1.wav lokey=62 hikey=63 pitch_keycenter=62 lovel=1 hivel=50 You can see how much space is saved in the latter case, and it allows bulk adjustments to be done easier and makes debugging slightly easier, e.g.: <region> sample=piano_D4_vl1.wav lokey=62 hikey=63 pitch_keycenter=62 lovel=1 hivel=50 <region> sample=piano_E4_vl1.wav lokey=64 hikey=65 pitch_keycenter=64 lovel=1 hivel=50 <region> sample=piano_F#4_vl1.wav lokey=66 hikey=67 pitch_keycenter=66 lovel=11 hivel=50 <region> sample=piano_G#4_vl1.wav lokey=68 hikey=69 pitch_keycenter=68 lovel=1 hivel=50 You can see there is something wrong with the third region, a typo of lovel=11 instaed of lovel=1 . These four lines would replace over 20 lines, making files much more manageable. It is possible to swap between the two by using a find-and-replace operation in your text editor (e.g. Notepad++ or equivalent) to replace new line character with a space (this can be done by selecting a blank line by clicking and dragging down on a blank so that one line is highlighted, THEN open the find/replace dialog and it will be auto-filled in the 'find' field; put a single space in the 'replace with' field. Try executing and see if it works; see the video below for a visual representation of the process). https://youtu.be/Lr7_qS2iV30","title":"Organization of Opcodes within Headers"},{"location":"tutorials/basics/#pitch","text":"If using a pitch based instrument, you will most likely be working heavily with three opcodes: lokey , hikey , and pitch_keycenter . These opcodes define the range of MIDI note numbers or note names that will allow the note to play. It is highly recommended that you use MIDI note numbers, as pitch naming conventions are poorly standardized at best. You can remember the MIDI note numbers for the C's as follows, using International Pitch Notation , which states C4=MIDI note number 60: C1:24 C2: 36 (this is the C below bass clef) C3: 48 (this is the C in bass clef) C4: 60 (this is Middle C) C5: 72 (this is the C in treble clef) C6: 84 (this is the C above treble clef) C7: 96 (note that many, many samplers use a different standard of C3=60, in which case all numbers are shifted down one; in fact, this is probably much more commonly found) You'll notice each value is exactly 12 notes apart from the others. It's not too difficult to calculate notes between the C's, or keep a chart on your wall or desk with the note names and MIDI numbers listed out. Many hours have been saved debugging and mapping for me in this way.","title":"Pitch"},{"location":"tutorials/basics/#velocity-layers","text":"For most instruments, it is possible to perform notes of varying intensity. For classically trained musicians, this might be called dynamics (such as piano, forte, mezzo-forte, etc.). For a piano, when a key is struck with minimal force versus a great deal of force, a rather different tone is emitted, with harder strikes having more higher frequency content present. In the MIDI world, we refer to this as Velocity , borrowing the term from the world of physics. In the original MIDI spec, velocity has a range of 1-127 (aside: a velocity value of '0' is actually an alias of 'note off' signal, so the actual range is 1-127, not 0-127). So, to make a realistic piano (or really most any instrument), it is necessary to sample the tone of the instrument at several different dynamic levels or velocities. We collectively refer to these sets of levels as Velocity Layers or Dynamic Layers . For example, let us say we record a piano with three such velocity layers. The softest layer might be what a classically trained pianist might call piano or pianissimo (p or pp marking). The moderate layer might be mezzo-forte (mf) , and the hardest layer fortissimo (ff) . In SFZ, we would assign each layer to a velocity range from the 1-127 range. For example, the lowest layer might get the range of 1-50, the medium from 51-100, and the loudest from 101-127. We express this in SFZ using lovel and hivel, for example: <region> sample=piano_C4_vl1.wav lovel=1 hivel=50 <region> sample=piano_C4_vl2.wav lovel=51 hivel=100 <region> sample=piano_C4_vl3.wav lovel=101 hivel=127 We would of course also add our lokey , hikey , and pitch_keycenter to these as well if we recorded multiple tones on the instrument.","title":"Velocity Layers"},{"location":"tutorials/basics/#using-velocity-with-groups-inheriting","text":"To simplify our lives and keep our SFZ files from being huge, we can also use the <group> header to organize our velocity layers, for example. Any <region> within a <group> will of course inherit whatever is listed in that <group> , so if we group our samples as shown below, we can significantly cut down on the amount of space needed in the file: <group> //velocity layer 1 (pp) lovel=1 hivel=50 <region> //C4 sample=piano_C4_vl1.wav lokey=60 hikey=61 pitch_keycenter=60 <region> //D4 sample=piano_D4_vl1.wav lokey=62 hikey=63 pitch_keycenter=62 <region> //E4 sample=piano_E4_vl1.wav lokey=64 hikey=64 pitch_keycenter=64 <region> //F4 sample=piano_F4_vl1.wav lokey=65 hikey=66 pitch_keycenter=65 <group> //velocity layer 2 (mf) lovel=51 hivel=100 <region> //C4 sample=piano_C4_vl2.wav lokey=60 hikey=61 pitch_keycenter=60 <region> //D4 sample=piano_D4_vl2.wav lokey=62 hikey=63 pitch_keycenter=62 <region> //E4 sample=piano_E4_vl2.wav lokey=64 hikey=64 pitch_keycenter=64 <region> //F4 sample=piano_F4_vl2.wav lokey=65 hikey=66 pitch_keycenter=65 <group> //velocity layer 3 (ff) lovel=101 hivel=127 <region> //C4 sample=piano_C4_vl3.wav lokey=60 hikey=61 pitch_keycenter=60 <region> //D4 sample=piano_D4_vl3.wav lokey=62 hikey=63 pitch_keycenter=62 <region> //E4 sample=piano_E4_vl3.wav lokey=64 hikey=64 pitch_keycenter=64 <region> //F4 sample=piano_F4_vl3.wav lokey=65 hikey=66 pitch_keycenter=65 Keep in mind of course that we can always override the inheriting behavior here, such as in the case of a sample for which only two velocity layers were recorded. This might happen in the case of a mistake, or in the case where time was running short in the session, or in some cases where the instrument physically has less distinction between its quietest and loudest sounds and it was desirable to save some time. You can also use group, master, and global to organize other things than velocity layers, such as keys, sustain pedal state, round robins, mic positions, and more. Just be careful as in some cases you might run out of headers to use if the file gets too complex, such as if you are using multiple mic positions, round robins, and grouping your velocity layers as well.","title":"Using Velocity with Groups &amp; Inheriting"},{"location":"tutorials/basics/#includes","text":"One final more advanced topic to discuss is Includes. Perhaps the dark magic of SFZ, #include allows you to take the contents of one SFZ file and import them into your current file. This allows another layer of organiziation to take place, with, for example, all of the samples for each drum in a drum kit to exist in a separate .sfz file without an assigned key range, and a single master .sfz file to inherit each of those into a <group> where their key range is assigned (see Virtuosity Drums as a good example of this process). This might also be useful for an acoustic instrument to organize by mic position or articulation. This allows you to keep an extremely tidy workflow, creating easily-managed main files where you can rapidly change key ranges and other control values to get the controls you need. .videoWrapper { position: relative; padding-bottom: 56.333%; height: 0; background: black; } .videoWrapper iframe { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: 0; } function get_youtube_id(url) { var p = /^(?:https?:\\/\\/)?(?:www\\.)?(?:youtu\\.be\\/|youtube\\.com\\/(?:embed\\/|v\\/|watch\\?v=|watch\\?.+&v=)|youtube-nocookie\\.com\\/(?:embed\\/|v\\/|watch\\?v=|watch\\?.+&v=))((\\w|-){11})(?:\\S+)?$/; return (url.match(p)) ? RegExp.$1 : false; } function vimeo_embed(url,el) { var id = false; $.ajax({ url: 'https://vimeo.com/api/oembed.json?url='+url, async: true, success: function(response) { if(response.video_id) { id = response.video_id; if(url.indexOf('autoplay=1') !== -1) var autoplay=1; else var autoplay=0; if(url.indexOf('loop=1') !== -1) var loop=1; else var loop=0; var theInnerHTML = '<div class=\"videoWrapper\"><iframe src=\"https://player.vimeo.com/video/'+id+'/?byline=0&title=0&portrait=0'; if(autoplay==1) theInnerHTML += '&autoplay=1'; if(loop==1) theInnerHTML += '&loop=1'; theInnerHTML += '\" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div>'; el.innerHTML = theInnerHTML; } } }); } function video_embed() { var p = document.getElementsByTagName('p'); for(var i = 0; i < p.length; i++) { //check if this is an external url (that starts with https:// or http:// if (p[i].innerHTML.indexOf(\"http://\") == 0 || p[i].innerHTML.indexOf(\"https://\") == 0) { var youtube_id = get_youtube_id(p[i].innerHTML); if(youtube_id) { if(p[i].innerHTML.indexOf('autoplay=1') !== -1) var autoplay=1; else var autoplay=0; if(p[i].innerHTML.indexOf('loop=1') !== -1) var loop=1; else var loop=0; var theInnerHTML = '<div class=\"videoWrapper\"><iframe width=\"720\" height=\"420\" src=\"https://www.youtube-nocookie.com/embed/' + youtube_id + '?rel=0&showinfo=0'; if(autoplay==1) theInnerHTML += '&autoplay=1'; if(loop==1) theInnerHTML += '&loop=1&playlist='+youtube_id+'&version=3'; if(p[i].innerHTML.indexOf('start=') !== -1) theInnerHTML += '&start='+p[i].innerHTML.substring(p[i].innerHTML.indexOf('start=')+6); theInnerHTML += '\" frameborder=\"0\" allowfullscreen></iframe></div>'; p[i].innerHTML = theInnerHTML; } if(p[i].innerHTML.indexOf('vimeo.com') !== -1) { //ask vimeo for the id and place the embed vimeo_embed(p[i].innerHTML,p[i]); } } } } video_embed(); function mp3_embed() { var p = document.getElementsByTagName('p'); for(var i = 0; i < p.length; i++) { if(p[i].innerHTML.indexOf('.mp3') !== -1) { var str = p[i].innerHTML.split('?'); if(str.length == 1) str[1] = ''; var str1 = str[1]; str1 = str1.replace('&','').replace('&',''); str1 = str1.replace('autoplay=1','').replace('autoplay=0',''); str1 = str1.replace('loop=1','').replace('loop=0',''); str1 = str1.replace('controls=0','').replace('controls=1',''); if (str[0].lastIndexOf('.mp3', str[0].length - 4) === str[0].length - 4 && str1.length == 0) { if(str[1].indexOf('autoplay=1') !== -1) var autoplay=1; else var autoplay=0; if(str[1].indexOf('loop=1') !== -1) var loop=1; else var loop=0; if(str[1].indexOf('controls=0') !== -1) var controls=0; else var controls=1; var newInnerHTML = '<audio'; if(autoplay==1) newInnerHTML += ' autoplay'; if(loop==1) newInnerHTML += ' loop'; if(controls==1) newInnerHTML += ' controls'; newInnerHTML += '><source src=\"'+str[0]+'\" type=\"audio/mpeg\">Your browser does not support the audio element.</audio>'; p[i].innerHTML = newInnerHTML; } } } } mp3_embed();","title":"Includes"},{"location":"tutorials/brush_stirs/","text":"Not all drum sounds are hits which can be used in the usual way described in our drum basics article. One major exception are brush techniques which involve scraping the brush across a drum head, often in a circle. If you are not sure what this looks or sounds like, this video is a good guide . These techniques are called swirls or stirs, and for the purpose of this article we'll call them stirs. As the sound changes in intensity, and the duration of the scrapes needs to fit the tempo and rhythm of the song, sampling them requires a different approach to the usual drum hits. The two common approaches are to completely ignore this technique and not sample it at all, and to record loops to fit various tempos. This article describes another approach. The key principle here is that stirs are a noisy, nonlinear sound with a lot of randomness, which makes them very easy to crossfade or loop with no phase issues. Therefore, instead of trying to record stirs performed in a realistic way, we propose recording long, unrealistically steady stirs with no perceptible rhythm or expression, and then using those samples as source material for building up a musical stir. Recording the source material For the purposes of this example, let's assume the source stirs are recorded at four speeds, with 1 being the slowest and 4 being the fastest. Speed 1 is slow enough that a full circle around the head of the drum is completed in more than 4 seconds. That's enough to fill a measure at 60 bpm and still have some sound left, so the user can start the next stir before the previous one ends, and thus achieve a continuous sound. Speed 4 is several circles per second, to match the speed at which the brush would be moving during the peak of an aggressive stir. Making the sound steady at this speed is a challenge. As for how long the recordings need to be, speed 1 needs to be long enough for the longest stir we want to be able to make. However, if tuning controls are to be applied, it's important to remember that pitching a sample up shortens it, so if the tuning range is to extend to one octave up, then a 10-second sample is the minimum to make a 5-second stir. Speeds 3 and 4 are not used thorughout the duration of a stir but only for peaks, and for the purposes of this example they can be half the length of speed 1. Simple stir model We can make a very simple stir using speed 1 by playing the sample with loop_mode set to one_shot, like we normally would set it for a drum hit, and using a simple volume envelope to fade this sample in over a time, and then fade it out. <region>key=26 loop_mode=one_shot sample=snare_stir_speed_1.wav ampeg_attack=1.0 ampeg_decay=1.0 ampeg_sustain=0 The resulting volume envelope will look something like this. The illustrations are not precise, only general shapes. This is a good start, and we can add expression and realism by layering a faster speed on top of it near the stir's peak, with half the duration of the base layer. We use ampeg_delay to delay the start of the second layer by the same amount, so the peaks of both layers align in time. <region>key=26 loop_mode=one_shot sample=snare_stir_speed_1.wav ampeg_attack=1.0 ampeg_decay=1.0 ampeg_sustain=0 <region>key=26 loop_mode=one_shot sample=snare_stir_speed_3.wav ampeg_delay=0.5 ampeg_attack=0.5 ampeg_decay=0.5 ampeg_sustain=0 Modulating stir duration This has a fixed duration and is not flexible, but the stir length can easily be modulated by a single CC parameter changing all the envelope durations. Extremely short stirs, lasting only a small fraction of a second, are obviously not going to sound realistic, so we can use a minimum value to prevent that. Let's use CC1 (standard mod wheel). <region>key=26 loop_mode=one_shot sample=snare_stir_speed_1.wav ampeg_attack=0.1 ampeg_decay=0.1 ampeg_sustain=0 ampeg_attackcc1=0.4 ampeg_decaycc1=0.4 <region>key=26 loop_mode=one_shot sample=snare_stir_speed_3.wav ampeg_delay=0.05 ampeg_attack=0.05 ampeg_decay=0.05 ampeg_sustain=0 ampeg_delaycc1=0.25 ampeg_attackcc1=0.25 ampeg_decaycc1=0.25 Making the shape more realistic Drummers testing the above model have asked for some adjustments to make it sound more realistic. One is to make the first half of the base layer steadier. This can be done very easily by shortening the attack and adding a hold time to the envelope, ensuring that they still add up to the same amount of time that the faster layer's delay and attack, so the peak will remain aligned at all values of the modulation parameter. The attack stage should generally be shorter than the hold stage. <region>key=26 loop_mode=one_shot sample=snare_stir_speed_1.wav ampeg_attack=0.05 ampeg_hold=0.05 ampeg_decay=0.1 ampeg_sustain=0 ampeg_attackcc1=0.05 ampeg_holdcc1=0.35 ampeg_decaycc1=0.4 <region>key=26 loop_mode=one_shot sample=snare_stir_speed_3.wav ampeg_delay=0.05 ampeg_attack=0.05 ampeg_decay=0.05 ampeg_sustain=0 ampeg_delaycc1=0.25 ampeg_attackcc1=0.25 ampeg_decaycc1=0.25 Also, the peak should be sharper and more accented than it is with linear envelopes. Changing the envelope curves accomplishes this, though the initial attack envelope of the base layer can remain linear. The below values seem like a decent start. <region>key=26 loop_mode=one_shot sample=snare_stir_speed_1.wav ampeg_attack=0.05 ampeg_hold=0.05 ampeg_decay=0.1 ampeg_sustain=0 ampeg_attackcc1=0.05 ampeg_holdcc1=0.35 ampeg_decaycc1=0.4 ampeg_attack_shape=0.0 ampeg_decay_shape=-1.4 <region>key=26 loop_mode=one_shot sample=snare_stir_speed_3.wav ampeg_delay=0.05 ampeg_attack=0.05 ampeg_decay=0.05 ampeg_sustain=0 ampeg_delaycc1=0.25 ampeg_attackcc1=0.25 ampeg_decaycc1=0.25 ampeg_attack_shape=3.5 ampeg_decay_shape=-1.4 Adjusting the envelope shapes The above fixed envelope shapes are good for medium tempos and energy levels, but for slow tempos the flat envelope shapes actually work quite well, and more energetic tracks might sound better with even sharper envelope peaks. It would be nice to adjust the envelope curve shapes with MIDI CC, but it is not currently possible to do this. It's possible to work around this by crossfading sharp-envelope and flat-envelope regions, or use locc/hicc to select between several pre-baked envelope shapes . Here's an example of the latter method. <group>key=26 loop_mode=one_shot <region>hicc100=42 sample=snare_stir_speed_1.wav ampeg_attack=0.05 ampeg_hold=0.05 ampeg_decay=0.1 ampeg_sustain=0 ampeg_attackcc1=0.05 ampeg_holdcc1=0.35 ampeg_decaycc1=0.4 ampeg_attack_shape=0.0 ampeg_decay_shape=0.0 <region>hicc100=42 sample=snare_stir_speed_3.wav ampeg_delay=0.05 ampeg_attack=0.05 ampeg_decay=0.05 ampeg_sustain=0 ampeg_delaycc1=0.25 ampeg_attackcc1=0.25 ampeg_decaycc1=0.25 ampeg_attack_shape=0.0 ampeg_decay_shape=0.0 <region>locc100=43 hicc100=86 sample=snare_stir_speed_1.wav ampeg_attack=0.05 ampeg_hold=0.05 ampeg_decay=0.1 ampeg_sustain=0 ampeg_attackcc1=0.05 ampeg_holdcc1=0.35 ampeg_decaycc1=0.4 ampeg_attack_shape=0.0 ampeg_decay_shape=-1.4 <region>locc100=43 hicc100=86 sample=snare_stir_speed_3.wav ampeg_delay=0.05 ampeg_attack=0.05 ampeg_decay=0.05 ampeg_sustain=0 ampeg_delaycc1=0.25 ampeg_attackcc1=0.25 ampeg_decaycc1=0.25 ampeg_attack_shape=3.5 ampeg_decay_shape=-1.4 <region>locc100=87 sample=snare_stir_speed_1.wav ampeg_attack=0.05 ampeg_hold=0.05 ampeg_decay=0.1 ampeg_sustain=0 ampeg_attackcc1=0.05 ampeg_holdcc1=0.35 ampeg_decaycc1=0.4 ampeg_attack_shape=0.0 ampeg_decay_shape=-3.5 <region>locc100=87 sample=snare_stir_speed_3.wav ampeg_delay=0.05 ampeg_attack=0.05 ampeg_decay=0.05 ampeg_sustain=0 ampeg_delaycc1=0.25 ampeg_attackcc1=0.25 ampeg_decaycc1=0.25 ampeg_attack_shape=5.2 ampeg_decay_shape=-3.5 Adding ornaments So far, we have a stir with adjustable duration and shape which peaks halfway through. More complex patterns can have more than one peak, though. A simple way to emulate that is to use a differnet MIDI note to trigger short ornaments which will add a brief extra sound to the stir, thus emulating a momentary acceleration of the brush. We can use one of the higher stir speeds for this. <group>key=27 loop_mode=one_shot sample=snare_stir_speed_2.wav ampeg_attack=0.05 ampeg_decay=0.05 ampeg_sustain=0 ampeg_attackcc1=0.2 ampeg_decaycc1=0.2 <region>hicc100=42 ampeg_attack_shape=0.0 ampeg_decay_shape=0.0 <region>hicc100=42 ampeg_attack_shape=3.5 ampeg_decay_shape=-1.4 <region>hicc100=42 ampeg_attack_shape=5.2 ampeg_decay_shape=-3.5 Accents We can also create accents, which are similar to the typical stir but peak much more quickly and use faster speeds. In pracitce, they can be used either as short, aggressive stirs, or added on top of basic stirs to create more complex patterns. The difference in the SFZ here is that the attack curve shape can be applied to the attack portion as well, and there is no hold stage in the envelope. <group>key=28 loop_mode=one_shot <region>hicc100=42 sample=snare_stir_speed_2.wav ampeg_attack=0.05 ampeg_decay=0.1 ampeg_sustain=0 ampeg_attackcc1=0.05 ampeg_decaycc1=0.4 ampeg_attack_shape=0.0 ampeg_decay_shape=0.0 <region>hicc100=42 sample=snare_stir_speed_4.wav ampeg_attack=0.05 ampeg_decay=0.05 ampeg_sustain=0 ampeg_attackcc1=0.05 ampeg_decaycc1=0.2 ampeg_attack_shape=0.0 ampeg_decay_shape=0.0 <region>locc100=43 hicc100=86 sample=snare_stir_speed_2.wav ampeg_attack=0.05 ampeg_decay=0.1 ampeg_sustain=0 ampeg_attackcc1=0.05 ampeg_decaycc1=0.4 ampeg_attack_shape=3.5 ampeg_decay_shape=-1.4 <region>locc100=43 hicc100=86 sample=snare_stir_speed_4.wav ampeg_attack=0.05 ampeg_decay=0.05 ampeg_sustain=0 ampeg_attackcc1=0.05 ampeg_decaycc1=0.2 ampeg_attack_shape=3.5 ampeg_decay_shape=-1.4 <region>locc100=87 sample=snare_stir_speed_2.wav ampeg_attack=0.05 ampeg_decay=0.1 ampeg_sustain=0 ampeg_attackcc1=0.05 ampeg_decaycc1=0.4 ampeg_attack_shape=5.2 ampeg_decay_shape=-3.5 <region>locc100=87 sample=snare_stir_speed_4.wav ampeg_attack=0.05 ampeg_decay=0.05 ampeg_sustain=0 ampeg_attackcc1=0.05 ampeg_decaycc1=0.2 ampeg_attack_shape=5.2 ampeg_decay_shape=-3.5 Muting As all the above sounds have loop_mode set to one_shot, triggering a note causes the sound to play until the volume envelope drops to zero. If ending a stir earlier than that is required, we can use polyphony groups. The group and off_by opcodes are the key ones here. We can use them to make stirs self-mute, so that triggering a new stir will mute any previously playing stirs, as well as add a key which produces no sound, using silence instead of a sample , but is in the same mute groups, so triggering this key will mute any stir or accent currently playing. This key can be used to stop stirs early. Note that, as usual, separate groups are needed for layers which are to play simultaneously, and if there are multiple microphone positions then those would need separate groups as well. In the below example we also have stirs mute accents, and vice versa, although the ornaments are left out of the mute groups and can be layered on top of other sounds without muting them. For a more sophisticated use of mute groups with other pieces of the drum kit, please see cymbal muting . <global>loop_mode=one_shot off_mode=normal ampeg_release=0.1 ampeg_releasecc1=0.2 <group>key=26 <region>hicc100=42 sample=snare_stir_speed_1.wav ampeg_attack=0.05 ampeg_hold=0.05 ampeg_decay=0.1 ampeg_sustain=0 ampeg_attackcc1=0.05 ampeg_holdcc1=0.35 ampeg_decaycc1=0.4 ampeg_attack_shape=0.0 ampeg_decay_shape=0.0 group=1 off_by=1 <region>hicc100=42 sample=snare_stir_speed_3.wav ampeg_delay=0.05 ampeg_attack=0.05 ampeg_decay=0.05 ampeg_sustain=0 ampeg_delaycc1=0.25 ampeg_attackcc1=0.25 ampeg_decaycc1=0.25 ampeg_attack_shape=0.0 ampeg_decay_shape=0.0 group=2 off_by=2 <region>locc100=43 hicc100=86 sample=snare_stir_speed_1.wav ampeg_attack=0.05 ampeg_hold=0.05 ampeg_decay=0.1 ampeg_sustain=0 ampeg_attackcc1=0.05 ampeg_holdcc1=0.35 ampeg_decaycc1=0.4 ampeg_attack_shape=0.0 ampeg_decay_shape=-1.4 group=1 off_by=1 <region>locc100=43 hicc100=86 sample=snare_stir_speed_3.wav ampeg_delay=0.05 ampeg_attack=0.05 ampeg_decay=0.05 ampeg_sustain=0 ampeg_delaycc1=0.25 ampeg_attackcc1=0.25 ampeg_decaycc1=0.25 ampeg_attack_shape=3.5 ampeg_decay_shape=-1.4 group=2 off_by=2 <region>locc100=87 sample=snare_stir_speed_1.wav ampeg_attack=0.05 ampeg_hold=0.05 ampeg_decay=0.1 ampeg_sustain=0 ampeg_attackcc1=0.05 ampeg_holdcc1=0.35 ampeg_decaycc1=0.4 ampeg_attack_shape=0.0 ampeg_decay_shape=-3.5 group=1 off_by=1 <region>locc100=87 sample=snare_stir_speed_3.wav ampeg_delay=0.05 ampeg_attack=0.05 ampeg_decay=0.05 ampeg_sustain=0 ampeg_delaycc1=0.25 ampeg_attackcc1=0.25 ampeg_decaycc1=0.25 ampeg_attack_shape=5.2 ampeg_decay_shape=-3.5 group=2 off_by=2 <group>key=27 sample=snare_stir_speed_2.wav ampeg_attack=0.05 ampeg_decay=0.05 ampeg_sustain=0 ampeg_attackcc1=0.2 ampeg_decaycc1=0.2 <region>hicc100=42 ampeg_attack_shape=0.0 ampeg_decay_shape=0.0 <region>hicc100=42 ampeg_attack_shape=3.5 ampeg_decay_shape=-1.4 <region>hicc100=42 ampeg_attack_shape=5.2 ampeg_decay_shape=-3.5 <group>key=28 <region>hicc100=42 sample=snare_stir_speed_2.wav ampeg_attack=0.05 ampeg_decay=0.1 ampeg_sustain=0 ampeg_attackcc1=0.05 ampeg_decaycc1=0.4 ampeg_attack_shape=0.0 ampeg_decay_shape=0.0 group=1 off_by=1 <region>hicc100=42 sample=snare_stir_speed_4.wav ampeg_attack=0.05 ampeg_decay=0.05 ampeg_sustain=0 ampeg_attackcc1=0.05 ampeg_decaycc1=0.2 ampeg_attack_shape=0.0 ampeg_decay_shape=0.0 group=2 off_by=2 <region>locc100=43 hicc100=86 sample=snare_stir_speed_2.wav ampeg_attack=0.05 ampeg_decay=0.1 ampeg_sustain=0 ampeg_attackcc1=0.05 ampeg_decaycc1=0.4 ampeg_attack_shape=3.5 ampeg_decay_shape=-1.4 group=1 off_by=1 <region>locc100=43 hicc100=86 sample=snare_stir_speed_4.wav ampeg_attack=0.05 ampeg_decay=0.05 ampeg_sustain=0 ampeg_attackcc1=0.05 ampeg_decaycc1=0.2 ampeg_attack_shape=3.5 ampeg_decay_shape=-1.4 group=2 off_by=2 <region>locc100=87 sample=snare_stir_speed_2.wav ampeg_attack=0.05 ampeg_decay=0.1 ampeg_sustain=0 ampeg_attackcc1=0.05 ampeg_decaycc1=0.4 ampeg_attack_shape=5.2 ampeg_decay_shape=-3.5 group=1 off_by=1 <region>locc100=87 sample=snare_stir_speed_4.wav ampeg_attack=0.05 ampeg_decay=0.05 ampeg_sustain=0 ampeg_attackcc1=0.05 ampeg_decaycc1=0.2 ampeg_attack_shape=5.2 ampeg_decay_shape=-3.5 group=2 off_by=2 <group>key=29 sample=*silence <region>group=1 off_by=1 <region>group=2 off_by=2 It is, of course, possible to apply round robins and dynamic layers to this, just like any other drum sound. That is left as an exercise to the reader. Alternative approach The above approach was developed to be playable from an electronic drum kit controller. For keyboard controllers or sequencing, another approach is possible where instead of using a MIDI note to trigger a new stir every time the drummer would complete a circle, we hold down a long note for as long as we want to produce stirs (so, possibly for several measures, or even the entire duration of a song). We then use MIDI CC to crossfade between the layers to modulate the speed of the stir in order to create realism and rhythmic interest. In order to be able to do this, the samples will have to be looped, but as stated at the beginning, looping or crossfading noisy samples is very easy as there are no phase issues. We also set the loop_mode opcode to continuous instead of the one_shot setting used in the earlier approach. <group>key=26 loop_mode=continuous ampeg_release=0.25 <region>sample=snare_stir_speed_1.wav xfin_locc1=0 xfin_hicc1=31 xfout_locc1=32 xfout_hicc1=63 <region>sample=snare_stir_speed_2.wav xfin_locc1=32 xfin_hicc1=63 xfout_locc1=64 xfout_hicc1=95 <region>sample=snare_stir_speed_3.wav xfin_locc1=64 xfin_hicc1=95 xfout_locc1=96 xfout_hicc1=127 <region>sample=snare_stir_speed_4.wav xfin_locc1=96 xfin_hicc1=127 In practice, this approach has proven more difficult to use, with it being easy to sound obviously unrealistic by moving the MIDI CC parameter too quickly or staying at high values for too long. With care, however, it can produce realistic results, and it is extremely flexible. Further possibilities The brush flutter technique can be treated similarly to the base layer of the stirs. There is no need to layer faster and slower flutters. In theory, this approach could also be extended to other noisy, highly nonlinear sounds which can vary in duration - perhaps shakers. The main challenge there would be to record shakers shaking smoothly for an extended duration. It is also certainly possible to further improve the above model with more realism and playablity.","title":"Brush stirs"},{"location":"tutorials/brush_stirs/#recording-the-source-material","text":"For the purposes of this example, let's assume the source stirs are recorded at four speeds, with 1 being the slowest and 4 being the fastest. Speed 1 is slow enough that a full circle around the head of the drum is completed in more than 4 seconds. That's enough to fill a measure at 60 bpm and still have some sound left, so the user can start the next stir before the previous one ends, and thus achieve a continuous sound. Speed 4 is several circles per second, to match the speed at which the brush would be moving during the peak of an aggressive stir. Making the sound steady at this speed is a challenge. As for how long the recordings need to be, speed 1 needs to be long enough for the longest stir we want to be able to make. However, if tuning controls are to be applied, it's important to remember that pitching a sample up shortens it, so if the tuning range is to extend to one octave up, then a 10-second sample is the minimum to make a 5-second stir. Speeds 3 and 4 are not used thorughout the duration of a stir but only for peaks, and for the purposes of this example they can be half the length of speed 1.","title":"Recording the source material"},{"location":"tutorials/brush_stirs/#simple-stir-model","text":"We can make a very simple stir using speed 1 by playing the sample with loop_mode set to one_shot, like we normally would set it for a drum hit, and using a simple volume envelope to fade this sample in over a time, and then fade it out. <region>key=26 loop_mode=one_shot sample=snare_stir_speed_1.wav ampeg_attack=1.0 ampeg_decay=1.0 ampeg_sustain=0 The resulting volume envelope will look something like this. The illustrations are not precise, only general shapes. This is a good start, and we can add expression and realism by layering a faster speed on top of it near the stir's peak, with half the duration of the base layer. We use ampeg_delay to delay the start of the second layer by the same amount, so the peaks of both layers align in time. <region>key=26 loop_mode=one_shot sample=snare_stir_speed_1.wav ampeg_attack=1.0 ampeg_decay=1.0 ampeg_sustain=0 <region>key=26 loop_mode=one_shot sample=snare_stir_speed_3.wav ampeg_delay=0.5 ampeg_attack=0.5 ampeg_decay=0.5 ampeg_sustain=0","title":"Simple stir model"},{"location":"tutorials/brush_stirs/#modulating-stir-duration","text":"This has a fixed duration and is not flexible, but the stir length can easily be modulated by a single CC parameter changing all the envelope durations. Extremely short stirs, lasting only a small fraction of a second, are obviously not going to sound realistic, so we can use a minimum value to prevent that. Let's use CC1 (standard mod wheel). <region>key=26 loop_mode=one_shot sample=snare_stir_speed_1.wav ampeg_attack=0.1 ampeg_decay=0.1 ampeg_sustain=0 ampeg_attackcc1=0.4 ampeg_decaycc1=0.4 <region>key=26 loop_mode=one_shot sample=snare_stir_speed_3.wav ampeg_delay=0.05 ampeg_attack=0.05 ampeg_decay=0.05 ampeg_sustain=0 ampeg_delaycc1=0.25 ampeg_attackcc1=0.25 ampeg_decaycc1=0.25","title":"Modulating stir duration"},{"location":"tutorials/brush_stirs/#making-the-shape-more-realistic","text":"Drummers testing the above model have asked for some adjustments to make it sound more realistic. One is to make the first half of the base layer steadier. This can be done very easily by shortening the attack and adding a hold time to the envelope, ensuring that they still add up to the same amount of time that the faster layer's delay and attack, so the peak will remain aligned at all values of the modulation parameter. The attack stage should generally be shorter than the hold stage. <region>key=26 loop_mode=one_shot sample=snare_stir_speed_1.wav ampeg_attack=0.05 ampeg_hold=0.05 ampeg_decay=0.1 ampeg_sustain=0 ampeg_attackcc1=0.05 ampeg_holdcc1=0.35 ampeg_decaycc1=0.4 <region>key=26 loop_mode=one_shot sample=snare_stir_speed_3.wav ampeg_delay=0.05 ampeg_attack=0.05 ampeg_decay=0.05 ampeg_sustain=0 ampeg_delaycc1=0.25 ampeg_attackcc1=0.25 ampeg_decaycc1=0.25 Also, the peak should be sharper and more accented than it is with linear envelopes. Changing the envelope curves accomplishes this, though the initial attack envelope of the base layer can remain linear. The below values seem like a decent start. <region>key=26 loop_mode=one_shot sample=snare_stir_speed_1.wav ampeg_attack=0.05 ampeg_hold=0.05 ampeg_decay=0.1 ampeg_sustain=0 ampeg_attackcc1=0.05 ampeg_holdcc1=0.35 ampeg_decaycc1=0.4 ampeg_attack_shape=0.0 ampeg_decay_shape=-1.4 <region>key=26 loop_mode=one_shot sample=snare_stir_speed_3.wav ampeg_delay=0.05 ampeg_attack=0.05 ampeg_decay=0.05 ampeg_sustain=0 ampeg_delaycc1=0.25 ampeg_attackcc1=0.25 ampeg_decaycc1=0.25 ampeg_attack_shape=3.5 ampeg_decay_shape=-1.4","title":"Making the shape more realistic"},{"location":"tutorials/brush_stirs/#adjusting-the-envelope-shapes","text":"The above fixed envelope shapes are good for medium tempos and energy levels, but for slow tempos the flat envelope shapes actually work quite well, and more energetic tracks might sound better with even sharper envelope peaks. It would be nice to adjust the envelope curve shapes with MIDI CC, but it is not currently possible to do this. It's possible to work around this by crossfading sharp-envelope and flat-envelope regions, or use locc/hicc to select between several pre-baked envelope shapes . Here's an example of the latter method. <group>key=26 loop_mode=one_shot <region>hicc100=42 sample=snare_stir_speed_1.wav ampeg_attack=0.05 ampeg_hold=0.05 ampeg_decay=0.1 ampeg_sustain=0 ampeg_attackcc1=0.05 ampeg_holdcc1=0.35 ampeg_decaycc1=0.4 ampeg_attack_shape=0.0 ampeg_decay_shape=0.0 <region>hicc100=42 sample=snare_stir_speed_3.wav ampeg_delay=0.05 ampeg_attack=0.05 ampeg_decay=0.05 ampeg_sustain=0 ampeg_delaycc1=0.25 ampeg_attackcc1=0.25 ampeg_decaycc1=0.25 ampeg_attack_shape=0.0 ampeg_decay_shape=0.0 <region>locc100=43 hicc100=86 sample=snare_stir_speed_1.wav ampeg_attack=0.05 ampeg_hold=0.05 ampeg_decay=0.1 ampeg_sustain=0 ampeg_attackcc1=0.05 ampeg_holdcc1=0.35 ampeg_decaycc1=0.4 ampeg_attack_shape=0.0 ampeg_decay_shape=-1.4 <region>locc100=43 hicc100=86 sample=snare_stir_speed_3.wav ampeg_delay=0.05 ampeg_attack=0.05 ampeg_decay=0.05 ampeg_sustain=0 ampeg_delaycc1=0.25 ampeg_attackcc1=0.25 ampeg_decaycc1=0.25 ampeg_attack_shape=3.5 ampeg_decay_shape=-1.4 <region>locc100=87 sample=snare_stir_speed_1.wav ampeg_attack=0.05 ampeg_hold=0.05 ampeg_decay=0.1 ampeg_sustain=0 ampeg_attackcc1=0.05 ampeg_holdcc1=0.35 ampeg_decaycc1=0.4 ampeg_attack_shape=0.0 ampeg_decay_shape=-3.5 <region>locc100=87 sample=snare_stir_speed_3.wav ampeg_delay=0.05 ampeg_attack=0.05 ampeg_decay=0.05 ampeg_sustain=0 ampeg_delaycc1=0.25 ampeg_attackcc1=0.25 ampeg_decaycc1=0.25 ampeg_attack_shape=5.2 ampeg_decay_shape=-3.5","title":"Adjusting the envelope shapes"},{"location":"tutorials/brush_stirs/#adding-ornaments","text":"So far, we have a stir with adjustable duration and shape which peaks halfway through. More complex patterns can have more than one peak, though. A simple way to emulate that is to use a differnet MIDI note to trigger short ornaments which will add a brief extra sound to the stir, thus emulating a momentary acceleration of the brush. We can use one of the higher stir speeds for this. <group>key=27 loop_mode=one_shot sample=snare_stir_speed_2.wav ampeg_attack=0.05 ampeg_decay=0.05 ampeg_sustain=0 ampeg_attackcc1=0.2 ampeg_decaycc1=0.2 <region>hicc100=42 ampeg_attack_shape=0.0 ampeg_decay_shape=0.0 <region>hicc100=42 ampeg_attack_shape=3.5 ampeg_decay_shape=-1.4 <region>hicc100=42 ampeg_attack_shape=5.2 ampeg_decay_shape=-3.5","title":"Adding ornaments"},{"location":"tutorials/brush_stirs/#accents","text":"We can also create accents, which are similar to the typical stir but peak much more quickly and use faster speeds. In pracitce, they can be used either as short, aggressive stirs, or added on top of basic stirs to create more complex patterns. The difference in the SFZ here is that the attack curve shape can be applied to the attack portion as well, and there is no hold stage in the envelope. <group>key=28 loop_mode=one_shot <region>hicc100=42 sample=snare_stir_speed_2.wav ampeg_attack=0.05 ampeg_decay=0.1 ampeg_sustain=0 ampeg_attackcc1=0.05 ampeg_decaycc1=0.4 ampeg_attack_shape=0.0 ampeg_decay_shape=0.0 <region>hicc100=42 sample=snare_stir_speed_4.wav ampeg_attack=0.05 ampeg_decay=0.05 ampeg_sustain=0 ampeg_attackcc1=0.05 ampeg_decaycc1=0.2 ampeg_attack_shape=0.0 ampeg_decay_shape=0.0 <region>locc100=43 hicc100=86 sample=snare_stir_speed_2.wav ampeg_attack=0.05 ampeg_decay=0.1 ampeg_sustain=0 ampeg_attackcc1=0.05 ampeg_decaycc1=0.4 ampeg_attack_shape=3.5 ampeg_decay_shape=-1.4 <region>locc100=43 hicc100=86 sample=snare_stir_speed_4.wav ampeg_attack=0.05 ampeg_decay=0.05 ampeg_sustain=0 ampeg_attackcc1=0.05 ampeg_decaycc1=0.2 ampeg_attack_shape=3.5 ampeg_decay_shape=-1.4 <region>locc100=87 sample=snare_stir_speed_2.wav ampeg_attack=0.05 ampeg_decay=0.1 ampeg_sustain=0 ampeg_attackcc1=0.05 ampeg_decaycc1=0.4 ampeg_attack_shape=5.2 ampeg_decay_shape=-3.5 <region>locc100=87 sample=snare_stir_speed_4.wav ampeg_attack=0.05 ampeg_decay=0.05 ampeg_sustain=0 ampeg_attackcc1=0.05 ampeg_decaycc1=0.2 ampeg_attack_shape=5.2 ampeg_decay_shape=-3.5","title":"Accents"},{"location":"tutorials/brush_stirs/#muting","text":"As all the above sounds have loop_mode set to one_shot, triggering a note causes the sound to play until the volume envelope drops to zero. If ending a stir earlier than that is required, we can use polyphony groups. The group and off_by opcodes are the key ones here. We can use them to make stirs self-mute, so that triggering a new stir will mute any previously playing stirs, as well as add a key which produces no sound, using silence instead of a sample , but is in the same mute groups, so triggering this key will mute any stir or accent currently playing. This key can be used to stop stirs early. Note that, as usual, separate groups are needed for layers which are to play simultaneously, and if there are multiple microphone positions then those would need separate groups as well. In the below example we also have stirs mute accents, and vice versa, although the ornaments are left out of the mute groups and can be layered on top of other sounds without muting them. For a more sophisticated use of mute groups with other pieces of the drum kit, please see cymbal muting . <global>loop_mode=one_shot off_mode=normal ampeg_release=0.1 ampeg_releasecc1=0.2 <group>key=26 <region>hicc100=42 sample=snare_stir_speed_1.wav ampeg_attack=0.05 ampeg_hold=0.05 ampeg_decay=0.1 ampeg_sustain=0 ampeg_attackcc1=0.05 ampeg_holdcc1=0.35 ampeg_decaycc1=0.4 ampeg_attack_shape=0.0 ampeg_decay_shape=0.0 group=1 off_by=1 <region>hicc100=42 sample=snare_stir_speed_3.wav ampeg_delay=0.05 ampeg_attack=0.05 ampeg_decay=0.05 ampeg_sustain=0 ampeg_delaycc1=0.25 ampeg_attackcc1=0.25 ampeg_decaycc1=0.25 ampeg_attack_shape=0.0 ampeg_decay_shape=0.0 group=2 off_by=2 <region>locc100=43 hicc100=86 sample=snare_stir_speed_1.wav ampeg_attack=0.05 ampeg_hold=0.05 ampeg_decay=0.1 ampeg_sustain=0 ampeg_attackcc1=0.05 ampeg_holdcc1=0.35 ampeg_decaycc1=0.4 ampeg_attack_shape=0.0 ampeg_decay_shape=-1.4 group=1 off_by=1 <region>locc100=43 hicc100=86 sample=snare_stir_speed_3.wav ampeg_delay=0.05 ampeg_attack=0.05 ampeg_decay=0.05 ampeg_sustain=0 ampeg_delaycc1=0.25 ampeg_attackcc1=0.25 ampeg_decaycc1=0.25 ampeg_attack_shape=3.5 ampeg_decay_shape=-1.4 group=2 off_by=2 <region>locc100=87 sample=snare_stir_speed_1.wav ampeg_attack=0.05 ampeg_hold=0.05 ampeg_decay=0.1 ampeg_sustain=0 ampeg_attackcc1=0.05 ampeg_holdcc1=0.35 ampeg_decaycc1=0.4 ampeg_attack_shape=0.0 ampeg_decay_shape=-3.5 group=1 off_by=1 <region>locc100=87 sample=snare_stir_speed_3.wav ampeg_delay=0.05 ampeg_attack=0.05 ampeg_decay=0.05 ampeg_sustain=0 ampeg_delaycc1=0.25 ampeg_attackcc1=0.25 ampeg_decaycc1=0.25 ampeg_attack_shape=5.2 ampeg_decay_shape=-3.5 group=2 off_by=2 <group>key=27 sample=snare_stir_speed_2.wav ampeg_attack=0.05 ampeg_decay=0.05 ampeg_sustain=0 ampeg_attackcc1=0.2 ampeg_decaycc1=0.2 <region>hicc100=42 ampeg_attack_shape=0.0 ampeg_decay_shape=0.0 <region>hicc100=42 ampeg_attack_shape=3.5 ampeg_decay_shape=-1.4 <region>hicc100=42 ampeg_attack_shape=5.2 ampeg_decay_shape=-3.5 <group>key=28 <region>hicc100=42 sample=snare_stir_speed_2.wav ampeg_attack=0.05 ampeg_decay=0.1 ampeg_sustain=0 ampeg_attackcc1=0.05 ampeg_decaycc1=0.4 ampeg_attack_shape=0.0 ampeg_decay_shape=0.0 group=1 off_by=1 <region>hicc100=42 sample=snare_stir_speed_4.wav ampeg_attack=0.05 ampeg_decay=0.05 ampeg_sustain=0 ampeg_attackcc1=0.05 ampeg_decaycc1=0.2 ampeg_attack_shape=0.0 ampeg_decay_shape=0.0 group=2 off_by=2 <region>locc100=43 hicc100=86 sample=snare_stir_speed_2.wav ampeg_attack=0.05 ampeg_decay=0.1 ampeg_sustain=0 ampeg_attackcc1=0.05 ampeg_decaycc1=0.4 ampeg_attack_shape=3.5 ampeg_decay_shape=-1.4 group=1 off_by=1 <region>locc100=43 hicc100=86 sample=snare_stir_speed_4.wav ampeg_attack=0.05 ampeg_decay=0.05 ampeg_sustain=0 ampeg_attackcc1=0.05 ampeg_decaycc1=0.2 ampeg_attack_shape=3.5 ampeg_decay_shape=-1.4 group=2 off_by=2 <region>locc100=87 sample=snare_stir_speed_2.wav ampeg_attack=0.05 ampeg_decay=0.1 ampeg_sustain=0 ampeg_attackcc1=0.05 ampeg_decaycc1=0.4 ampeg_attack_shape=5.2 ampeg_decay_shape=-3.5 group=1 off_by=1 <region>locc100=87 sample=snare_stir_speed_4.wav ampeg_attack=0.05 ampeg_decay=0.05 ampeg_sustain=0 ampeg_attackcc1=0.05 ampeg_decaycc1=0.2 ampeg_attack_shape=5.2 ampeg_decay_shape=-3.5 group=2 off_by=2 <group>key=29 sample=*silence <region>group=1 off_by=1 <region>group=2 off_by=2 It is, of course, possible to apply round robins and dynamic layers to this, just like any other drum sound. That is left as an exercise to the reader.","title":"Muting"},{"location":"tutorials/brush_stirs/#alternative-approach","text":"The above approach was developed to be playable from an electronic drum kit controller. For keyboard controllers or sequencing, another approach is possible where instead of using a MIDI note to trigger a new stir every time the drummer would complete a circle, we hold down a long note for as long as we want to produce stirs (so, possibly for several measures, or even the entire duration of a song). We then use MIDI CC to crossfade between the layers to modulate the speed of the stir in order to create realism and rhythmic interest. In order to be able to do this, the samples will have to be looped, but as stated at the beginning, looping or crossfading noisy samples is very easy as there are no phase issues. We also set the loop_mode opcode to continuous instead of the one_shot setting used in the earlier approach. <group>key=26 loop_mode=continuous ampeg_release=0.25 <region>sample=snare_stir_speed_1.wav xfin_locc1=0 xfin_hicc1=31 xfout_locc1=32 xfout_hicc1=63 <region>sample=snare_stir_speed_2.wav xfin_locc1=32 xfin_hicc1=63 xfout_locc1=64 xfout_hicc1=95 <region>sample=snare_stir_speed_3.wav xfin_locc1=64 xfin_hicc1=95 xfout_locc1=96 xfout_hicc1=127 <region>sample=snare_stir_speed_4.wav xfin_locc1=96 xfin_hicc1=127 In practice, this approach has proven more difficult to use, with it being easy to sound obviously unrealistic by moving the MIDI CC parameter too quickly or staying at high values for too long. With care, however, it can produce realistic results, and it is extremely flexible.","title":"Alternative approach"},{"location":"tutorials/brush_stirs/#further-possibilities","text":"The brush flutter technique can be treated similarly to the base layer of the stirs. There is no need to layer faster and slower flutters. In theory, this approach could also be extended to other noisy, highly nonlinear sounds which can vary in duration - perhaps shakers. The main challenge there would be to record shakers shaking smoothly for an extended duration. It is also certainly possible to further improve the above model with more realism and playablity.","title":"Further possibilities"},{"location":"tutorials/cymbal_muting/","text":"A lot of the information in this article deals with implementing sampled hi-hats and cymbals in general, and although the code examples are in SFZ, the principles should also apply to other samplers, or even synthesized cymbals. Muting previously played notes is important with monophonic instruments, such as flutes or trumpets. With hi-hats, it is also crucial to sounding like a hi-hat - an open hi-hat hit will be muted in real life when the hi-hat pedal is closed. Let's start with a simple hi-hat with closed hit, foot chik, half-open and open samples, with the latter two on the same key and degree of openness selected by MIDI CC 4 - the common hi-hat pedal assignment in electronic drum kits. <region>key=42 sample=hh_closed.wav <region>key=44 sample=hh_chik.wav <region>key=46 sample=hh_half_open.wav hicc4=63 <region>key=46 sample=hh_open.wav locc4=64 Simple self-muting The above hi-hat has no muting implemented, so playing a closed hit after an open one would result in the open hit unrealistically continuing to ring. The simplest way to take care of that is to put all the regions in the same \u2039group\u203a and use off_by to make that group mute itself - that will mean any hi-hat hit will mute any currently playing hi-hat hit. Setting off_mode to normal and using ampeg_release or off_time to set the time it takes for the previous sample to fade out also helps this sound a bit more natural. <group> off_mode=normal ampeg_release=0.07 <region>key=42 sample=hh_closed.wav group=1 off_by=1 <region>key=44 sample=hh_chik.wav group=1 off_by=1 <region>key=46 sample=hh_half_open.wav hicc4=63 group=1 off_by=1 <region>key=46 sample=hh_open.wav locc4=64 group=1 off_by=1 Hierarchical self-muting This is the way many virtual drum kits work, but it is not fully satisfactory if, for example, playing a ride pattern on an open hi-hat. Things do start getting more complicated here, though, and many developers feel that it's enough to stop here, just implement the above rules, and have a reasonably working virtual hi-hat. For those who want more, however, Peter L. Jones has developed a hierarchy of muting, where hits which are more closed mute hits that are more open, but hits which are more open do not mute hits which are more closed. Hits also don't mute hits with the same degree of openness. So, chiks mute all hits, closed hits mute any partially open hits but not chiks or closed hits etc. With this amount of degrees of openness, half-open hits would mute open hits, and open hits would mute nothing. So, we need to put each hi-hat articulation in a different group. This, however, means we need a group which mutes several other groups, and regions in a group cannot have multiple or varying off_by values. So, what we have to do is use silence - either the silence* setting of sample ARIA extension, or an actual file of a short silence. Note that the silence samples also have to have off_by settings the same as the hi-hat samples in their mute group. Also, since group 1 doesn't mute anything, we don't need to add any silence regions to that group. Note that the group opcode used here and the \u2039group\u203a header are completely separate concepts - \"group\" for the remainder of this article refers to the opcode, not the header, though group headers are also used in the code examples. <group> // Here are the hi-hat samples off_mode=normal ampeg_release=0.07 <region>key=42 sample=hh_closed.wav group=3 off_by=4 <region>key=44 sample=hh_chik.wav group=4 <region>key=46 sample=hh_half_open.wav hicc4=63 group=2 off_by=3 <region>key=46 sample=hh_open.wav locc4=64 group=1 off_by=2 <group>group=2 off_by=3 // The range which mutes open hi-hats - that is, everything except open sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 <region> key=42 <region> key=44 <region> key=46 hicc4=63 <group>group=3 off_by=4 // The range which mutes half-open and open hi-hats - that is, closed and chik loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 <region> key=42 <region> key=44 <group>group=4 // The range which mutes closed, half-open and open hi-hats - that is, just chik loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 <region> key=44 Special treatment of foot splashes The above isn't perfect - for example, fully opening up a hi-hat after playing a hard half-open hit in the real world would stop the clashes between the top and bottom, effectively stopping a half-open sound and replacing it with quieter open ringing - but it is a reasonable compromise covering various degrees of openness. Also, the more degrees of openness there are, the more groups will be needed. There are, however, more hi-hat articulations possible. One which has special behavior when it comes to muting is the foot splash - closing the hi-hat with the pedal, then quickly reopening it. This articulation needs to mute itself, because playing one foot splash after another involves closing the hi-hat, which will mute the ringing. Whether the splash should mute other types of hits is an open question, however. Splashes, especially gentler ones, involve only momentary contact of the cymbal edges and not complete closure. Whether an open hi-hat hit followed by a splash sounds better when the splash mutes the open hit is left as a decision to the reader. The below example has the splash muting everything else, except for pedal chiks, because it invovles closing the hi-hat fully. So, if a kit has foot splash samples (for which there is no standard general MIDI note assignment, so let's use 54 here - an octave above the chik, though in general MIDI that's supposed to be the cowbell note), we'd need to set up one more group, and have that mute itself. It will also need to be muted by all other types of hi-hat hits, except for fully open hits. <group> //Here are the hi-hat samples off_mode=normal ampeg_release=0.07 <region>key=42 sample=hh_closed.wav group=4 off_by=5 <region>key=44 sample=hh_chik.wav group=5 <region>key=46 sample=hh_half_open.wav hicc4=63 group=3 off_by=4 <region>key=46 sample=hh_open.wav locc4=64 group=2 off_by=3 <region>key=54 sample=hh_splash.wav group=1 off_by=1 <group>group=1 off_by=1 //The range which mutes foot splashes - everything except open and foot splash //Foot splash mutes itself, but this group does not include the foot splash key //That's because the foot splash samples themselves are in the same group sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 <region> key=42 <region> key=44 <region> key=46 <group>group=3 off_by=4 //The range which mutes open hi-hats - that is, everything except open sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 <region> key=42 <region> key=44 <region> key=46 hicc4=63 <region> key=54 <group>group=4 off_by=5 //The range which mutes half-open and open hi-hats - that is, closed, chik and foot splash sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 <region> key=42 <region> key=44 <region> key=54 <group>group=5 //The range which mutes closed, half-open and open hi-hats - that is, just chik and foot splash sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 <region> key=44 <region> key=54 Limiting polyphony This works reasonably well. Another potential refinement is to also avoid excessive buildup when the more open articulations (which with some hi-hat pairs can ring for upwards of 20 seconds), while still allowing enough for ride patterns on an open hi-hat to sound right. We can do this by using the polyphony opcode to put a limit on the number of polyphony voices used by a specific group. Note this must be set for the silence regions, also, so that every region in a group will have the same off_by and polyphony as all the other regions in that group. Polyphony of 4 for the open hi-hats and 3 for the half-open are judgment calls. Drier cymbals and articulations with less sustain will generally sound realistic with lower numbers here, and brushes might need a lower number than sticks. Limiting the polyphony for the more closed articulations is not necessary in practice, unless playing unrealistically dense trap hi-hat patterns, because they don't ring very long anyway. Limiting the polyphony for the foot splash is not necessary at all, because it mutes itself. <group> //Here are the hi-hat samples off_mode=normal ampeg_release=0.07 <region>key=42 sample=hh_closed.wav group=4 off_by=5 <region>key=44 sample=hh_chik.wav group=5 <region>key=46 sample=hh_half_open.wav hicc4=63 group=3 off_by=4 polyphony=3 <region>key=46 sample=hh_open.wav locc4=64 group=2 off_by=3 polyphony=4 <region>key=54 sample=hh_splash.wav group=1 off_by=1 <group>group=1 off_by=1 //The range which mutes foot splashes //All sounds except open mute foot splashes, but this group does not include the foot splash key //That's because the foot splash samples are in the same group, and will mute anything else sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 <region> key=42 <region> key=44 <region> key=46 hicc4=63 <group>group=3 off_by=4 polyphony=3 //The range which mutes open hi-hats - that is, everything except open and foot splash sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 <region> key=42 <region> key=44 <region> key=46 hicc4=63 <region> key=54 <group>group=4 off_by=5 //The range which mutes half-open and open hi-hats - that is, closed, chik and foot splash sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 <region> key=42 <region> key=44 <region> key=54 <group>group=5 //The range which mutes closed, half-open and open hi-hats - that is, just chik and foot splash sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 <region> key=44 Edge cases The above can sound strange when a hard hi-hat hit is being muted by a much quieter one. If the hit doing the muting is both quiet and short, it can be practically inaudible, and the resulting sound seems to only be the open hit, suddenly fading out. This is especially risky if using amp_veltrack set to 100, which will make hits with very low velocity extremely quiet, or if the lowest dynamic layers of more closed hits and foot chiks are recorded very quietly. Lowering amp_veltrack for the lowest velocity layers is one potential way to reduce this problem, as is setting amp_velcurve_1 to some value around 0.2 to 0.5 (higher values if there are more dynamic layers). In real life, however, a hard open hi-hat hit would have reduced in volume before the start of the soft closed hit, as the pedal needs to be closed before a closed hit can be made. This would, of course, cause many edge clashes along the way, which we do not have a way to emulate. However, it is possible to use the pedal's MIDI CC to make the open sample quieter outside of the range where the open hi-hat sample would be triggered. This can be done by modulating the hi-hat's amplitude , and applying a \u2039curve\u203a which will keep the amplitude at 100% unless the pedal is a good deal more closed than it was when the sample was triggered. <group> //Here are the hi-hat samples off_mode=normal ampeg_release=0.07 <region>key=42 sample=hh_closed.wav group=4 off_by=5 <region>key=44 sample=hh_chik.wav group=5 <region>key=46 sample=hh_half_open.wav hicc4=63 group=3 off_by=4 amplitude_cc4=100 amplitude_curvecc4=21 amplitude_smoothcc4=150 <region>key=46 sample=hh_open.wav locc4=64 group=2 off_by=3 amplitude_cc4=100 amplitude_curvecc4=21 amplitude_smoothcc4=150 <region>key=54 sample=hh_splash.wav group=1 off_by=1 <curve>curve_index=21 v000=0.13 v037=0.8 v077=1 v127=1 <curve>curve_index=22 v000=0.1 v037=0.7 v077=1 v127=1 Using smoothing on the amplitude modulation helps avoid sudden jumps, though playing an open hit, closing the hi-hat pedal most of the way and then reopening it will still result in obviously unrealistic volume fluctuations. So, this is not a perfect solution by any means. It's probably better to do this by using a volume envelope and using CC4 to modulate its decay time, with the sustain set to a low level. and the ampeg_dynamic opcode set to 1 so that moving the pedal will cause the decay time to be recalculated. However, that has not been tested yet, as the author's test kit was already using envelopes on the hi-hat to emulate drier cymbals. Also, applying this to splash samples, which involve the pedal starting closed and opening rapidly, is another problem which requires a solution. Multimic samples So far, each hi-hat articulation has only one sample, which will obviously not be the case in most virtual drum kits. This does not add much complexity, though, as the samples for each degree of openness simply need to all be in the same group. All half-open samples, for example, including all round robins, all velocity layers, can share the same group. If there are separate articulations for each degree of openness, such as shank, tip and bell, those can also all be on the same group. Brushes, sticks and mallets can often also share the same groups, unless the brushes need lower polyphony numbers. However, if there are separate samples for different microphones and the groups are self-muting, they will need to be in different groups. In the current example, only the footsplash is self-muting, but if using the simpler rules where all hi-hat articulations mute all others, all groups are self-muting. So, having separate close hi-hat mic and a stereo overhead pair would mean twice as many of those groups (assuming the stereo overheads are in the L and R channel of the same sample), and close hi-hat, stereo overheads, close room and far room would mean four times as many. The polyphony numbers for groups which have polyphony will also have to be multiplied by the same factor. Here is an example with close and overhead, with slightly longer fadeout times for the more distant overhead mics: <group> //Here are the hi-hat samples off_mode=normal <region>key=42 sample=hh_closed_close.wav group=4 off_by=5 ampeg_release=0.12 <region>key=42 sample=hh_closed_oh.wav group=4 off_by=5 ampeg_release=0.2 <region>key=44 sample=hh_chik_close.wav group=5 ampeg_release=0.12 <region>key=44 sample=hh_chik_oh.wav group=5 ampeg_release=0.2 <region>key=46 sample=hh_half_open_close.wav hicc4=63 group=3 off_by=4 polyphony=6 ampeg_release=0.12 <region>key=46 sample=hh_half_open_oh.wav hicc4=63 group=3 off_by=4 polyphony=6 ampeg_release=0.2 <region>key=46 sample=hh_open_close.wav locc4=64 group=2 off_by=3 polyphony=8 ampeg_release=0.12 <region>key=46 sample=hh_open_oh.wav locc4=64 group=2 off_by=3 polyphony=8 ampeg_release=0.2 <region>key=54 sample=hh_splash_close.wav group=1 off_by=1 ampeg_release=0.12 <region>key=54 sample=hh_splash_oh.wav group=11 off_by=11 ampeg_release=0.2 <group>group=1 off_by=1 //The range which mutes foot splashes for the close mic //All sounds except open mute foot splashes, but this group does not include the foot splash key //That's because the foot splash samples are in the same group, and will mute anything else sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 <region> key=42 <region> key=44 <region> key=46 hicc4=63 <group>group=11 off_by=11 //The range which mutes foot splashes for the overhead mics //All sounds mute foot splashes, but this group does not include the foot splash key //That's because the foot splash samples are in the same group, and will mute anything else sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 <region> key=42 <region> key=44 <region> key=46 hicc4=63 <group>group=3 off_by=4 polyphony=3 //The range which mutes open hi-hats for both close and overhead mics - that is, everything except open sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 <region> key=42 <region> key=44 <region> key=46 hicc4=63 <region> key=54 <group>group=4 off_by=5 //The range which mutes half-open and open hi-hats - that is, closed, chik and foot splash sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 <region> key=42 <region> key=44 <region> key=54 <group>group=5 //The range which mutes closed, half-open and open hi-hats - that is, just chik sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 <region> key=44 Header organization That is as complex as it gets, though there are a few minor points to be aware of. Many drum kits with round robins will set seq_length at the \u2039global\u203a level, and in those cases, the silence regions would only trigger for the first hit in the round robin sequence, unless they have seq_length set to 1 to override the global setting. Also, the \u2039master\u203a header level and #include statement are useful ARIA extensions for keeping deeply sampled hi-hat mappings organized. Cymbals other than hi-hats Cymbals other than hi-hats are simpler, but there are two considerations when muting those. One is limiting polyphony, which is especially important with cymbals intended for playing rolls, and with jazz ride cymbals (rock/metal rides which primarily use the bell articulation, not as much). The other is that it's also possible to record separate choke samples, and have those mute everything else. A ride with bell, bow and edge articulations, choke samples and overhead and room mics might be set up like below. Note that while each articulation has its own groups and different polyphony limits, all articulations for each mic have the same off_by value, which is the group value of the choke samples for that mic. It would not be necessary to have this many groups to implement muting, but this setup would also allow a mapping using only the overhead mics and no room mic to be created without breaking anything, as each mic's samples have separate groups. Having different polyphony numbers for different mics can result in an inconsistent sound, so it is not recommended. <group> off_mode=normal //Bow hits <region> key=51 group=30 off_by=33 polyphony=5 ampeg_release=0.3 sample=ride_bow_oh.wav <region> key=51 group=40 off_by=43 polyphony=5 ampeg_release=0.4 sample=ride_bow_rm.wav //Bell hits <region> key=53 group=31 off_by=33 polyphony=4 ampeg_release=0.3 sample=ride_bell_oh.wav <region> key=53 group=41 off_by=43 polyphony=4 ampeg_release=0.4 sample=ride_bell_rm.wav //Edge hits (crashes) <region> key=59 group=32 off_by=33 polyphony=6 ampeg_release=0.3 sample=ride_edge_oh.wav <region> key=59 group=42 off_by=43 polyphony=6 ampeg_release=0.4 sample=ride_edge_rm.wav //Edge chokes <region> key=71 ampeg_attack=0.15 group=33 sample=ride_choke_oh.wav <region> key=71 ampeg_attack=0.15 group=43 sample=ride_choke_rm.wav It is also possible to use note_polyphony here, which has the advantage of allowing note_selfmask to be used. This is good when a hard hit is followed by several lighter ones on the same cymbal - using polyphony, the quieter hits will mute the loud one when the polyphony limit is reached, which can result in the louder hit's sustain suddenly and unrealistically vanishing. However, this can cause problems with hi-hats where one MIDI note needs to trigger several silence groups as well. This is why Virtuosity Drums has the hi-hat regions set with note_polyphony=MAX, though there might be a better way. Note_polyphony is also separated by keys; while the polyphony limit under a group can be tracked together for several keys under one group, note_polyphony is tracked separately for each MIDI note value. The above example modified to use note_polyphony instead of polyphony would look like this: <group> off_mode=normal //Bow hits <region> key=51 group=30 off_by=33 note_polyphony=5 ampeg_release=0.3 sample=ride_bow_oh.wav <region> key=51 group=40 off_by=43 note_polyphony=5 ampeg_release=0.4 sample=ride_bow_rm.wav //Bell hits <region> key=53 group=31 off_by=33 note_polyphony=4 ampeg_release=0.3 sample=ride_bell_oh.wav <region> key=53 group=41 off_by=43 note_polyphony=4 ampeg_release=0.4 sample=ride_bell_rm.wav //Edge hits (crashes) <region> key=59 group=32 off_by=33 note_polyphony=6 ampeg_release=0.3 sample=ride_edge_oh.wav <region> key=59 group=42 off_by=43 note_polyphony=6 ampeg_release=0.4 sample=ride_edge_rm.wav //Edge chokes <region> key=71 ampeg_attack=0.15 group=33 sample=ride_choke_oh.wav <region> key=71 ampeg_attack=0.15 group=43 sample=ride_choke_rm.wav Another approach to limiting polyphony If there is no need have a choke group, it's possible to limit the polyphony of a cymbal in a way which is more controllable, by having it self-mute but making the fadeout time of the previous samples long. This cannot be done when chokes are required, because chokes need a fast fadeout, but it is another option which allows how much dense patterns on a cymbal will build up to be controlled with a MIDI CC parameter - the polyphony opcode cannot be modulated by MIDI CC, but ampeg_release can. Here is how that might work using CC 100 to modulate the time, with different maximum times for different articulations, as in general edge hits will build up the most and bell hits the least. Of course, it's not very possible to modulate the buildup of a cymbal in the real world, but that doesn't mean it can't be useful in the sampled world. <group> off_mode=normal ampeg_release=0.1 //Bow hits <region> key=51 group=30 off_by=30 ampeg_release_oncc100=5 sample=ride_bow_oh.wav <region> key=51 group=40 off_by=40 ampeg_release_oncc100=5.7 sample=ride_bow_rm.wav //Bell hits <region> key=53 group=31 off_by=31 ampeg_release_oncc100=3 sample=ride_bell_oh.wav <region> key=53 group=41 off_by=41 ampeg_release_oncc100=3.5 sample=ride_bell_rm.wav //Edge hits (crashes) <region> key=59 group=32 off_by=32 ampeg_release_oncc100=7 sample=ride_edge_oh.wav <region> key=59 group=42 off_by=42 ampeg_release_oncc100=8 sample=ride_edge_rm.wav Deep-sampled hi-hat example Putting most of the above knowledge together into a complex example can result in long SFZ files, but the principles themselves remain the same. The mapping for a deeply sampled hi-hat with tightly closed, closed, loosely closed, quarter open, half open, open, foot chik, foot splash and pedal return samples, with separate shank and tip hits for tightly closed, closed, loosely closed and quarter open might look like this: <control> //Key assignments - hi-hat #define $htclstkey 42 #define $htchkkey 44 #define $htvartkey 46 #define $htclsskey 54 #define $htsplkey 56 #define $htvarskey 58 #define $htretkey 68 //Hi-hat CC ranges - order for keyboard/sequencing use //E-kit pedal should be backwards #define $ht_lo_hi_init 127 #define $ht_cl_lo 0 #define $ht_cl_hi 25 #define $ht_lc_lo 26 #define $ht_lc_hi 51 #define $ht_qo_lo 52 #define $ht_qo_hi 76 #define $ht_ho_lo 77 #define $ht_ho_hi 102 #define $ht_open_lo 103 #define $ht_open_hi 127 #define $mg_open_lo 0 #define $mg_open_hi 102 #define $mg_ho_lo 0 #define $mg_ho_hi 76 #define $mg_qo_lo 0 #define $mg_qo_hi 51 #define $mg_lc_lo 0 #define $mg_lc_hi 25 label_cc4=Hi-hat position label_cc100=Hi-hat close label_cc101=Hi-hat OH set_cc4=$ht_lo_hi_init set_cc100=40 set_cc101=100 <global> loop_mode=one_shot seq_length=4 ampeg_release=0.12 amp_velcurve_1=0.4 //Foot chiks <master> key=$htchkkey amplitude_cc100=100 #include \"mappings/hihat_14/ht_chik_cl.sfz\" <master> key=$htchkkey amplitude_cc101=100 #include \"mappings/hihat_14/ht_chik_oh.sfz\" //Stick tip hits <master> key=$htclstkey amplitude_cc100=100 group=11 off_by=10 #include \"mappings/hihat_14/ht_tc_cl.sfz\" <master> key=$htclstkey amplitude_cc101=100 group=21 off_by=20 ampeg_release=0.2 #include \"mappings/hihat_14/ht_tc_oh.sfz\" <master> key=$htvartkey amplitude_cc100=100 group=12 off_by=11 locc4=$ht_cl_lo hicc4=$ht_cl_hi #include \"mappings/hihat_14/ht_cl_cl.sfz\" <master> key=$htvartkey amplitude_cc101=100 group=22 off_by=21 ampeg_release=0.2 locc4=$ht_cl_lo hicc4=$ht_cl_hi #include \"mappings/hihat_14/ht_cl_oh.sfz\" <master> key=$htvartkey amplitude_cc100=100 group=13 off_by=12 locc4=$ht_lc_lo hicc4=$ht_lc_hi #include \"mappings/hihat_14/ht_lc_cl.sfz\" <master> key=$htvartkey amplitude_cc101=100 group=23 off_by=22 ampeg_release=0.2 locc4=$ht_lc_lo hicc4=$ht_lc_hi #include \"mappings/hihat_14/ht_lc_oh.sfz\" <master> key=$htvartkey amplitude_cc100=100 group=14 off_by=13 locc4=$ht_qo_lo hicc4=$ht_qo_hi #include \"mappings/hihat_14/ht_qo_cl.sfz\" <master> key=$htvartkey amplitude_cc101=100 group=24 off_by=23 ampeg_release=0.2 locc4=$ht_qo_lo hicc4=$ht_qo_hi #include \"mappings/hihat_14/ht_qo_oh.sfz\" <master> key=$htvartkey amplitude_cc100=100 group=15 off_by=14 amplitude_oncc4=100 amplitude_curvecc4=21 amplitude_smoothcc4=150 locc4=$ht_ho_lo hicc4=$ht_ho_hi #include \"mappings/hihat_14/ht_ho_cl.sfz\" <master> key=$htvartkey amplitude_cc101=100 group=25 off_by=24 ampeg_release=0.2 amplitude_oncc4=100 amplitude_curvecc4=21 amplitude_smoothcc4=150 locc4=$ht_ho_lo hicc4=$ht_ho_hi #include \"mappings/hihat_14/ht_ho_oh.sfz\" <master> key=$htvartkey amplitude_cc100=100 group=16 off_by=15 amplitude_oncc4=100 amplitude_curvecc4=22 amplitude_smoothcc4=150 locc4=$ht_open_lo hicc4=$ht_open_hi #include \"mappings/hihat_14/ht_open_cl.sfz\" <master> key=$htvartkey amplitude_cc101=100 group=26 off_by=25 ampeg_release=0.2 amplitude_oncc4=100 amplitude_curvecc4=22 amplitude_smoothcc4=150 locc4=$ht_open_lo hicc4=$ht_open_hi #include \"mappings/hihat_14/ht_open_oh.sfz\" //Stick shank hits <master> key=$htclsskey amplitude_cc100=100 group=11 off_by=10 #include \"mappings/hihat_14/ht_tc_s_cl.sfz\" <master> key=$htclsskey amplitude_cc101=100 group=21 off_by=20 ampeg_release=0.2 #include \"mappings/hihat_14/ht_tc_s_oh.sfz\" <master> key=$htvarskey amplitude_cc100=100 group=12 off_by=11 locc4=$ht_cl_lo hicc4=$ht_cl_hi #include \"mappings/hihat_14/ht_cl_s_cl.sfz\" <master> key=$htvarskey amplitude_cc101=100 group=22 off_by=21 ampeg_release=0.2 locc4=$ht_cl_lo hicc4=$ht_cl_hi #include \"mappings/hihat_14/ht_cl_s_oh.sfz\" <master> key=$htvarskey amplitude_cc100=100 group=13 off_by=12 locc4=$ht_lc_lo hicc4=$ht_lc_hi #include \"mappings/hihat_14/ht_lc_s_cl.sfz\" <master> key=$htvarskey amplitude_cc101=10 group=23 off_by=22 ampeg_release=0.2 locc4=$ht_lc_lo hicc4=$ht_lc_hi #include \"mappings/hihat_14/ht_lc_s_oh.sfz\" <master> key=$htvarskey amplitude_cc100=100 group=14 off_by=13 locc4=$ht_qo_lo hicc4=$ht_qo_hi #include \"mappings/hihat_14/ht_qo_s_cl.sfz\" <master> key=$htvarskey amplitude_cc101=100 group=24 off_by=23 ampeg_release=0.2 locc4=$ht_qo_lo hicc4=$ht_qo_hi #include \"mappings/hihat_14/ht_qo_s_oh.sfz\" <master> key=$htvarskey amplitude_cc100=100 group=15 off_by=14 amplitude_oncc4=100 amplitude_curvecc4=21 amplitude_smoothcc4=150 locc4=$ht_ho_lo hicc4=$ht_ho_hi #include \"mappings/hihat_14/ht_ho_cl.sfz\" <master> key=$htvarskey amplitude_cc101=100 group=25 off_by=24 ampeg_release=0.2 amplitude_oncc4=100 amplitude_curvecc4=21 amplitude_smoothcc4=150 locc4=$ht_ho_lo hicc4=$ht_ho_hi #include \"mappings/hihat_14/ht_ho_oh.sfz\" <master> key=$htvarskey amplitude_cc100=100 group=16 off_by=15 amplitude_oncc4=100 amplitude_curvecc4=22 amplitude_smoothcc4=150 locc4=$ht_open_lo hicc4=$ht_open_hi #include \"mappings/hihat_14/ht_open_cl.sfz\" <master> key=$htvarskey amplitude_cc101=100 group=26 off_by=25 ampeg_release=0.2 amplitude_oncc4=100 amplitude_curvecc4=22 amplitude_smoothcc4=150 locc4=$ht_open_lo hicc4=$ht_open_hi #include \"mappings/hihat_14/ht_open_oh.sfz\" //Footsplashes are the only self-muting group <master> key=$htsplkey amplitude_cc100=100 group=17 off_by=17 #include \"mappings/hihat_14/ht_footspl_cl.sfz\" <master> key=$htsplkey amplitude_cc101=100 group=27 off_by=27 ampeg_release=0.2 #include \"mappings/hihat_14/ht_footspl_oh.sfz\" //Stick hits on the shaft, not involved in muting <master> key=$htperckey amplitude_cc100=100 #include \"mappings/hihat_14/ht_perc_cl.sfz\" <master> key=$htperckey amplitude_cc101=100 #include \"mappings/hihat_14/ht_perc_oh.sfz\" //Hi hat pedal return noises, muted by anything else <master> key=$htretkey amplitude_cc100=100 group=18 off_by=17 #include \"mappings/hihat_14/ht_return_cl.sfz\" <master> key=$htretkey amplitude_cc101=100 group=28 off_by=27 ampeg_release=0.2 #include \"mappings/hihat_14/ht_return_oh.sfz\" //Hat mute silence groups <master> seq_length=1 <group> group=18 //The range which mutes hi-hat pedal return noises //Everything except themselves sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 off_by=17 <region> key=$htclstkey <region> key=$htchkkey <region> key=$htvartkey <region> key=$htclsskey <region> key=$htvarskey <region> key=$htsplkey <group> group=17 //The range which mutes footsplashes //Everything except pedal return noises and open //Footsplashes are the only articulation which mutes itself //Splash also mutes splash, but key=$htsplkey is not part of this silence group //Instead splash regions themselves are marked with group=17 also //Kind of a kludge, but keeps the silence from instantly muting the splash //while allowing a subsequent splash to mute the current splash sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 off_by=17 <region> key=$htclstkey <region> key=$htchkkey <region> key=$htvartkey locc4=$mg_open_lo hicc4=$mg_open_hi <region> key=$htclsskey <region> key=$htvarskey locc4=$mg_open_lo hicc4=$mg_open_hi <group> group=15 //The range which mutes open hi-hats //Everything except pedal return noises and open //Just like the footsplash mute group, except the footsplash key is in this too sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 off_by=14 <region> key=$htclstkey <region> key=$htchkkey <region> key=$htvartkey locc4=$mg_open_lo hicc4=$mg_open_hi <region> key=$htclsskey <region> key=$htvarskey locc4=$mg_open_lo hicc4=$mg_open_hi <region> key=$htsplkey <region> key=$htsplkey <group> group=14 //The range which mutes half open hi-hats //Everything except open and half-open sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 off_by=13 <region> key=$htclstkey <region> key=$htchkkey <region> key=$htvartkey locc4=$mg_ho_lo hicc4=$mg_ho_hi <region> key=$htclsskey <region> key=$htvarskey locc4=$mg_ho_lo hicc4=$mg_ho_hi <region> key=$htsplkey <group> group=13 //The range which mutes quarter open hi-hats //Everything except open, half-open and quarter open sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 off_by=12 <region> key=$htclstkey <region> key=$htchkkey <region> key=$htvartkey locc4=$mg_qo_lo hicc4=$mg_qo_hi <region> key=$htclsskey <region> key=$htvarskey locc4=$mg_qo_lo hicc4=$mg_qo_hi <region> key=$htsplkey <group> group=12 //The range which mutes loosely closed hi-hats //Everything except open, half-open, quarter open and loosely closed sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 off_by=11 <region> key=$htclstkey <region> key=$htchkkey <region> key=$htvartkey locc4=$mg_lc_lo hicc4=$mg_lc_hi <region> key=$htclsskey <region> key=$htvarskey locc4=$mg_lc_lo hicc4=$mg_lc_hi <region> key=$htsplkey <group> group=11 //The range which mutes regular closed hi-hats //Just foot chik, tightly closed and footsplash sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 off_by=10 <region> key=$htclstkey <region> key=$htchkkey <region> key=$htclsskey <region> key=$htsplkey <group> group=10 //The range which mutes tightly closed hi-hats - just foot chik and footsplash sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 <region> key=$htchkkey <region> key=$htsplkey <group> group=28 //The range which mutes hi-hat pedal return noises //Everything except themselves sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 off_by=27 <region> key=$htclstkey <region> key=$htchkkey <region> key=$htvartkey <region> key=$htclsskey <region> key=$htvarskey <region> key=$htsplkey <group> group=27 //The range which mutes footsplashes //Everything except pedal return noises and open //Footsplashes are the only articulation which mutes itself //Splash also mutes splash, but key=$htsplkey is not part of this silence group //Instead splash regions themselves are marked with group=27 also //Kind of a kludge, but keeps the silence from instantly muting the splash //while allowing a subsequent splash to mute the current splash sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 off_by=27 <region> key=$htclstkey <region> key=$htchkkey <region> key=$htvartkey locc4=$mg_open_lo hicc4=$mg_open_hi <region> key=$htclsskey <region> key=$htvarskey locc4=$mg_open_lo hicc4=$mg_open_hi <group> group=25 //The range which mutes open hi-hats //Everything except pedal return noises and open //Just like the footsplash mute group, except the footsplash key is in this too sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 off_by=24 <region> key=$htclstkey <region> key=$htchkkey <region> key=$htvartkey locc4=$mg_open_lo hicc4=$mg_open_hi <region> key=$htclsskey <region> key=$htvarskey locc4=$mg_open_lo hicc4=$mg_open_hi <region> key=$htsplkey <region> key=$htsplkey <group> group=24 //The range which mutes half open hi-hats //Everything except open and half-open sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 off_by=23 <region> key=$htclstkey <region> key=$htchkkey <region> key=$htvartkey locc4=$mg_ho_lo hicc4=$mg_ho_hi <region> key=$htclsskey <region> key=$htvarskey locc4=$mg_ho_lo hicc4=$mg_ho_hi <region> key=$htsplkey <group> group=23 //The range which mutes quarter open hi-hats //Everything except open, half-open and quarter open sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 off_by=22 <region> key=$htclstkey <region> key=$htchkkey <region> key=$htvartkey locc4=$mg_qo_lo hicc4=$mg_qo_hi <region> key=$htclsskey <region> key=$htvarskey locc4=$mg_qo_lo hicc4=$mg_qo_hi <region> key=$htsplkey <group> group=22 //The range which mutes loosely closed hi-hats //Everything except open, half-open, quarter open and loosely closed sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 off_by=21 <region> key=$htclstkey <region> key=$htchkkey <region> key=$htvartkey locc4=$mg_lc_lo hicc4=$mg_lc_hi <region> key=$htclsskey <region> key=$htvarskey locc4=$mg_lc_lo hicc4=$mg_lc_hi <region> key=$htsplkey <group> group=21 //The range which mutes regular closed hi-hats //Just foot chik, tightly closed and footsplash sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 off_by=20 <region> key=$htclstkey <region> key=$htchkkey <region> key=$htclsskey <region> key=$htsplkey <group> group=20 //The range which mutes tightly closed hi-hats - just foot chik and footsplash sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 <region> key=$htchkkey <region> key=$htsplkey <curve>curve_index=21 v000=0.13 v037=0.8 v077=1 v127=1 <curve>curve_index=22 v000=0.1 v037=0.7 v077=1 v127=1","title":"Cymbal muting"},{"location":"tutorials/cymbal_muting/#simple-self-muting","text":"The above hi-hat has no muting implemented, so playing a closed hit after an open one would result in the open hit unrealistically continuing to ring. The simplest way to take care of that is to put all the regions in the same \u2039group\u203a and use off_by to make that group mute itself - that will mean any hi-hat hit will mute any currently playing hi-hat hit. Setting off_mode to normal and using ampeg_release or off_time to set the time it takes for the previous sample to fade out also helps this sound a bit more natural. <group> off_mode=normal ampeg_release=0.07 <region>key=42 sample=hh_closed.wav group=1 off_by=1 <region>key=44 sample=hh_chik.wav group=1 off_by=1 <region>key=46 sample=hh_half_open.wav hicc4=63 group=1 off_by=1 <region>key=46 sample=hh_open.wav locc4=64 group=1 off_by=1","title":"Simple self-muting"},{"location":"tutorials/cymbal_muting/#hierarchical-self-muting","text":"This is the way many virtual drum kits work, but it is not fully satisfactory if, for example, playing a ride pattern on an open hi-hat. Things do start getting more complicated here, though, and many developers feel that it's enough to stop here, just implement the above rules, and have a reasonably working virtual hi-hat. For those who want more, however, Peter L. Jones has developed a hierarchy of muting, where hits which are more closed mute hits that are more open, but hits which are more open do not mute hits which are more closed. Hits also don't mute hits with the same degree of openness. So, chiks mute all hits, closed hits mute any partially open hits but not chiks or closed hits etc. With this amount of degrees of openness, half-open hits would mute open hits, and open hits would mute nothing. So, we need to put each hi-hat articulation in a different group. This, however, means we need a group which mutes several other groups, and regions in a group cannot have multiple or varying off_by values. So, what we have to do is use silence - either the silence* setting of sample ARIA extension, or an actual file of a short silence. Note that the silence samples also have to have off_by settings the same as the hi-hat samples in their mute group. Also, since group 1 doesn't mute anything, we don't need to add any silence regions to that group. Note that the group opcode used here and the \u2039group\u203a header are completely separate concepts - \"group\" for the remainder of this article refers to the opcode, not the header, though group headers are also used in the code examples. <group> // Here are the hi-hat samples off_mode=normal ampeg_release=0.07 <region>key=42 sample=hh_closed.wav group=3 off_by=4 <region>key=44 sample=hh_chik.wav group=4 <region>key=46 sample=hh_half_open.wav hicc4=63 group=2 off_by=3 <region>key=46 sample=hh_open.wav locc4=64 group=1 off_by=2 <group>group=2 off_by=3 // The range which mutes open hi-hats - that is, everything except open sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 <region> key=42 <region> key=44 <region> key=46 hicc4=63 <group>group=3 off_by=4 // The range which mutes half-open and open hi-hats - that is, closed and chik loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 <region> key=42 <region> key=44 <group>group=4 // The range which mutes closed, half-open and open hi-hats - that is, just chik loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 <region> key=44","title":"Hierarchical self-muting"},{"location":"tutorials/cymbal_muting/#special-treatment-of-foot-splashes","text":"The above isn't perfect - for example, fully opening up a hi-hat after playing a hard half-open hit in the real world would stop the clashes between the top and bottom, effectively stopping a half-open sound and replacing it with quieter open ringing - but it is a reasonable compromise covering various degrees of openness. Also, the more degrees of openness there are, the more groups will be needed. There are, however, more hi-hat articulations possible. One which has special behavior when it comes to muting is the foot splash - closing the hi-hat with the pedal, then quickly reopening it. This articulation needs to mute itself, because playing one foot splash after another involves closing the hi-hat, which will mute the ringing. Whether the splash should mute other types of hits is an open question, however. Splashes, especially gentler ones, involve only momentary contact of the cymbal edges and not complete closure. Whether an open hi-hat hit followed by a splash sounds better when the splash mutes the open hit is left as a decision to the reader. The below example has the splash muting everything else, except for pedal chiks, because it invovles closing the hi-hat fully. So, if a kit has foot splash samples (for which there is no standard general MIDI note assignment, so let's use 54 here - an octave above the chik, though in general MIDI that's supposed to be the cowbell note), we'd need to set up one more group, and have that mute itself. It will also need to be muted by all other types of hi-hat hits, except for fully open hits. <group> //Here are the hi-hat samples off_mode=normal ampeg_release=0.07 <region>key=42 sample=hh_closed.wav group=4 off_by=5 <region>key=44 sample=hh_chik.wav group=5 <region>key=46 sample=hh_half_open.wav hicc4=63 group=3 off_by=4 <region>key=46 sample=hh_open.wav locc4=64 group=2 off_by=3 <region>key=54 sample=hh_splash.wav group=1 off_by=1 <group>group=1 off_by=1 //The range which mutes foot splashes - everything except open and foot splash //Foot splash mutes itself, but this group does not include the foot splash key //That's because the foot splash samples themselves are in the same group sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 <region> key=42 <region> key=44 <region> key=46 <group>group=3 off_by=4 //The range which mutes open hi-hats - that is, everything except open sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 <region> key=42 <region> key=44 <region> key=46 hicc4=63 <region> key=54 <group>group=4 off_by=5 //The range which mutes half-open and open hi-hats - that is, closed, chik and foot splash sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 <region> key=42 <region> key=44 <region> key=54 <group>group=5 //The range which mutes closed, half-open and open hi-hats - that is, just chik and foot splash sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 <region> key=44 <region> key=54","title":"Special treatment of foot splashes"},{"location":"tutorials/cymbal_muting/#limiting-polyphony","text":"This works reasonably well. Another potential refinement is to also avoid excessive buildup when the more open articulations (which with some hi-hat pairs can ring for upwards of 20 seconds), while still allowing enough for ride patterns on an open hi-hat to sound right. We can do this by using the polyphony opcode to put a limit on the number of polyphony voices used by a specific group. Note this must be set for the silence regions, also, so that every region in a group will have the same off_by and polyphony as all the other regions in that group. Polyphony of 4 for the open hi-hats and 3 for the half-open are judgment calls. Drier cymbals and articulations with less sustain will generally sound realistic with lower numbers here, and brushes might need a lower number than sticks. Limiting the polyphony for the more closed articulations is not necessary in practice, unless playing unrealistically dense trap hi-hat patterns, because they don't ring very long anyway. Limiting the polyphony for the foot splash is not necessary at all, because it mutes itself. <group> //Here are the hi-hat samples off_mode=normal ampeg_release=0.07 <region>key=42 sample=hh_closed.wav group=4 off_by=5 <region>key=44 sample=hh_chik.wav group=5 <region>key=46 sample=hh_half_open.wav hicc4=63 group=3 off_by=4 polyphony=3 <region>key=46 sample=hh_open.wav locc4=64 group=2 off_by=3 polyphony=4 <region>key=54 sample=hh_splash.wav group=1 off_by=1 <group>group=1 off_by=1 //The range which mutes foot splashes //All sounds except open mute foot splashes, but this group does not include the foot splash key //That's because the foot splash samples are in the same group, and will mute anything else sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 <region> key=42 <region> key=44 <region> key=46 hicc4=63 <group>group=3 off_by=4 polyphony=3 //The range which mutes open hi-hats - that is, everything except open and foot splash sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 <region> key=42 <region> key=44 <region> key=46 hicc4=63 <region> key=54 <group>group=4 off_by=5 //The range which mutes half-open and open hi-hats - that is, closed, chik and foot splash sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 <region> key=42 <region> key=44 <region> key=54 <group>group=5 //The range which mutes closed, half-open and open hi-hats - that is, just chik and foot splash sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 <region> key=44","title":"Limiting polyphony"},{"location":"tutorials/cymbal_muting/#edge-cases","text":"The above can sound strange when a hard hi-hat hit is being muted by a much quieter one. If the hit doing the muting is both quiet and short, it can be practically inaudible, and the resulting sound seems to only be the open hit, suddenly fading out. This is especially risky if using amp_veltrack set to 100, which will make hits with very low velocity extremely quiet, or if the lowest dynamic layers of more closed hits and foot chiks are recorded very quietly. Lowering amp_veltrack for the lowest velocity layers is one potential way to reduce this problem, as is setting amp_velcurve_1 to some value around 0.2 to 0.5 (higher values if there are more dynamic layers). In real life, however, a hard open hi-hat hit would have reduced in volume before the start of the soft closed hit, as the pedal needs to be closed before a closed hit can be made. This would, of course, cause many edge clashes along the way, which we do not have a way to emulate. However, it is possible to use the pedal's MIDI CC to make the open sample quieter outside of the range where the open hi-hat sample would be triggered. This can be done by modulating the hi-hat's amplitude , and applying a \u2039curve\u203a which will keep the amplitude at 100% unless the pedal is a good deal more closed than it was when the sample was triggered. <group> //Here are the hi-hat samples off_mode=normal ampeg_release=0.07 <region>key=42 sample=hh_closed.wav group=4 off_by=5 <region>key=44 sample=hh_chik.wav group=5 <region>key=46 sample=hh_half_open.wav hicc4=63 group=3 off_by=4 amplitude_cc4=100 amplitude_curvecc4=21 amplitude_smoothcc4=150 <region>key=46 sample=hh_open.wav locc4=64 group=2 off_by=3 amplitude_cc4=100 amplitude_curvecc4=21 amplitude_smoothcc4=150 <region>key=54 sample=hh_splash.wav group=1 off_by=1 <curve>curve_index=21 v000=0.13 v037=0.8 v077=1 v127=1 <curve>curve_index=22 v000=0.1 v037=0.7 v077=1 v127=1 Using smoothing on the amplitude modulation helps avoid sudden jumps, though playing an open hit, closing the hi-hat pedal most of the way and then reopening it will still result in obviously unrealistic volume fluctuations. So, this is not a perfect solution by any means. It's probably better to do this by using a volume envelope and using CC4 to modulate its decay time, with the sustain set to a low level. and the ampeg_dynamic opcode set to 1 so that moving the pedal will cause the decay time to be recalculated. However, that has not been tested yet, as the author's test kit was already using envelopes on the hi-hat to emulate drier cymbals. Also, applying this to splash samples, which involve the pedal starting closed and opening rapidly, is another problem which requires a solution.","title":"Edge cases"},{"location":"tutorials/cymbal_muting/#multimic-samples","text":"So far, each hi-hat articulation has only one sample, which will obviously not be the case in most virtual drum kits. This does not add much complexity, though, as the samples for each degree of openness simply need to all be in the same group. All half-open samples, for example, including all round robins, all velocity layers, can share the same group. If there are separate articulations for each degree of openness, such as shank, tip and bell, those can also all be on the same group. Brushes, sticks and mallets can often also share the same groups, unless the brushes need lower polyphony numbers. However, if there are separate samples for different microphones and the groups are self-muting, they will need to be in different groups. In the current example, only the footsplash is self-muting, but if using the simpler rules where all hi-hat articulations mute all others, all groups are self-muting. So, having separate close hi-hat mic and a stereo overhead pair would mean twice as many of those groups (assuming the stereo overheads are in the L and R channel of the same sample), and close hi-hat, stereo overheads, close room and far room would mean four times as many. The polyphony numbers for groups which have polyphony will also have to be multiplied by the same factor. Here is an example with close and overhead, with slightly longer fadeout times for the more distant overhead mics: <group> //Here are the hi-hat samples off_mode=normal <region>key=42 sample=hh_closed_close.wav group=4 off_by=5 ampeg_release=0.12 <region>key=42 sample=hh_closed_oh.wav group=4 off_by=5 ampeg_release=0.2 <region>key=44 sample=hh_chik_close.wav group=5 ampeg_release=0.12 <region>key=44 sample=hh_chik_oh.wav group=5 ampeg_release=0.2 <region>key=46 sample=hh_half_open_close.wav hicc4=63 group=3 off_by=4 polyphony=6 ampeg_release=0.12 <region>key=46 sample=hh_half_open_oh.wav hicc4=63 group=3 off_by=4 polyphony=6 ampeg_release=0.2 <region>key=46 sample=hh_open_close.wav locc4=64 group=2 off_by=3 polyphony=8 ampeg_release=0.12 <region>key=46 sample=hh_open_oh.wav locc4=64 group=2 off_by=3 polyphony=8 ampeg_release=0.2 <region>key=54 sample=hh_splash_close.wav group=1 off_by=1 ampeg_release=0.12 <region>key=54 sample=hh_splash_oh.wav group=11 off_by=11 ampeg_release=0.2 <group>group=1 off_by=1 //The range which mutes foot splashes for the close mic //All sounds except open mute foot splashes, but this group does not include the foot splash key //That's because the foot splash samples are in the same group, and will mute anything else sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 <region> key=42 <region> key=44 <region> key=46 hicc4=63 <group>group=11 off_by=11 //The range which mutes foot splashes for the overhead mics //All sounds mute foot splashes, but this group does not include the foot splash key //That's because the foot splash samples are in the same group, and will mute anything else sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 <region> key=42 <region> key=44 <region> key=46 hicc4=63 <group>group=3 off_by=4 polyphony=3 //The range which mutes open hi-hats for both close and overhead mics - that is, everything except open sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 <region> key=42 <region> key=44 <region> key=46 hicc4=63 <region> key=54 <group>group=4 off_by=5 //The range which mutes half-open and open hi-hats - that is, closed, chik and foot splash sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 <region> key=42 <region> key=44 <region> key=54 <group>group=5 //The range which mutes closed, half-open and open hi-hats - that is, just chik sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 <region> key=44","title":"Multimic samples"},{"location":"tutorials/cymbal_muting/#header-organization","text":"That is as complex as it gets, though there are a few minor points to be aware of. Many drum kits with round robins will set seq_length at the \u2039global\u203a level, and in those cases, the silence regions would only trigger for the first hit in the round robin sequence, unless they have seq_length set to 1 to override the global setting. Also, the \u2039master\u203a header level and #include statement are useful ARIA extensions for keeping deeply sampled hi-hat mappings organized.","title":"Header organization"},{"location":"tutorials/cymbal_muting/#cymbals-other-than-hi-hats","text":"Cymbals other than hi-hats are simpler, but there are two considerations when muting those. One is limiting polyphony, which is especially important with cymbals intended for playing rolls, and with jazz ride cymbals (rock/metal rides which primarily use the bell articulation, not as much). The other is that it's also possible to record separate choke samples, and have those mute everything else. A ride with bell, bow and edge articulations, choke samples and overhead and room mics might be set up like below. Note that while each articulation has its own groups and different polyphony limits, all articulations for each mic have the same off_by value, which is the group value of the choke samples for that mic. It would not be necessary to have this many groups to implement muting, but this setup would also allow a mapping using only the overhead mics and no room mic to be created without breaking anything, as each mic's samples have separate groups. Having different polyphony numbers for different mics can result in an inconsistent sound, so it is not recommended. <group> off_mode=normal //Bow hits <region> key=51 group=30 off_by=33 polyphony=5 ampeg_release=0.3 sample=ride_bow_oh.wav <region> key=51 group=40 off_by=43 polyphony=5 ampeg_release=0.4 sample=ride_bow_rm.wav //Bell hits <region> key=53 group=31 off_by=33 polyphony=4 ampeg_release=0.3 sample=ride_bell_oh.wav <region> key=53 group=41 off_by=43 polyphony=4 ampeg_release=0.4 sample=ride_bell_rm.wav //Edge hits (crashes) <region> key=59 group=32 off_by=33 polyphony=6 ampeg_release=0.3 sample=ride_edge_oh.wav <region> key=59 group=42 off_by=43 polyphony=6 ampeg_release=0.4 sample=ride_edge_rm.wav //Edge chokes <region> key=71 ampeg_attack=0.15 group=33 sample=ride_choke_oh.wav <region> key=71 ampeg_attack=0.15 group=43 sample=ride_choke_rm.wav It is also possible to use note_polyphony here, which has the advantage of allowing note_selfmask to be used. This is good when a hard hit is followed by several lighter ones on the same cymbal - using polyphony, the quieter hits will mute the loud one when the polyphony limit is reached, which can result in the louder hit's sustain suddenly and unrealistically vanishing. However, this can cause problems with hi-hats where one MIDI note needs to trigger several silence groups as well. This is why Virtuosity Drums has the hi-hat regions set with note_polyphony=MAX, though there might be a better way. Note_polyphony is also separated by keys; while the polyphony limit under a group can be tracked together for several keys under one group, note_polyphony is tracked separately for each MIDI note value. The above example modified to use note_polyphony instead of polyphony would look like this: <group> off_mode=normal //Bow hits <region> key=51 group=30 off_by=33 note_polyphony=5 ampeg_release=0.3 sample=ride_bow_oh.wav <region> key=51 group=40 off_by=43 note_polyphony=5 ampeg_release=0.4 sample=ride_bow_rm.wav //Bell hits <region> key=53 group=31 off_by=33 note_polyphony=4 ampeg_release=0.3 sample=ride_bell_oh.wav <region> key=53 group=41 off_by=43 note_polyphony=4 ampeg_release=0.4 sample=ride_bell_rm.wav //Edge hits (crashes) <region> key=59 group=32 off_by=33 note_polyphony=6 ampeg_release=0.3 sample=ride_edge_oh.wav <region> key=59 group=42 off_by=43 note_polyphony=6 ampeg_release=0.4 sample=ride_edge_rm.wav //Edge chokes <region> key=71 ampeg_attack=0.15 group=33 sample=ride_choke_oh.wav <region> key=71 ampeg_attack=0.15 group=43 sample=ride_choke_rm.wav","title":"Cymbals other than hi-hats"},{"location":"tutorials/cymbal_muting/#another-approach-to-limiting-polyphony","text":"If there is no need have a choke group, it's possible to limit the polyphony of a cymbal in a way which is more controllable, by having it self-mute but making the fadeout time of the previous samples long. This cannot be done when chokes are required, because chokes need a fast fadeout, but it is another option which allows how much dense patterns on a cymbal will build up to be controlled with a MIDI CC parameter - the polyphony opcode cannot be modulated by MIDI CC, but ampeg_release can. Here is how that might work using CC 100 to modulate the time, with different maximum times for different articulations, as in general edge hits will build up the most and bell hits the least. Of course, it's not very possible to modulate the buildup of a cymbal in the real world, but that doesn't mean it can't be useful in the sampled world. <group> off_mode=normal ampeg_release=0.1 //Bow hits <region> key=51 group=30 off_by=30 ampeg_release_oncc100=5 sample=ride_bow_oh.wav <region> key=51 group=40 off_by=40 ampeg_release_oncc100=5.7 sample=ride_bow_rm.wav //Bell hits <region> key=53 group=31 off_by=31 ampeg_release_oncc100=3 sample=ride_bell_oh.wav <region> key=53 group=41 off_by=41 ampeg_release_oncc100=3.5 sample=ride_bell_rm.wav //Edge hits (crashes) <region> key=59 group=32 off_by=32 ampeg_release_oncc100=7 sample=ride_edge_oh.wav <region> key=59 group=42 off_by=42 ampeg_release_oncc100=8 sample=ride_edge_rm.wav","title":"Another approach to limiting polyphony"},{"location":"tutorials/cymbal_muting/#deep-sampled-hi-hat-example","text":"Putting most of the above knowledge together into a complex example can result in long SFZ files, but the principles themselves remain the same. The mapping for a deeply sampled hi-hat with tightly closed, closed, loosely closed, quarter open, half open, open, foot chik, foot splash and pedal return samples, with separate shank and tip hits for tightly closed, closed, loosely closed and quarter open might look like this: <control> //Key assignments - hi-hat #define $htclstkey 42 #define $htchkkey 44 #define $htvartkey 46 #define $htclsskey 54 #define $htsplkey 56 #define $htvarskey 58 #define $htretkey 68 //Hi-hat CC ranges - order for keyboard/sequencing use //E-kit pedal should be backwards #define $ht_lo_hi_init 127 #define $ht_cl_lo 0 #define $ht_cl_hi 25 #define $ht_lc_lo 26 #define $ht_lc_hi 51 #define $ht_qo_lo 52 #define $ht_qo_hi 76 #define $ht_ho_lo 77 #define $ht_ho_hi 102 #define $ht_open_lo 103 #define $ht_open_hi 127 #define $mg_open_lo 0 #define $mg_open_hi 102 #define $mg_ho_lo 0 #define $mg_ho_hi 76 #define $mg_qo_lo 0 #define $mg_qo_hi 51 #define $mg_lc_lo 0 #define $mg_lc_hi 25 label_cc4=Hi-hat position label_cc100=Hi-hat close label_cc101=Hi-hat OH set_cc4=$ht_lo_hi_init set_cc100=40 set_cc101=100 <global> loop_mode=one_shot seq_length=4 ampeg_release=0.12 amp_velcurve_1=0.4 //Foot chiks <master> key=$htchkkey amplitude_cc100=100 #include \"mappings/hihat_14/ht_chik_cl.sfz\" <master> key=$htchkkey amplitude_cc101=100 #include \"mappings/hihat_14/ht_chik_oh.sfz\" //Stick tip hits <master> key=$htclstkey amplitude_cc100=100 group=11 off_by=10 #include \"mappings/hihat_14/ht_tc_cl.sfz\" <master> key=$htclstkey amplitude_cc101=100 group=21 off_by=20 ampeg_release=0.2 #include \"mappings/hihat_14/ht_tc_oh.sfz\" <master> key=$htvartkey amplitude_cc100=100 group=12 off_by=11 locc4=$ht_cl_lo hicc4=$ht_cl_hi #include \"mappings/hihat_14/ht_cl_cl.sfz\" <master> key=$htvartkey amplitude_cc101=100 group=22 off_by=21 ampeg_release=0.2 locc4=$ht_cl_lo hicc4=$ht_cl_hi #include \"mappings/hihat_14/ht_cl_oh.sfz\" <master> key=$htvartkey amplitude_cc100=100 group=13 off_by=12 locc4=$ht_lc_lo hicc4=$ht_lc_hi #include \"mappings/hihat_14/ht_lc_cl.sfz\" <master> key=$htvartkey amplitude_cc101=100 group=23 off_by=22 ampeg_release=0.2 locc4=$ht_lc_lo hicc4=$ht_lc_hi #include \"mappings/hihat_14/ht_lc_oh.sfz\" <master> key=$htvartkey amplitude_cc100=100 group=14 off_by=13 locc4=$ht_qo_lo hicc4=$ht_qo_hi #include \"mappings/hihat_14/ht_qo_cl.sfz\" <master> key=$htvartkey amplitude_cc101=100 group=24 off_by=23 ampeg_release=0.2 locc4=$ht_qo_lo hicc4=$ht_qo_hi #include \"mappings/hihat_14/ht_qo_oh.sfz\" <master> key=$htvartkey amplitude_cc100=100 group=15 off_by=14 amplitude_oncc4=100 amplitude_curvecc4=21 amplitude_smoothcc4=150 locc4=$ht_ho_lo hicc4=$ht_ho_hi #include \"mappings/hihat_14/ht_ho_cl.sfz\" <master> key=$htvartkey amplitude_cc101=100 group=25 off_by=24 ampeg_release=0.2 amplitude_oncc4=100 amplitude_curvecc4=21 amplitude_smoothcc4=150 locc4=$ht_ho_lo hicc4=$ht_ho_hi #include \"mappings/hihat_14/ht_ho_oh.sfz\" <master> key=$htvartkey amplitude_cc100=100 group=16 off_by=15 amplitude_oncc4=100 amplitude_curvecc4=22 amplitude_smoothcc4=150 locc4=$ht_open_lo hicc4=$ht_open_hi #include \"mappings/hihat_14/ht_open_cl.sfz\" <master> key=$htvartkey amplitude_cc101=100 group=26 off_by=25 ampeg_release=0.2 amplitude_oncc4=100 amplitude_curvecc4=22 amplitude_smoothcc4=150 locc4=$ht_open_lo hicc4=$ht_open_hi #include \"mappings/hihat_14/ht_open_oh.sfz\" //Stick shank hits <master> key=$htclsskey amplitude_cc100=100 group=11 off_by=10 #include \"mappings/hihat_14/ht_tc_s_cl.sfz\" <master> key=$htclsskey amplitude_cc101=100 group=21 off_by=20 ampeg_release=0.2 #include \"mappings/hihat_14/ht_tc_s_oh.sfz\" <master> key=$htvarskey amplitude_cc100=100 group=12 off_by=11 locc4=$ht_cl_lo hicc4=$ht_cl_hi #include \"mappings/hihat_14/ht_cl_s_cl.sfz\" <master> key=$htvarskey amplitude_cc101=100 group=22 off_by=21 ampeg_release=0.2 locc4=$ht_cl_lo hicc4=$ht_cl_hi #include \"mappings/hihat_14/ht_cl_s_oh.sfz\" <master> key=$htvarskey amplitude_cc100=100 group=13 off_by=12 locc4=$ht_lc_lo hicc4=$ht_lc_hi #include \"mappings/hihat_14/ht_lc_s_cl.sfz\" <master> key=$htvarskey amplitude_cc101=10 group=23 off_by=22 ampeg_release=0.2 locc4=$ht_lc_lo hicc4=$ht_lc_hi #include \"mappings/hihat_14/ht_lc_s_oh.sfz\" <master> key=$htvarskey amplitude_cc100=100 group=14 off_by=13 locc4=$ht_qo_lo hicc4=$ht_qo_hi #include \"mappings/hihat_14/ht_qo_s_cl.sfz\" <master> key=$htvarskey amplitude_cc101=100 group=24 off_by=23 ampeg_release=0.2 locc4=$ht_qo_lo hicc4=$ht_qo_hi #include \"mappings/hihat_14/ht_qo_s_oh.sfz\" <master> key=$htvarskey amplitude_cc100=100 group=15 off_by=14 amplitude_oncc4=100 amplitude_curvecc4=21 amplitude_smoothcc4=150 locc4=$ht_ho_lo hicc4=$ht_ho_hi #include \"mappings/hihat_14/ht_ho_cl.sfz\" <master> key=$htvarskey amplitude_cc101=100 group=25 off_by=24 ampeg_release=0.2 amplitude_oncc4=100 amplitude_curvecc4=21 amplitude_smoothcc4=150 locc4=$ht_ho_lo hicc4=$ht_ho_hi #include \"mappings/hihat_14/ht_ho_oh.sfz\" <master> key=$htvarskey amplitude_cc100=100 group=16 off_by=15 amplitude_oncc4=100 amplitude_curvecc4=22 amplitude_smoothcc4=150 locc4=$ht_open_lo hicc4=$ht_open_hi #include \"mappings/hihat_14/ht_open_cl.sfz\" <master> key=$htvarskey amplitude_cc101=100 group=26 off_by=25 ampeg_release=0.2 amplitude_oncc4=100 amplitude_curvecc4=22 amplitude_smoothcc4=150 locc4=$ht_open_lo hicc4=$ht_open_hi #include \"mappings/hihat_14/ht_open_oh.sfz\" //Footsplashes are the only self-muting group <master> key=$htsplkey amplitude_cc100=100 group=17 off_by=17 #include \"mappings/hihat_14/ht_footspl_cl.sfz\" <master> key=$htsplkey amplitude_cc101=100 group=27 off_by=27 ampeg_release=0.2 #include \"mappings/hihat_14/ht_footspl_oh.sfz\" //Stick hits on the shaft, not involved in muting <master> key=$htperckey amplitude_cc100=100 #include \"mappings/hihat_14/ht_perc_cl.sfz\" <master> key=$htperckey amplitude_cc101=100 #include \"mappings/hihat_14/ht_perc_oh.sfz\" //Hi hat pedal return noises, muted by anything else <master> key=$htretkey amplitude_cc100=100 group=18 off_by=17 #include \"mappings/hihat_14/ht_return_cl.sfz\" <master> key=$htretkey amplitude_cc101=100 group=28 off_by=27 ampeg_release=0.2 #include \"mappings/hihat_14/ht_return_oh.sfz\" //Hat mute silence groups <master> seq_length=1 <group> group=18 //The range which mutes hi-hat pedal return noises //Everything except themselves sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 off_by=17 <region> key=$htclstkey <region> key=$htchkkey <region> key=$htvartkey <region> key=$htclsskey <region> key=$htvarskey <region> key=$htsplkey <group> group=17 //The range which mutes footsplashes //Everything except pedal return noises and open //Footsplashes are the only articulation which mutes itself //Splash also mutes splash, but key=$htsplkey is not part of this silence group //Instead splash regions themselves are marked with group=17 also //Kind of a kludge, but keeps the silence from instantly muting the splash //while allowing a subsequent splash to mute the current splash sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 off_by=17 <region> key=$htclstkey <region> key=$htchkkey <region> key=$htvartkey locc4=$mg_open_lo hicc4=$mg_open_hi <region> key=$htclsskey <region> key=$htvarskey locc4=$mg_open_lo hicc4=$mg_open_hi <group> group=15 //The range which mutes open hi-hats //Everything except pedal return noises and open //Just like the footsplash mute group, except the footsplash key is in this too sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 off_by=14 <region> key=$htclstkey <region> key=$htchkkey <region> key=$htvartkey locc4=$mg_open_lo hicc4=$mg_open_hi <region> key=$htclsskey <region> key=$htvarskey locc4=$mg_open_lo hicc4=$mg_open_hi <region> key=$htsplkey <region> key=$htsplkey <group> group=14 //The range which mutes half open hi-hats //Everything except open and half-open sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 off_by=13 <region> key=$htclstkey <region> key=$htchkkey <region> key=$htvartkey locc4=$mg_ho_lo hicc4=$mg_ho_hi <region> key=$htclsskey <region> key=$htvarskey locc4=$mg_ho_lo hicc4=$mg_ho_hi <region> key=$htsplkey <group> group=13 //The range which mutes quarter open hi-hats //Everything except open, half-open and quarter open sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 off_by=12 <region> key=$htclstkey <region> key=$htchkkey <region> key=$htvartkey locc4=$mg_qo_lo hicc4=$mg_qo_hi <region> key=$htclsskey <region> key=$htvarskey locc4=$mg_qo_lo hicc4=$mg_qo_hi <region> key=$htsplkey <group> group=12 //The range which mutes loosely closed hi-hats //Everything except open, half-open, quarter open and loosely closed sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 off_by=11 <region> key=$htclstkey <region> key=$htchkkey <region> key=$htvartkey locc4=$mg_lc_lo hicc4=$mg_lc_hi <region> key=$htclsskey <region> key=$htvarskey locc4=$mg_lc_lo hicc4=$mg_lc_hi <region> key=$htsplkey <group> group=11 //The range which mutes regular closed hi-hats //Just foot chik, tightly closed and footsplash sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 off_by=10 <region> key=$htclstkey <region> key=$htchkkey <region> key=$htclsskey <region> key=$htsplkey <group> group=10 //The range which mutes tightly closed hi-hats - just foot chik and footsplash sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 <region> key=$htchkkey <region> key=$htsplkey <group> group=28 //The range which mutes hi-hat pedal return noises //Everything except themselves sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 off_by=27 <region> key=$htclstkey <region> key=$htchkkey <region> key=$htvartkey <region> key=$htclsskey <region> key=$htvarskey <region> key=$htsplkey <group> group=27 //The range which mutes footsplashes //Everything except pedal return noises and open //Footsplashes are the only articulation which mutes itself //Splash also mutes splash, but key=$htsplkey is not part of this silence group //Instead splash regions themselves are marked with group=27 also //Kind of a kludge, but keeps the silence from instantly muting the splash //while allowing a subsequent splash to mute the current splash sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 off_by=27 <region> key=$htclstkey <region> key=$htchkkey <region> key=$htvartkey locc4=$mg_open_lo hicc4=$mg_open_hi <region> key=$htclsskey <region> key=$htvarskey locc4=$mg_open_lo hicc4=$mg_open_hi <group> group=25 //The range which mutes open hi-hats //Everything except pedal return noises and open //Just like the footsplash mute group, except the footsplash key is in this too sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 off_by=24 <region> key=$htclstkey <region> key=$htchkkey <region> key=$htvartkey locc4=$mg_open_lo hicc4=$mg_open_hi <region> key=$htclsskey <region> key=$htvarskey locc4=$mg_open_lo hicc4=$mg_open_hi <region> key=$htsplkey <region> key=$htsplkey <group> group=24 //The range which mutes half open hi-hats //Everything except open and half-open sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 off_by=23 <region> key=$htclstkey <region> key=$htchkkey <region> key=$htvartkey locc4=$mg_ho_lo hicc4=$mg_ho_hi <region> key=$htclsskey <region> key=$htvarskey locc4=$mg_ho_lo hicc4=$mg_ho_hi <region> key=$htsplkey <group> group=23 //The range which mutes quarter open hi-hats //Everything except open, half-open and quarter open sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 off_by=22 <region> key=$htclstkey <region> key=$htchkkey <region> key=$htvartkey locc4=$mg_qo_lo hicc4=$mg_qo_hi <region> key=$htclsskey <region> key=$htvarskey locc4=$mg_qo_lo hicc4=$mg_qo_hi <region> key=$htsplkey <group> group=22 //The range which mutes loosely closed hi-hats //Everything except open, half-open, quarter open and loosely closed sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 off_by=21 <region> key=$htclstkey <region> key=$htchkkey <region> key=$htvartkey locc4=$mg_lc_lo hicc4=$mg_lc_hi <region> key=$htclsskey <region> key=$htvarskey locc4=$mg_lc_lo hicc4=$mg_lc_hi <region> key=$htsplkey <group> group=21 //The range which mutes regular closed hi-hats //Just foot chik, tightly closed and footsplash sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 off_by=20 <region> key=$htclstkey <region> key=$htchkkey <region> key=$htclsskey <region> key=$htsplkey <group> group=20 //The range which mutes tightly closed hi-hats - just foot chik and footsplash sample=*silence loop_mode=loop_continuous off_mode=fast ampeg_attack=0 ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 <region> key=$htchkkey <region> key=$htsplkey <curve>curve_index=21 v000=0.13 v037=0.8 v077=1 v127=1 <curve>curve_index=22 v000=0.1 v037=0.7 v077=1 v127=1","title":"Deep-sampled hi-hat example"},{"location":"tutorials/drum_basics/","text":"SFZ has a lot of opcodes. No instrument uses all of them, though, and even highly complicated instruments with thousands of samples will usually only use a dozen or two different opcodes. In this guide, we'll talk about the opcodes needed to make a simple drum kit. If you have some drum samples, a text editor and an SFZ player, this should be all the knowledge you need to make a working SFZ mapping for those samples. Most of them will apply to most other instrument types as well. Later, we'll apply this knowledge to instruments such as piano, guitar, violin and flute. A very simple instrument to make would be an electronic drum kit with one sample for each sound. A functional mapping for an entire sampled drum machine using one-shot samples could be made using only the region header, and two opcodes sample and key . With kick, snare and hi-hat samples on their standard General MIDI notes, this could be the entire SFZ file: <region>key=36 sample=kick.wav <region>key=38 sample=snare.wav <region>key=42 sample=closedhat.wav This would work. Load this into an SFZ player, hit the C on MIDI note 36, and you get the kick sample playing. However, each sound would play only while a note is held. With drums it's usually a good idea to play the entire sample, so a very short note will result in a complete drum hit sounding. We can do that with the loop_mode opcode, which is also used for looping (as the name implies), but loop_mode=one_shot causes the sampler to play the entire sample from start to end, ignoring note off. <region>key=36 loop_mode=one_shot sample=kick.wav <region>key=38 loop_mode=one_shot sample=snare.wav <region>key=42 loop_mode=one_shot sample=closedhat.wav There's no need to set the one_shot for each region, though. We can simplify our life by using the \u2039global\u203a header like this: <global>loop_mode=one_shot <region>key=36 sample=kick.wav <region>key=38 sample=snare.wav <region>key=42 sample=closedhat.wav This is basically all that's required to take, for example, some of Wave Alchemy's very nice free samples of TR-808 or Tanzbar drum machines, and make a working SFZ mapping for them. Let's say what we have isn't drum machine samples, but acoustic drum samples. These sounds will have natural variation between hits - some depending on hit location, a lot depending on dynamics (how hard the drum is hit), and some just plain random. Let's ignore controlling hit location for now (drum samples mostly do ignore it), and focus on the other two. Dynamic variation can be captured by recording hits of various intensity, and organizing them into dynamic layers, also called velocity layers. If we have an acoustic kick drum sampled at four dynamics - quiet, kind of quiet, kind of loud and loud - we have four dynamic layers. Let's say the files for these layers are named like this: kick_vl1.wav kick_vl2.wav kick_vl3.wav kick_vl4.wav To trigger the quiet sample at low MIDI note velocities, we'd use the lovel and hivel opcodes like this: <region>key=36 lovel=0 hivel=31 sample=kick_vl1.wav All four hits with velocity ranges assigned, evenly splitting the full 0 to 127 velocity range into four, would look like this: <region>key=36 lovel=0 hivel=31 sample=kick_vl1.wav <region>key=36 lovel=32 hivel=63 sample=kick_vl2.wav <region>key=36 lovel=64 hivel=95 sample=kick_vl3.wav <region>key=36 lovel=96 hivel=127 sample=kick_vl4.wav This can, again, be simplified. The defalut value for lovel is 0, and for hivel it's 127, so we don't need to specify setting them to those numbers. Also, we can use a \u2039group\u203a header to make the key opcode the same across all four regions: <global>loop_mode=one_shot <group>key=36 <region>hivel=31 sample=kick_vl1.wav <region>lovel=32 hivel=63 sample=kick_vl2.wav <region>lovel=64 hivel=95 sample=kick_vl3.wav <region>lovel=96 sample=kick_vl4.wav However, the quiet samples will play quieter than they should - because of standard velocity tracking, each sample would play at full volume if the velocity was 127, but we actually need each sample to play at full volume at the velocity which is equal to its hivel value. This can be done in various ways, and the way we recommend is the amp_velcurve_N opcode, like this: <global>loop_mode=one_shot <group>key=36 <region>hivel=31 amp_velcurve_31=1 sample=kick_vl1.wav <region>lovel=32 hivel=63 amp_velcurve_63=1 sample=kick_vl2.wav <region>lovel=64 hivel=95 amp_velcurve_95=1 sample=kick_vl3.wav <region>lovel=96 sample=kick_vl4.wav Let's say that each dynamic layer also contains four round robins - four samples with roughly the same dynamic. This allows us to include some variation, and sound more natural - fast parts won't sound like a \"machine gun\". There are two basic ways to put round robins to use. One is to use the seq_length and seq_position opcodes, like this: <global>loop_mode=one_shot <group>key=36 hivel=31 amp_velcurve_31=1 seq_length=4 <region>seq_position=1 sample=kick_vl1_rr1.wav <region>seq_position=2 sample=kick_vl1_rr2.wav <region>seq_position=3 sample=kick_vl1_rr3.wav <region>seq_position=4 sample=kick_vl1_rr4.wav <group>key=36 lovel=32 hivel=63 amp_velcurve_63=1 seq_length=4 <region>seq_position=1 sample=kick_vl2_rr1.wav <region>seq_position=2 sample=kick_vl2_rr2.wav <region>seq_position=3 sample=kick_vl2_rr3.wav <region>seq_position=4 sample=kick_vl2_rr4.wav <group>key=36 lovel=64 hivel=95 amp_velcurve_95=1 seq_length=4 <region>seq_position=1 sample=kick_vl3_rr1.wav <region>seq_position=2 sample=kick_vl3_rr2.wav <region>seq_position=3 sample=kick_vl3_rr3.wav <region>seq_position=4 sample=kick_vl3_rr4.wav <group>key=36 lovel=96 seq_length=4 <region>seq_position=1 sample=kick_vl4_rr1.wav <region>seq_position=2 sample=kick_vl4_rr2.wav <region>seq_position=3 sample=kick_vl4_rr3.wav <region>seq_position=4 sample=kick_vl4_rr4.wav That's a kick drum with four dynamic layers and four sequential round robins. As you might have noticed, we're repeating the key=36 and seq_length=4 opcodes in every group. Those two opcodes could be moved to the global level if all we wanted was a kick drum, but as we're going to have other instruments with other keys and possibly different numbers of round robins, we kept them at the group level. The other way to use round robins is randomized, using the lorand and hirand opcodes. This will make the sample player generate a random number, then play the region whose lorand to hirand range includes that random number. Whether robins should be used in this random way or the above sequential way, the answer is \"it depends\". It seems that more instruments use sequential, though. This is how random round robins would be set up for our kick drum samples: <global>loop_mode=one_shot <group>key=36 hivel=31 amp_velcurve_31=1 <region>hirand=0.25 sample=kick_vl1_rr1.wav <region>lorand=0.25 hirand=0.5 sample=kick_vl1_rr2.wav <region>lorand=0.5 hirand=0.75 sample=kick_vl1_rr3.wav <region>lorand=0.75 sample=kick_vl1_rr4.wav <group>key=36 lovel=32 hivel=63 amp_velcurve_63=1 <region>hirand=0.25 sample=kick_vl2_rr1.wav <region>lorand=0.25 hirand=0.5 sample=kick_vl2_rr2.wav <region>lorand=0.5 hirand=0.75 sample=kick_vl2_rr3.wav <region>lorand=0.75 sample=kick_vl2_rr4.wav <group>key=36 lovel=64 hivel=95 amp_velcurve_95=1 <region>hirand=0.25 sample=kick_vl3_rr1.wav <region>lorand=0.25 hirand=0.5 sample=kick_vl3_rr2.wav <region>lorand=0.5 hirand=0.75 sample=kick_vl3_rr3.wav <region>lorand=0.75 sample=kick_vl3_rr4.wav <group>key=36 lovel=96 <region>hirand=0.25 sample=kick_vl4_rr1.wav <region>lorand=0.25 hirand=0.5 sample=kick_vl4_rr2.wav <region>lorand=0.5 hirand=0.75 sample=kick_vl4_rr3.wav <region>lorand=0.75 sample=kick_vl4_rr4.wav If we go back to sequential round robins and add a snare with only three round robins, plus a few comments, the resulting SFZ would look like this: // This is an example of a basic drum kit mapping // All samples set to play in their entirety when a note is received <global>loop_mode=one_shot // This is the kick, on MIDI note 36, with four dynamic layers and four round robins <group>key=36 hivel=31 amp_velcurve_31=1 seq_length=4 <region>seq_position=1 sample=kick_vl1_rr1.wav <region>seq_position=2 sample=kick_vl1_rr2.wav <region>seq_position=3 sample=kick_vl1_rr3.wav <region>seq_position=4 sample=kick_vl1_rr4.wav <group>key=36 lovel=32 hivel=63 amp_velcurve_63=1 seq_length=4 <region>seq_position=1 sample=kick_vl2_rr1.wav <region>seq_position=2 sample=kick_vl2_rr2.wav <region>seq_position=3 sample=kick_vl2_rr3.wav <region>seq_position=4 sample=kick_vl2_rr4.wav <group>key=36 lovel=64 hivel=95 amp_velcurve_95=1 seq_length=4 <region>seq_position=1 sample=kick_vl3_rr1.wav <region>seq_position=2 sample=kick_vl3_rr2.wav <region>seq_position=3 sample=kick_vl3_rr3.wav <region>seq_position=4 sample=kick_vl3_rr4.wav <group>key=36 lovel=96 seq_length=4 <region>seq_position=1 sample=kick_vl4_rr1.wav <region>seq_position=2 sample=kick_vl4_rr2.wav <region>seq_position=3 sample=kick_vl4_rr3.wav <region>seq_position=4 sample=kick_vl4_rr4.wav // Here is the snare, on MIDI note 38, with four dynamic layers and three round robins <group>key=38 hivel=31 amp_velcurve_31=1 seq_length=3 <region>seq_position=1 sample=snare_vl1_rr1.wav <region>seq_position=2 sample=snare_vl1_rr2.wav <region>seq_position=3 sample=snare_vl1_rr3.wav <group>key=38 lovel=32 hivel=63 amp_velcurve_63=1 seq_length=3 <region>seq_position=1 sample=snare_vl2_rr1.wav <region>seq_position=2 sample=snare_vl2_rr2.wav <region>seq_position=3 sample=snare_vl2_rr3.wav <group>key=38 lovel=64 hivel=95 amp_velcurve_95=1 seq_length=3 <region>seq_position=1 sample=snare_vl3_rr1.wav <region>seq_position=2 sample=snare_vl3_rr2.wav <region>seq_position=3 sample=snare_vl3_rr3.wav <group>key=38 lovel=96 seq_length=3 <region>seq_position=1 sample=snare_vl4_rr1.wav <region>seq_position=2 sample=snare_vl4_rr2.wav <region>seq_position=3 sample=snare_vl4_rr3.wav This is almost all the information needed to map basic drum kits in SFZ. Almost, because well-sampled hi-hats will have many different articulations, and that creates some additional considerations, which we will describe on another page .","title":"Drum basics"},{"location":"tutorials/envelope_generators/","text":"Envelope generators (EGs) are used to control the profile of the volume, filter, pitch, or other parameter, based on the timing of the key press and release (including sustain / sostenuto pedal release.) These are often called \"ADSRs\", after the four parameters (Attack, Decay, Sustain, Release) that were used to control envelopes in early synthesizers (and many current ones as well.) See SFZ1 Modulations to see examples of how these can be applied. SFZ has two types of EGs: SFZ1 and SFZ2. SFZ1: DSAHDSR SFZ1 envelopes are sometimes called DSAHDSR after the 7 controls of the envelope, which are applied in the order given below. An EG can control a variety of parameters, but to help understand, you can imagine it controlling the volume, in which case you can substitute \"volume\" for \"EG\" below. Parameter Suffix Description Delay time (s) _delay time to wait after key is depressed until the EG starts Start level (%) _start level at which to start Attack time (s) _attack time from note start (at start level) to 100% level Hold time (s) _hold time the volume is held at 100% level Decay time 1 (s) _decay time 3 for the volume to decrease from 100% to the sustain level Sustain level (%) _sustain the % level at which the EG remains while the key is down or the sustain pedal is down Release time 2 _release time 3 for the EG to decrease to zero. This begins when both key and sustain pedal are released, even if the prior stages have not completed. Here is a screenshot of an audio file created using Sforzando, showing the ampeg envelope shape and its stages. Note that this image assumes the Start level is 0. If it were nonzero, the tip of the left-pointing arrow would look chopped off vertically. Here's a play-by-play explanation, when using the EG for volume (ampeg_xxx). When the key is depressed, Delay time elapses and then the note starts (at Start level, which above is the default of 0.) The volume increases (at a constant dB/sec rate) for the Attack time and then reaches the peak level for that note (which is controlled by the velocity and possibly other parameters.) The volume stays at that level for the Hold time, after which it falls off for the Decay time until it reaches the Sustain level. It remains at that level until the key and sustain pedal are both released, when it takes the Release time to fall off to silence. Note that when using an envelope generator to control volume, it is usually not necessary to adjust release or decay times based on velocity: that will happen naturally. That is, if I configure ampeg_release =1 and play a very loud note, that note will decay with a rate so that one second later it will be about 90 dB quieter than when it started. If I play a very soft note, that note will also decay with the same rate, so that 1 second later it will be 90 dB quieter when it started. That's pretty close to how most natural instruments behave. Another note when using an envelope to control volume: if you're playing a sample that already has a natural envelope, such as the pluck of a harp string, you normally don't have to configure the envelope because it's already in the sample, which has a natural attack and decay. However, you'll still probably want to configure a release, so that if the key is released before the sample is finished, it doesn't end abruptly. With most natural instruments, this release rate varies with pitch, but not velocity. SFZ2 The SFZ2 standard has a more flexible generator that can be used in addition to the above. This is briefly described in SFZ2 Modulations:Envelopes . References th:nth-of-type(1){width:20%;} Decay time is actually a constant decay rate that is specified as the time for the EG to go from 100% to 0% . However, this can be changed by setting xxx_decay_zero=0 to instead mean to decay from 100% to sustain level in the given time, from the actual sustain level. \u21a9 Release time is actually a constant decay rate that is specified as the time for the EG to go from the sustain level to zero. However, this can be changed setting by xxx_release_zero=1 to instead mean to decay from 100% to zero in the given time. \u21a9 When using an amp envelope generator, \"0%\" means \"silence\" but it's actually interpreted as -90dBFS for Aria, or -80dBFS for original sfz. This adjustment is needed because volume is contolled in dB, and silence in dB is negative infinity, which complicates the math. \u21a9 \u21a9","title":"Envelope Generators"},{"location":"tutorials/envelope_generators/#sfz1-dsahdsr","text":"SFZ1 envelopes are sometimes called DSAHDSR after the 7 controls of the envelope, which are applied in the order given below. An EG can control a variety of parameters, but to help understand, you can imagine it controlling the volume, in which case you can substitute \"volume\" for \"EG\" below. Parameter Suffix Description Delay time (s) _delay time to wait after key is depressed until the EG starts Start level (%) _start level at which to start Attack time (s) _attack time from note start (at start level) to 100% level Hold time (s) _hold time the volume is held at 100% level Decay time 1 (s) _decay time 3 for the volume to decrease from 100% to the sustain level Sustain level (%) _sustain the % level at which the EG remains while the key is down or the sustain pedal is down Release time 2 _release time 3 for the EG to decrease to zero. This begins when both key and sustain pedal are released, even if the prior stages have not completed. Here is a screenshot of an audio file created using Sforzando, showing the ampeg envelope shape and its stages. Note that this image assumes the Start level is 0. If it were nonzero, the tip of the left-pointing arrow would look chopped off vertically. Here's a play-by-play explanation, when using the EG for volume (ampeg_xxx). When the key is depressed, Delay time elapses and then the note starts (at Start level, which above is the default of 0.) The volume increases (at a constant dB/sec rate) for the Attack time and then reaches the peak level for that note (which is controlled by the velocity and possibly other parameters.) The volume stays at that level for the Hold time, after which it falls off for the Decay time until it reaches the Sustain level. It remains at that level until the key and sustain pedal are both released, when it takes the Release time to fall off to silence. Note that when using an envelope generator to control volume, it is usually not necessary to adjust release or decay times based on velocity: that will happen naturally. That is, if I configure ampeg_release =1 and play a very loud note, that note will decay with a rate so that one second later it will be about 90 dB quieter than when it started. If I play a very soft note, that note will also decay with the same rate, so that 1 second later it will be 90 dB quieter when it started. That's pretty close to how most natural instruments behave. Another note when using an envelope to control volume: if you're playing a sample that already has a natural envelope, such as the pluck of a harp string, you normally don't have to configure the envelope because it's already in the sample, which has a natural attack and decay. However, you'll still probably want to configure a release, so that if the key is released before the sample is finished, it doesn't end abruptly. With most natural instruments, this release rate varies with pitch, but not velocity.","title":"SFZ1: DSAHDSR"},{"location":"tutorials/envelope_generators/#sfz2","text":"The SFZ2 standard has a more flexible generator that can be used in addition to the above. This is briefly described in SFZ2 Modulations:Envelopes .","title":"SFZ2"},{"location":"tutorials/envelope_generators/#references","text":"th:nth-of-type(1){width:20%;} Decay time is actually a constant decay rate that is specified as the time for the EG to go from 100% to 0% . However, this can be changed by setting xxx_decay_zero=0 to instead mean to decay from 100% to sustain level in the given time, from the actual sustain level. \u21a9 Release time is actually a constant decay rate that is specified as the time for the EG to go from the sustain level to zero. However, this can be changed setting by xxx_release_zero=1 to instead mean to decay from 100% to zero in the given time. \u21a9 When using an amp envelope generator, \"0%\" means \"silence\" but it's actually interpreted as -90dBFS for Aria, or -80dBFS for original sfz. This adjustment is needed because volume is contolled in dB, and silence in dB is negative infinity, which complicates the math. \u21a9 \u21a9","title":"References"},{"location":"tutorials/epic_drums/","text":"Basic Concept Epic percussion in media music is commonly created by recording large ensembles of large, low-tuned drums (for example taikos) in large, naturally reverberant spaces. The Virtuosity Drums kit includes an \"Epic\" knob which makes the small, high-tuned jazz kit recorded in a music store sound surprisingly, well, epic. This tutorial explains how that trick works. Using drum samples at pitches lower than the original recording makes them sound bigger in several ways. One, obviously, the pitch is lower. Two, slowing down the playback also slows down attack times and lengthens decay tails. This includes any reverb tails captured by the microphones, which means pitching a sound down makes it sound as if it was recorded in a larger space. However, pitching sounds down also takes away the high end and reduces definition. Playing a sound at both its original pitch and tuned down an octave is a way to get both at the same time - a large, deep sound with reverb tails twice the length of the real recording, and the clarity and definition of the originally pitched sample. This could be done using the tune opcode, though transpose is likely more convenient.Here is a very simple example using a single floor tom sample: <region> sample=Rack_Tom.wav <region> transpose=-12 sample=Rack_Tom.wav If the sample maps are modularized using #include statements, it becomes very simple to set up a volume control, and also use locc so that the transposed samples don't use up polyphony voices when their volume is at zero. <master> amplitude_oncc101=100 locc101=1 #include \"sample_maps/rack_tom.sfz\" <master> amplitude_oncc102=100 locc102=1 transpose=-12 #include \"sample_maps/rack_tom.sfz\" Some Pitfalls This does not work as well with close mics, which don't have much room reverb in the recording. This is why in Virtuosity Drums, the kick and snare mics aren't used with the Epic control. With kicks and other low drums, there's also a point of diminishing returns with having a lot of low frequencies, which is one more reason to not apply this to kick close mics. Although sample maps can often be reused, as in the above example, instruments which have self-muting behavior, such as hi-hats, or instruments with polyphony limitations will need separate polyphony group numbers for the transposed regions, just as if the transposed regions were separate microphone positions. With complex muting scenarios this will result in very large numbers of groups which can be difficult to keep track of, but with simple self-muting it could look like this: <master> amplitude_oncc101=100 locc101=1 group=1 off_by=1 #include \"sample_maps/hi_hat.sfz\" <master> amplitude_oncc102=100 locc102=1 group=11 off_by=11 transpose=-12 #include \"sample_maps/hi_hat.sfz\" If the samples include any preroll before the hit, which more distant microphone samples naturally will, transposing down an octave will double the length of that preroll. This is usually not a problem, but in extreme cases it may be necessary to use offset to reduce the preroll to avoid a flam sound. In Virtuosity Drums, this is done for the hi-hat pedal articulations. On the topic of flams, this does not work well with flams, buzz rolls and other sounds which do not consist of a single distinct hit. Long rolls and partially closed hi-hats seem to work fairly well, however. Tambourines, shakers etc. will usually sound quite unnatural with the transposed and untransposed sound appearing as separate entities, but sometimes this can be musically useful. Other Uses Applying this trick to a snare bottom mic usually results in a sound which is not epic, but can be very industrial. Beyond drums, this could work reasonably well with other instruments. Sounds with fast, distinct attacks will behave more similarly to drums, though at least on principle this could be used with sounds such as sustained bowed strings also. Of course, pitched instruments can be doubled with another note an octave lower without transposition, as long as the lower note also falls in their range. However, transposition an octave down does make the reverb tails twice as long.","title":"Epic Drums"},{"location":"tutorials/epic_drums/#basic-concept","text":"Epic percussion in media music is commonly created by recording large ensembles of large, low-tuned drums (for example taikos) in large, naturally reverberant spaces. The Virtuosity Drums kit includes an \"Epic\" knob which makes the small, high-tuned jazz kit recorded in a music store sound surprisingly, well, epic. This tutorial explains how that trick works. Using drum samples at pitches lower than the original recording makes them sound bigger in several ways. One, obviously, the pitch is lower. Two, slowing down the playback also slows down attack times and lengthens decay tails. This includes any reverb tails captured by the microphones, which means pitching a sound down makes it sound as if it was recorded in a larger space. However, pitching sounds down also takes away the high end and reduces definition. Playing a sound at both its original pitch and tuned down an octave is a way to get both at the same time - a large, deep sound with reverb tails twice the length of the real recording, and the clarity and definition of the originally pitched sample. This could be done using the tune opcode, though transpose is likely more convenient.Here is a very simple example using a single floor tom sample: <region> sample=Rack_Tom.wav <region> transpose=-12 sample=Rack_Tom.wav If the sample maps are modularized using #include statements, it becomes very simple to set up a volume control, and also use locc so that the transposed samples don't use up polyphony voices when their volume is at zero. <master> amplitude_oncc101=100 locc101=1 #include \"sample_maps/rack_tom.sfz\" <master> amplitude_oncc102=100 locc102=1 transpose=-12 #include \"sample_maps/rack_tom.sfz\"","title":"Basic Concept"},{"location":"tutorials/epic_drums/#some-pitfalls","text":"This does not work as well with close mics, which don't have much room reverb in the recording. This is why in Virtuosity Drums, the kick and snare mics aren't used with the Epic control. With kicks and other low drums, there's also a point of diminishing returns with having a lot of low frequencies, which is one more reason to not apply this to kick close mics. Although sample maps can often be reused, as in the above example, instruments which have self-muting behavior, such as hi-hats, or instruments with polyphony limitations will need separate polyphony group numbers for the transposed regions, just as if the transposed regions were separate microphone positions. With complex muting scenarios this will result in very large numbers of groups which can be difficult to keep track of, but with simple self-muting it could look like this: <master> amplitude_oncc101=100 locc101=1 group=1 off_by=1 #include \"sample_maps/hi_hat.sfz\" <master> amplitude_oncc102=100 locc102=1 group=11 off_by=11 transpose=-12 #include \"sample_maps/hi_hat.sfz\" If the samples include any preroll before the hit, which more distant microphone samples naturally will, transposing down an octave will double the length of that preroll. This is usually not a problem, but in extreme cases it may be necessary to use offset to reduce the preroll to avoid a flam sound. In Virtuosity Drums, this is done for the hi-hat pedal articulations. On the topic of flams, this does not work well with flams, buzz rolls and other sounds which do not consist of a single distinct hit. Long rolls and partially closed hi-hats seem to work fairly well, however. Tambourines, shakers etc. will usually sound quite unnatural with the transposed and untransposed sound appearing as separate entities, but sometimes this can be musically useful.","title":"Some Pitfalls"},{"location":"tutorials/epic_drums/#other-uses","text":"Applying this trick to a snare bottom mic usually results in a sound which is not epic, but can be very industrial. Beyond drums, this could work reasonably well with other instruments. Sounds with fast, distinct attacks will behave more similarly to drums, though at least on principle this could be used with sounds such as sustained bowed strings also. Of course, pitched instruments can be doubled with another note an octave lower without transposition, as long as the lower note also falls in their range. However, transposition an octave down does make the reverb tails twice as long.","title":"Other Uses"},{"location":"tutorials/legato/","text":"Basic monophony In the basic sustained instruments tutorial, we have the below example of a monophonic flute, which uses the group and off_by opcodes to allow only one be played at a time, and the off_mode together with ampeg_release make the fadeout of the previous note a little smoother. This is a starting point for implementing legato. If only group and off_by are specified, the resulting sound will probably be quite bad, as this will use default values for off_mode, ampeg_attack and ampeg_release. This means the note being muted will drop off extremely quickly, which will probably leave an audible drop in levels during the transition, unless the next note has an extremely fast attack. Therefore, at least ampeg_release will need to be specified in most cases - though most instruments will need to specify that even if not using legato. <global>ampeg_release=0.3 amp_veltrack=0 sw_lokey=48 sw_hikey=49 group=1 off_by=1 off_mode=normal <group>lokey=50 hikey=51 pitch_keycenter=50 sw_last=48 <region>sample=d4_p.wav xfin_locc1=0 xfin_hicc1=42 xfout_locc1=43 xfout_hicc1=85 <region>sample=d4_mf.wav xfin_locc1=43 xfin_hicc1=85 xfout_locc1=86 xfout_hicc1=127 <region>sample=d4_f.wav xfin_locc1=86 xfin_hicc1=127 <group>lokey=52 hikey=53 pitch_keycenter=52 sw_last=48 <region>sample=e4_p.wav xfin_locc1=0 xfin_hicc1=42 xfout_locc1=43 xfout_hicc1=85 <region>sample=e4_mf.wav xfin_locc1=43 xfin_hicc1=85 xfout_locc1=86 xfout_hicc1=127 <region>sample=e4_f.wav xfin_locc1=86 xfin_hicc1=127 <group>lokey=50 hikey=51 pitch_keycenter=50 sw_last=49 <region>sample=d4_ft_p.wav xfin_locc1=0 xfin_hicc1=63 xfout_locc1=64 xfout_hicc1=127 <region>sample=d4_ft_f.wav xfin_locc1=64 xfin_hicc1=127 <group>lokey=52 hikey=53 pitch_keycenter=52 sw_last=49 <region>sample=e4_ft_p.wav xfin_locc1=0 xfin_hicc1=63 xfout_locc1=64 xfout_hicc1=127 <region>sample=e4_ft_f.wav xfin_locc1=64 xfin_hicc1=127 Legato regions The above will allow only one note to sound at a time, with a quick crossfade between the old and new note. In many cases, though, it makes sense to treat the legato notes differently than the notes which start a phrase when no other note is playing. The trigger opcode is used to separate regions into initial and legato. For sustained sounds, it can make sense to use the offset opcode to skip the start of the sample for legato regions. It's also probably a good idea to use offset_attack in these cases, which both makes the transition sound smoother and avoids clicks and pops in cases where the offset does not fall on a zero crossing. Here are the relevant opcodes from the Hadziha choir. An offset of 6000 samples is enough to skip the fraction of a second when the singers are starting the note, but not enough to skip the part of the sample when they're still settling on a common pitch, so it works well for this particular choir. The crossfade times with an off time of 1 second and legato note attack time of 0.4 seconds are probably much longer than would be needed for most solo instruments or voices, or ensembles intended for fast legato, but could be a good range for other types of ensembles playing slowly. Note that the samples are not all in the same group - the initial note regions are in polyphony group 1, which is muted by group 2. The legato regions are in polyphony group 2, which mutes itself. Having everything in group 1 should also work, though. This was done this was to allow the use of additional syllable start samples, which would then be group 3 and also be muted by group 2. As with hi-hat muting, if there are multiple mic positions in separate files, each mic position will need its own polyphony groups. <global>off_mode=time off_time=1 amp_veltrack=0 <master>trigger=first group=1 off_by=2 //Sample map goes here #include \"mappings/6_a_map.sfz\" <master>trigger=legato offset=6000 ampeg_attack=0.4 group=2 off_by=2 //Sample map goes here #include \"mappings/6_a_map.sfz\" As this does not use velocity to control note volume, that frees up velocity for something else, so in this specific case velocity is repurposed to shorten the attack time on the legato notes, which makes the patch more intuitively playable. <global>off_mode=time off_time=1 amp_veltrack=0 <master>trigger=first group=1 off_by=3 //Sample map goes here #include \"mappings/6_a_map.sfz\" <master>trigger=legato offset=6000 ampeg_attack=1 ampeg_vel2attack=-0.8 group=3 off_by=3 //Sample map goes here #include \"mappings/6_a_map.sfz\" Portamento Another possibility is portamento, or having a pitch glide implemented on the legato regions. Here are the relevant opcodes from Karoryfer Samples Meatbass, which has both legato and portamento. The portamento is very obviously fake for slow glides across long intervals, but as long as the interval is no more than a third or fourth, it can be convincing. Of course, the narrower the interval and the shorter the time, the easier it is to sound convincing. With the portamento time at zero, this is effectively the same as non-portamento legato in the above example. In the below setup, MIDI CC109 controls the glide time and an SFZ2 envelope is used to make the pitch change happen. CC140 is the ARIA extension CC for pitch delta, and being the difference in pitch between the previous note and the current note, it sets the depth of the glide envelope. <global>eg06_sustain=1 //Pitch envelope setup for legato slides eg06_level0=-1 //Envelope starts away from the note pitch eg06_time0=0 eg06_pitch_oncc140=100 //This is the pitch depth eg06_time1=0 eg06_level1=0 //At the end of the envelope, return to base pitch //eg06_time1_oncc109 needs to be set for the legato regions - but we don't want //it on for all regions so the default is 0 //At zero envelope duration the pitch goes to base pitch immediately so there //is no glide //Typical stuff for monophonic instruments off_mode=normal ampeg_release_oncc104=2 All the sample regions are then basically duplicated in non-legato and legato versions. Here's an example non-legato region with trigger set to first and no eg06_time_oncc109 set. The group and off_by work just like in the above examples. <group> trigger=first off_mode=normal group=1 off_by=1 <region> sample=..\\Samples\\arco_looped\\c4_sustain.wav pitch_keycenter=48 And the corresponding legato region with trigger set to legato, the eg06 glide envelope time control, and also an attack time, to let the note fade in more gradually, with this controlled by CC100 rather than velocity, as the example above. This is another option. <group> trigger=legato off_mode=normal group=1 off_by=1 eg06_time1_oncc109=0.3 ampeg_attack_oncc100=0.5 <region> sample=..\\Samples\\arco_looped\\c4_sustain.wav pitch_keycenter=48 True sampled legato Here are examples from a simple flute test by MatFluor. The trigger=first regions work similarly as all the above examples, and the sw_previous opcode can be used to choose which sample plays for the legato regions. If the samples would include both the legato transition and the complete sustain of the following note, things would be very simple: <group> // Legato transitions and the complete sustain of the next note both in the same sample trigger=legato group=2 off_by=1 ampeg_attack=0.05 ampeg_release=0.2 off_mode=normal // Leg transitions up <region> sample=legatovib_g4_a4.wav key=A4 sw_previous=G4 <region> sample=legatovib_g4_c5.wav key=C5 sw_previous=G4 <region> sample=legatovib_a4_c5.wav key=C5 sw_previous=A4 // Leg transitions down <region> sample=legatovib_c5_a4.wav key=A4 sw_previous=C5 <region> sample=legatovib_c5_g4.wav key=G4 sw_previous=C5 Recording the full sustain after every transition adds greatly to the recording time, diskspace and RAM use, however. It may be necessary in some cases, such as solo vocals, but in other cases it's possible to use transition samples which are short, then fade in the regular sustain sample. <group> // Legato transitions in one sample, crossfaded into standard sustain in another sample trigger=legato group=2 off_by=1 ampeg_attack=0.05 ampeg_release=0.2 off_mode=normal // Leg transitions up <region> sample=legatovib_g4_a4.wav key=A4 sw_previous=G4 ampeg_hold=0.25 ampeg_decay=0.2 ampeg_sustain=0 offset=45000 ampeg_decay_shape=-1.4 <region> sample=legatovib_g4_c5.wav key=C5 sw_previous=G4 ampeg_hold=0.25 ampeg_decay=0.2 ampeg_sustain=0 offset=45000 ampeg_decay_shape=-1.4 <region> sample=legatovib_a4_c5.wav key=C5 sw_previous=A4 ampeg_hold=0.25 ampeg_decay=0.2 ampeg_sustain=0 offset=45000 ampeg_decay_shape=-1.4 // Leg transitions down <region> sample=legatovib_c5_a4.wav key=A4 sw_previous=C5 ampeg_hold=0.25 ampeg_decay=0.2 ampeg_sustain=0 offset=45000 ampeg_decay_shape=-1.4 <region> sample=legatovib_c5_g4.wav key=G4 sw_previous=C5 ampeg_hold=0.25 ampeg_decay=0.2 ampeg_sustain=0 offset=45000 ampeg_decay_shape=-1.4 <region> sample=legatovib_a4_g4.wav key=G4 sw_previous=A4 ampeg_hold=0.25 ampeg_decay=0.2 ampeg_sustain=0 offset=43000 ampeg_decay_shape=-1.4 // Leg sustains <region> sample=sustainvib_c5.wav key=C5 ampeg_attack=0.3 offset=5000 ampeg_attack_shape=3.8 <region> sample=sustainvib_a4.wav key=A4 ampeg_attack=0.3 offset=5000 ampeg_attack_shape=3.8 <region> sample=sustainvib_g4.wav key=G4 ampeg_attack=0.3 offset=5000 ampeg_attack_shape=3.8 Another consideration is that for instruments with a wide range, it may not be worthwhile to record every possible transition, and only record transitions of up to one octave, for example. The extended CCs do not always behave quite like other CCs, necessitating using hdcc in ARIA, but the below works for a legato vocal with a range of less than two octaves. <global> off_mode=time off_time=0.4 ampeg_release=0.3 <group> trigger=first group=1 off_by=1 #include \"modules/vowel_sustain_a.sfz\" <group> trigger=legato group=1 off_by=1 ampeg_attack=0.1 ampeg_hold=0.3 ampeg_decay=0.6 ampeg_sustain=0 hihdcc141=12.1 #include \"modules/vowel_transition_a.sfz\" <group> trigger=legato group=2 off_by=1 delay=0.3 ampeg_attack=0.2 offset=40000 hihdcc141=12.1 #include \"modules/vowel_sustain_a.sfz\" <group> trigger=legato group=1 off_by=1 ampeg_attack=0.1 lohdcc141=12.9 hihdcc141=24 offset=12000 #include \"modules/vowel_sustain_a.sfz\" It is also possible to use CC 140 in a similar way in an instrument which, for example, has legato transitions recorded ascending but not descending. Further True Legato Possibilities It's possible to make a legato instrument that's not sampled chromatically. In such cases, it's necessary to use the same tricks used when extending range and transpose samples across a wider range. The important thing to remember is that when extending the range of a sample, lokey, hikey and sw_previous all need to be changed by the same amount from the original. For example, if an instrument has transitions sampled from C and D but not from C#, like this: <region> sample=legatovib_c5_a4.wav key=A4 sw_previous=C5 <region> sample=legatovib_c5_a#4.wav key=A#4 sw_previous=C5 <region> sample=legatovib_c5_b4.wav key=B4 sw_previous=C5 <region> sample=legatovib_d5_a4.wav key=A4 sw_previous=D5 <region> sample=legatovib_d5_a#4.wav key=A#4 sw_previous=D5 <region> sample=legatovib_d5_b4.wav key=B4 sw_previous=D5 Extending the transitions from C5 to be used as transitions from C#5 for those same three notes could look like this: <region> sample=legatovib_c5_a4.wav key=A4 sw_previous=C5 <region> sample=legatovib_c5_a#4.wav key=A#4 sw_previous=C5 <region> sample=legatovib_c5_b4.wav key=B4 sw_previous=C5 <region> sample=legatovib_c5_g#4.wav lokey=A4 hikey=A4 pitch_keycenter=G#4 sw_previous=C#5 <region> sample=legatovib_c5_a4.wav lokey=A#4 hikey=A#4 pitch_keycenter=A4 sw_previous=C#5 <region> sample=legatovib_c5_a#4.wav lokey=B4 hikey=B4 pitch_keycenter=A#4 sw_previous=C#5 <region> sample=legatovib_d5_a4.wav key=A4 sw_previous=D5 <region> sample=legatovib_d5_a#4.wav key=A#4 sw_previous=D5 <region> sample=legatovib_d5_b4.wav key=B4 sw_previous=D5 In one real-world case where the notes from which the intervals were sampled was not completely consistent between different dynamic layers, the easiest way to deal with this was to copy the entire sample map, move the lokey, hikey and sw_previous values by one in the copy, then manually delete the duplicates and values where either the key or sw_previous falls outside the instrument's range. An instrument which does not have all interval transitions sampled, however, would be more tricky. For example, a diatonic folk flute in C would not have a minor second from C to C#, and the nearest available minor second transition would be from E to F, which would be a pretty big transposition. One possible compromise in such cases would probably be to use the C to D transition transposed down a minor second, which would include a bit of B at the start of the transition, but if the transitions are quick enough this might be passable. A better but more laborious solution would be processing the recordings with pitch transposition software such as Melodyne or Zplane reTune to create the missing intervals.","title":"Legato"},{"location":"tutorials/legato/#basic-monophony","text":"In the basic sustained instruments tutorial, we have the below example of a monophonic flute, which uses the group and off_by opcodes to allow only one be played at a time, and the off_mode together with ampeg_release make the fadeout of the previous note a little smoother. This is a starting point for implementing legato. If only group and off_by are specified, the resulting sound will probably be quite bad, as this will use default values for off_mode, ampeg_attack and ampeg_release. This means the note being muted will drop off extremely quickly, which will probably leave an audible drop in levels during the transition, unless the next note has an extremely fast attack. Therefore, at least ampeg_release will need to be specified in most cases - though most instruments will need to specify that even if not using legato. <global>ampeg_release=0.3 amp_veltrack=0 sw_lokey=48 sw_hikey=49 group=1 off_by=1 off_mode=normal <group>lokey=50 hikey=51 pitch_keycenter=50 sw_last=48 <region>sample=d4_p.wav xfin_locc1=0 xfin_hicc1=42 xfout_locc1=43 xfout_hicc1=85 <region>sample=d4_mf.wav xfin_locc1=43 xfin_hicc1=85 xfout_locc1=86 xfout_hicc1=127 <region>sample=d4_f.wav xfin_locc1=86 xfin_hicc1=127 <group>lokey=52 hikey=53 pitch_keycenter=52 sw_last=48 <region>sample=e4_p.wav xfin_locc1=0 xfin_hicc1=42 xfout_locc1=43 xfout_hicc1=85 <region>sample=e4_mf.wav xfin_locc1=43 xfin_hicc1=85 xfout_locc1=86 xfout_hicc1=127 <region>sample=e4_f.wav xfin_locc1=86 xfin_hicc1=127 <group>lokey=50 hikey=51 pitch_keycenter=50 sw_last=49 <region>sample=d4_ft_p.wav xfin_locc1=0 xfin_hicc1=63 xfout_locc1=64 xfout_hicc1=127 <region>sample=d4_ft_f.wav xfin_locc1=64 xfin_hicc1=127 <group>lokey=52 hikey=53 pitch_keycenter=52 sw_last=49 <region>sample=e4_ft_p.wav xfin_locc1=0 xfin_hicc1=63 xfout_locc1=64 xfout_hicc1=127 <region>sample=e4_ft_f.wav xfin_locc1=64 xfin_hicc1=127","title":"Basic monophony"},{"location":"tutorials/legato/#legato-regions","text":"The above will allow only one note to sound at a time, with a quick crossfade between the old and new note. In many cases, though, it makes sense to treat the legato notes differently than the notes which start a phrase when no other note is playing. The trigger opcode is used to separate regions into initial and legato. For sustained sounds, it can make sense to use the offset opcode to skip the start of the sample for legato regions. It's also probably a good idea to use offset_attack in these cases, which both makes the transition sound smoother and avoids clicks and pops in cases where the offset does not fall on a zero crossing. Here are the relevant opcodes from the Hadziha choir. An offset of 6000 samples is enough to skip the fraction of a second when the singers are starting the note, but not enough to skip the part of the sample when they're still settling on a common pitch, so it works well for this particular choir. The crossfade times with an off time of 1 second and legato note attack time of 0.4 seconds are probably much longer than would be needed for most solo instruments or voices, or ensembles intended for fast legato, but could be a good range for other types of ensembles playing slowly. Note that the samples are not all in the same group - the initial note regions are in polyphony group 1, which is muted by group 2. The legato regions are in polyphony group 2, which mutes itself. Having everything in group 1 should also work, though. This was done this was to allow the use of additional syllable start samples, which would then be group 3 and also be muted by group 2. As with hi-hat muting, if there are multiple mic positions in separate files, each mic position will need its own polyphony groups. <global>off_mode=time off_time=1 amp_veltrack=0 <master>trigger=first group=1 off_by=2 //Sample map goes here #include \"mappings/6_a_map.sfz\" <master>trigger=legato offset=6000 ampeg_attack=0.4 group=2 off_by=2 //Sample map goes here #include \"mappings/6_a_map.sfz\" As this does not use velocity to control note volume, that frees up velocity for something else, so in this specific case velocity is repurposed to shorten the attack time on the legato notes, which makes the patch more intuitively playable. <global>off_mode=time off_time=1 amp_veltrack=0 <master>trigger=first group=1 off_by=3 //Sample map goes here #include \"mappings/6_a_map.sfz\" <master>trigger=legato offset=6000 ampeg_attack=1 ampeg_vel2attack=-0.8 group=3 off_by=3 //Sample map goes here #include \"mappings/6_a_map.sfz\"","title":"Legato regions"},{"location":"tutorials/legato/#portamento","text":"Another possibility is portamento, or having a pitch glide implemented on the legato regions. Here are the relevant opcodes from Karoryfer Samples Meatbass, which has both legato and portamento. The portamento is very obviously fake for slow glides across long intervals, but as long as the interval is no more than a third or fourth, it can be convincing. Of course, the narrower the interval and the shorter the time, the easier it is to sound convincing. With the portamento time at zero, this is effectively the same as non-portamento legato in the above example. In the below setup, MIDI CC109 controls the glide time and an SFZ2 envelope is used to make the pitch change happen. CC140 is the ARIA extension CC for pitch delta, and being the difference in pitch between the previous note and the current note, it sets the depth of the glide envelope. <global>eg06_sustain=1 //Pitch envelope setup for legato slides eg06_level0=-1 //Envelope starts away from the note pitch eg06_time0=0 eg06_pitch_oncc140=100 //This is the pitch depth eg06_time1=0 eg06_level1=0 //At the end of the envelope, return to base pitch //eg06_time1_oncc109 needs to be set for the legato regions - but we don't want //it on for all regions so the default is 0 //At zero envelope duration the pitch goes to base pitch immediately so there //is no glide //Typical stuff for monophonic instruments off_mode=normal ampeg_release_oncc104=2 All the sample regions are then basically duplicated in non-legato and legato versions. Here's an example non-legato region with trigger set to first and no eg06_time_oncc109 set. The group and off_by work just like in the above examples. <group> trigger=first off_mode=normal group=1 off_by=1 <region> sample=..\\Samples\\arco_looped\\c4_sustain.wav pitch_keycenter=48 And the corresponding legato region with trigger set to legato, the eg06 glide envelope time control, and also an attack time, to let the note fade in more gradually, with this controlled by CC100 rather than velocity, as the example above. This is another option. <group> trigger=legato off_mode=normal group=1 off_by=1 eg06_time1_oncc109=0.3 ampeg_attack_oncc100=0.5 <region> sample=..\\Samples\\arco_looped\\c4_sustain.wav pitch_keycenter=48","title":"Portamento"},{"location":"tutorials/legato/#true-sampled-legato","text":"Here are examples from a simple flute test by MatFluor. The trigger=first regions work similarly as all the above examples, and the sw_previous opcode can be used to choose which sample plays for the legato regions. If the samples would include both the legato transition and the complete sustain of the following note, things would be very simple: <group> // Legato transitions and the complete sustain of the next note both in the same sample trigger=legato group=2 off_by=1 ampeg_attack=0.05 ampeg_release=0.2 off_mode=normal // Leg transitions up <region> sample=legatovib_g4_a4.wav key=A4 sw_previous=G4 <region> sample=legatovib_g4_c5.wav key=C5 sw_previous=G4 <region> sample=legatovib_a4_c5.wav key=C5 sw_previous=A4 // Leg transitions down <region> sample=legatovib_c5_a4.wav key=A4 sw_previous=C5 <region> sample=legatovib_c5_g4.wav key=G4 sw_previous=C5 Recording the full sustain after every transition adds greatly to the recording time, diskspace and RAM use, however. It may be necessary in some cases, such as solo vocals, but in other cases it's possible to use transition samples which are short, then fade in the regular sustain sample. <group> // Legato transitions in one sample, crossfaded into standard sustain in another sample trigger=legato group=2 off_by=1 ampeg_attack=0.05 ampeg_release=0.2 off_mode=normal // Leg transitions up <region> sample=legatovib_g4_a4.wav key=A4 sw_previous=G4 ampeg_hold=0.25 ampeg_decay=0.2 ampeg_sustain=0 offset=45000 ampeg_decay_shape=-1.4 <region> sample=legatovib_g4_c5.wav key=C5 sw_previous=G4 ampeg_hold=0.25 ampeg_decay=0.2 ampeg_sustain=0 offset=45000 ampeg_decay_shape=-1.4 <region> sample=legatovib_a4_c5.wav key=C5 sw_previous=A4 ampeg_hold=0.25 ampeg_decay=0.2 ampeg_sustain=0 offset=45000 ampeg_decay_shape=-1.4 // Leg transitions down <region> sample=legatovib_c5_a4.wav key=A4 sw_previous=C5 ampeg_hold=0.25 ampeg_decay=0.2 ampeg_sustain=0 offset=45000 ampeg_decay_shape=-1.4 <region> sample=legatovib_c5_g4.wav key=G4 sw_previous=C5 ampeg_hold=0.25 ampeg_decay=0.2 ampeg_sustain=0 offset=45000 ampeg_decay_shape=-1.4 <region> sample=legatovib_a4_g4.wav key=G4 sw_previous=A4 ampeg_hold=0.25 ampeg_decay=0.2 ampeg_sustain=0 offset=43000 ampeg_decay_shape=-1.4 // Leg sustains <region> sample=sustainvib_c5.wav key=C5 ampeg_attack=0.3 offset=5000 ampeg_attack_shape=3.8 <region> sample=sustainvib_a4.wav key=A4 ampeg_attack=0.3 offset=5000 ampeg_attack_shape=3.8 <region> sample=sustainvib_g4.wav key=G4 ampeg_attack=0.3 offset=5000 ampeg_attack_shape=3.8 Another consideration is that for instruments with a wide range, it may not be worthwhile to record every possible transition, and only record transitions of up to one octave, for example. The extended CCs do not always behave quite like other CCs, necessitating using hdcc in ARIA, but the below works for a legato vocal with a range of less than two octaves. <global> off_mode=time off_time=0.4 ampeg_release=0.3 <group> trigger=first group=1 off_by=1 #include \"modules/vowel_sustain_a.sfz\" <group> trigger=legato group=1 off_by=1 ampeg_attack=0.1 ampeg_hold=0.3 ampeg_decay=0.6 ampeg_sustain=0 hihdcc141=12.1 #include \"modules/vowel_transition_a.sfz\" <group> trigger=legato group=2 off_by=1 delay=0.3 ampeg_attack=0.2 offset=40000 hihdcc141=12.1 #include \"modules/vowel_sustain_a.sfz\" <group> trigger=legato group=1 off_by=1 ampeg_attack=0.1 lohdcc141=12.9 hihdcc141=24 offset=12000 #include \"modules/vowel_sustain_a.sfz\" It is also possible to use CC 140 in a similar way in an instrument which, for example, has legato transitions recorded ascending but not descending.","title":"True sampled legato"},{"location":"tutorials/legato/#further-true-legato-possibilities","text":"It's possible to make a legato instrument that's not sampled chromatically. In such cases, it's necessary to use the same tricks used when extending range and transpose samples across a wider range. The important thing to remember is that when extending the range of a sample, lokey, hikey and sw_previous all need to be changed by the same amount from the original. For example, if an instrument has transitions sampled from C and D but not from C#, like this: <region> sample=legatovib_c5_a4.wav key=A4 sw_previous=C5 <region> sample=legatovib_c5_a#4.wav key=A#4 sw_previous=C5 <region> sample=legatovib_c5_b4.wav key=B4 sw_previous=C5 <region> sample=legatovib_d5_a4.wav key=A4 sw_previous=D5 <region> sample=legatovib_d5_a#4.wav key=A#4 sw_previous=D5 <region> sample=legatovib_d5_b4.wav key=B4 sw_previous=D5 Extending the transitions from C5 to be used as transitions from C#5 for those same three notes could look like this: <region> sample=legatovib_c5_a4.wav key=A4 sw_previous=C5 <region> sample=legatovib_c5_a#4.wav key=A#4 sw_previous=C5 <region> sample=legatovib_c5_b4.wav key=B4 sw_previous=C5 <region> sample=legatovib_c5_g#4.wav lokey=A4 hikey=A4 pitch_keycenter=G#4 sw_previous=C#5 <region> sample=legatovib_c5_a4.wav lokey=A#4 hikey=A#4 pitch_keycenter=A4 sw_previous=C#5 <region> sample=legatovib_c5_a#4.wav lokey=B4 hikey=B4 pitch_keycenter=A#4 sw_previous=C#5 <region> sample=legatovib_d5_a4.wav key=A4 sw_previous=D5 <region> sample=legatovib_d5_a#4.wav key=A#4 sw_previous=D5 <region> sample=legatovib_d5_b4.wav key=B4 sw_previous=D5 In one real-world case where the notes from which the intervals were sampled was not completely consistent between different dynamic layers, the easiest way to deal with this was to copy the entire sample map, move the lokey, hikey and sw_previous values by one in the copy, then manually delete the duplicates and values where either the key or sw_previous falls outside the instrument's range. An instrument which does not have all interval transitions sampled, however, would be more tricky. For example, a diatonic folk flute in C would not have a minor second from C to C#, and the nearest available minor second transition would be from E to F, which would be a pretty big transposition. One possible compromise in such cases would probably be to use the C to D transition transposed down a minor second, which would include a bit of B at the start of the transition, but if the transitions are quick enough this might be passable. A better but more laborious solution would be processing the recordings with pitch transposition software such as Melodyne or Zplane reTune to create the missing intervals.","title":"Further True Legato Possibilities"},{"location":"tutorials/lfo/","text":"Just copy the following in your preferred text editor. We also have a section in the tools page listing some text editor's SFZ syntax highlighting add-ons. Add to your own SFZ to spice up your instruments: // ********************************************************************** // SFZ1 Pitch LFO Example // // // ********************************************************************** <global> pitchlfo_freq=4 pitchlfo_depth=0 //default setting pitchlfo_depth_oncc1=200 //pitch variation in cents using the mod wheel <region> sample=*sine // ********************************************************************** // SFZ2 Pitch LFO Example // // // ********************************************************************** <global> lfo06_freq=4 lfo06_pitch=0 //default setting lfo06_pitch_oncc1=200 //pitch variation in cents using the mod wheel <region> sample=*sine","title":"Pitch LFO Examples"},{"location":"tutorials/modular_instruments/","text":"The Include Statement SFZ is not a programming language, and has a structure based on a hierarchy of headers. There are no procedure or function calls which would allow the same block of code to be called from various places in an SFZ file. This can lead to a lot of repetition in large SFZ instruments. As a simple example, here's a polyphony switch in an instrument causing duplication of the sample map. <group> hicc100=63 <region>key=48 sample=c4.wav <region>key=49 sample=db4.wav <region>key=50 sample=d4.wav <region>key=51 sample=eb4.wav <region>key=52 sample=e4.wav <region>key=53 sample=f4.wav <region>key=54 sample=gb4.wav <region>key=55 sample=g4.wav <region>key=56 sample=ab4.wav <region>key=57 sample=a4.wav <region>key=58 sample=bb4.wav <region>key=59 sample=b4.wav <region>key=60 sample=c5.wav <group> locc100=64 group=1 off_by=1 <region>key=48 sample=c4.wav <region>key=49 sample=db4.wav <region>key=50 sample=d4.wav <region>key=51 sample=eb4.wav <region>key=52 sample=e4.wav <region>key=53 sample=f4.wav <region>key=54 sample=gb4.wav <region>key=55 sample=g4.wav <region>key=56 sample=ab4.wav <region>key=57 sample=a4.wav <region>key=58 sample=bb4.wav <region>key=59 sample=b4.wav <region>key=60 sample=c5.wav If we create an SFZ file called sample_map.sfz with the following content: <region>key=48 sample=c4.wav <region>key=49 sample=db4.wav <region>key=50 sample=d4.wav <region>key=51 sample=eb4.wav <region>key=52 sample=e4.wav <region>key=53 sample=f4.wav <region>key=54 sample=gb4.wav <region>key=55 sample=g4.wav <region>key=56 sample=ab4.wav <region>key=57 sample=a4.wav <region>key=58 sample=bb4.wav <region>key=59 sample=b4.wav <region>key=60 sample=c5.wav Then the sample map becomes a reusable module which can be \"called\" using an #include statement. The instrument can be decluttered to this: <group> hicc100=63 #include \"sample_map.sfz\" <group> locc100=64 group=1 off_by=1 #include \"sample_map.sfz\" Include And File Paths With large instruments which would be broken down into many files, the included files can be placed in a different folder or in a subfolder of the folder containing the instruments. Regardless of which file folder the included files are in, the sample file paths and include file paths will be calculated starting with the folder which contains the instrument file. So, if our above example instrument has the main SFZ file, called main.sfz, in a Programs folder under the instrument root, samples in a Samples folder under that, and the sample_map.sfz is in Programs/mappings, then main.sfz should contain: <group> hicc100=63 #include \"mappings/sample_map.sfz\" <group> locc100=64 group=1 off_by=1 #include \"mappings/sample_map.sfz\" The sample_map.sfz file in mappings should have the following contents: <region>key=48 sample=../Samples/c4.wav <region>key=49 sample=../Samples/db4.wav <region>key=50 sample=../Samples/d4.wav <region>key=51 sample=../Samples/eb4.wav <region>key=52 sample=../Samples/e4.wav <region>key=53 sample=../Samples/f4.wav <region>key=54 sample=../Samples/gb4.wav <region>key=55 sample=../Samples/g4.wav <region>key=56 sample=../Samples/ab4.wav <region>key=57 sample=../Samples/a4.wav <region>key=58 sample=../Samples/bb4.wav <region>key=59 sample=../Samples/b4.wav <region>key=60 sample=../Samples/c5.wav This means that opening the main.sfz file will work, but trying to open sample_map.sfz directly would not, as it would try to locate the samples in a relative path of ../Samples, which exists when starting from Programs, but does not exist when starting from Programs/modules. This can make testing sample maps somewhat messy, as they need to be moved out of their \"proper\" folder if the map needs to be tested by itself, without the rest of the SFZ. Include And Nesting Included files can, themselves, include files. This is not a problem, just avoid circular recursion. Other Use Cases For Include In addition to sample maps, modulations can also be reused. For example, a common set of vibrato controls can be included for violin samples which need them, but left out for samples which don't, such as harmonics, percussive noises and legato transitions. Different dynamics controls for long vs. short bowed articulations are also candidates for such treatment. <master> sw_last=34 sw_label=Sustain #include \"modules/vibrato.sfz\" #include \"modules/long_dynamics.sfz\" #include \"mappings/sustain.sfz\" <master> sw_last=33 sw_label=Staccato #include \"modules/vibrato.sfz\" #include \"modules/short_dynamics.sfz\" #include \"mappings/staccato.sfz\" <master> sw_last=32 sw_label=Natural harmonics #include \"modules/long_dynamics.sfz\" #include \"mappings/harmonics.sfz\" <master> sw_last=31 sw_label=Percussive noises #include \"modules/short_dynamics.sfz\" #include \"mappings/noises.sfz\" The same file can also be included in multiple instruments, for example a violin spiccato articulation map can be used in both a spiccato-only instrument and in a keyswitch instrument which contains other articulations as well. Putting each set of round robins inside its own file without defining seq_position inside that file can also be useful for emulating double-tracking. If the basic non-doubletracked instrument is set up like this: <global> seq_length=4 <group> seq_position=1 #include \"mappings/palm_mute_rr1_map.sfz\" <group> seq_position=2 #include \"mappings/palm_mute_rr2_map.sfz\" <group> seq_position=3 #include \"mappings/palm_mute_rr3_map.sfz\" <group> seq_position=4 #include \"mappings/palm_mute_rr4_map.sfz\" It then becomes very simple to make a doubletracked instrument which uses differnt round robins in the left and right channels: <global> seq_length=4 <group> pan=100 seq_position=1 #include \"mappings/palm_mute_rr1_map.sfz\" <group> pan=100 seq_position=2 #include \"mappings/palm_mute_rr2_map.sfz\" <group> pan=100 seq_position=3 #include \"mappings/palm_mute_rr3_map.sfz\" <group> pan=100 seq_position=4 #include \"mappings/palm_mute_rr4_map.sfz\" <group> pan=-100 seq_position=1 #include \"mappings/palm_mute_rr2_map.sfz\" <group> pan=-100 seq_position=2 #include \"mappings/palm_mute_rr3_map.sfz\" <group> pan=-100 seq_position=3 #include \"mappings/palm_mute_rr4_map.sfz\" <group> pan=-100 seq_position=4 #include \"mappings/palm_mute_rr1_map.sfz\" Include And Headers When including files, it's common to put lower levels of header organization, such as region and group in the included file, and put higher levels in the main file. However, this is not necessary, and any levels of headers can be included. It is important to keep in mind that included files are essentially just concatenated to make the SFZ file which the SFZ instrument actually parses. Although an included file is a little like a procedure in a programming language, it isn't really one, and the end of the included file is not meaningful when SFZ opcodes set under headers within an included file will be in effect until encountering another header of the same or higher level. For example, let's say a snare drum sample map contains one-shot samples under <region> headers and also multisampled hits under a <group> header later in the file, and this file is called snare_map.sfz. <region> key=37 sample=Sidestick.wav <region> key=39 sample=Off_center.wav <region> key=40 sample=Rimshot.wav <group> key=38 seq_length=4 <region> seq_position=1 sample=Center_rr1.wav <region> seq_position=2 sample=Center_rr2.wav <region> seq_position=3 sample=Center_rr3.wav <region> seq_position=4 sample=Center_rr4.wav If we want to put snare controls which apply to all those, this would work: <master> amplitude_oncc100=100 tune_oncc101=1200 tune_curvecc101=1 #include \"snare_map.sfz\" This, however, would make the controls affect the sidesticks, off-center hits and rimshot, but not the center hits: <group> amplitude_oncc100=100 tune_oncc101=1200 tune_curvecc101=1 #include \"snare_map.sfz\" That is because the opcodes set under the <group> header would only be active until the <group> header for the center hits is reached. If a <master> header is used, they remain in force until another <master> header is encountered. When the headers are not immediately visible because they're in an included file, it is easy to fall into this kind of trap. The Define Statement In addition to include, #define is the other statement which is very useful in making instruments more modular. Define and include can be used together. For example, user-editable parameters, such as MIDI note assignments for drum kits and CC ranges, can also be placed in a separate file such as the below. #define $KICKKEY 36 #define $SIDESTICKKEY 37 #define $SNAREKEY 38 The defined variables can then be used throughout the instrument, and an end user who wants to change the keymap can edit the file containing the defined numbers without having to search through the entire instrument. In the specific implementation of ARIA, anything which uses the defined variables also needs to be placed in the main SFZ file using include, because of the way ARIA parses SFZ files, described in more detail under the opcode page. Using define as a constant with a single value thorughout an instrument works easily. Defining the same variable to have multiple values at different points in the same instrument, however, requires care. Using #define to set the same variable to different values at one point in the same SFZ file does not work well at least in ARIA/Sforzando when loading an instrument. However, a workaround there is to use include to put each set of define statements with different values in a separate file. In simple tests, that has been successful. Sometimes copying large chunks of SFZ code and performing search-replace within them is easier than redefining variables comes into play. There's a balance of when to use include statements and when to just copy some files and use search-replace. Multiple defined variables can be used in the same line. #define $MIC_NAME Room #define $MIC_MIX_CC 32 <control> label_cc$MIC_MIX_CC=$MIC_NAME One thing to keep in mind is that each variable name should be unique. This is good: #define $SNARE_KEY 38 #define $SNARE_RIMSHOT_KEY 40 This will fail in at least some SFZ players, because the complete name of one variable is also the start of another variable's name: #define $SNARE 38 #define $SNARE_RIMSHOT 40","title":"Modular SFZ Instruments"},{"location":"tutorials/modular_instruments/#the-include-statement","text":"SFZ is not a programming language, and has a structure based on a hierarchy of headers. There are no procedure or function calls which would allow the same block of code to be called from various places in an SFZ file. This can lead to a lot of repetition in large SFZ instruments. As a simple example, here's a polyphony switch in an instrument causing duplication of the sample map. <group> hicc100=63 <region>key=48 sample=c4.wav <region>key=49 sample=db4.wav <region>key=50 sample=d4.wav <region>key=51 sample=eb4.wav <region>key=52 sample=e4.wav <region>key=53 sample=f4.wav <region>key=54 sample=gb4.wav <region>key=55 sample=g4.wav <region>key=56 sample=ab4.wav <region>key=57 sample=a4.wav <region>key=58 sample=bb4.wav <region>key=59 sample=b4.wav <region>key=60 sample=c5.wav <group> locc100=64 group=1 off_by=1 <region>key=48 sample=c4.wav <region>key=49 sample=db4.wav <region>key=50 sample=d4.wav <region>key=51 sample=eb4.wav <region>key=52 sample=e4.wav <region>key=53 sample=f4.wav <region>key=54 sample=gb4.wav <region>key=55 sample=g4.wav <region>key=56 sample=ab4.wav <region>key=57 sample=a4.wav <region>key=58 sample=bb4.wav <region>key=59 sample=b4.wav <region>key=60 sample=c5.wav If we create an SFZ file called sample_map.sfz with the following content: <region>key=48 sample=c4.wav <region>key=49 sample=db4.wav <region>key=50 sample=d4.wav <region>key=51 sample=eb4.wav <region>key=52 sample=e4.wav <region>key=53 sample=f4.wav <region>key=54 sample=gb4.wav <region>key=55 sample=g4.wav <region>key=56 sample=ab4.wav <region>key=57 sample=a4.wav <region>key=58 sample=bb4.wav <region>key=59 sample=b4.wav <region>key=60 sample=c5.wav Then the sample map becomes a reusable module which can be \"called\" using an #include statement. The instrument can be decluttered to this: <group> hicc100=63 #include \"sample_map.sfz\" <group> locc100=64 group=1 off_by=1 #include \"sample_map.sfz\"","title":"The Include Statement"},{"location":"tutorials/modular_instruments/#include-and-file-paths","text":"With large instruments which would be broken down into many files, the included files can be placed in a different folder or in a subfolder of the folder containing the instruments. Regardless of which file folder the included files are in, the sample file paths and include file paths will be calculated starting with the folder which contains the instrument file. So, if our above example instrument has the main SFZ file, called main.sfz, in a Programs folder under the instrument root, samples in a Samples folder under that, and the sample_map.sfz is in Programs/mappings, then main.sfz should contain: <group> hicc100=63 #include \"mappings/sample_map.sfz\" <group> locc100=64 group=1 off_by=1 #include \"mappings/sample_map.sfz\" The sample_map.sfz file in mappings should have the following contents: <region>key=48 sample=../Samples/c4.wav <region>key=49 sample=../Samples/db4.wav <region>key=50 sample=../Samples/d4.wav <region>key=51 sample=../Samples/eb4.wav <region>key=52 sample=../Samples/e4.wav <region>key=53 sample=../Samples/f4.wav <region>key=54 sample=../Samples/gb4.wav <region>key=55 sample=../Samples/g4.wav <region>key=56 sample=../Samples/ab4.wav <region>key=57 sample=../Samples/a4.wav <region>key=58 sample=../Samples/bb4.wav <region>key=59 sample=../Samples/b4.wav <region>key=60 sample=../Samples/c5.wav This means that opening the main.sfz file will work, but trying to open sample_map.sfz directly would not, as it would try to locate the samples in a relative path of ../Samples, which exists when starting from Programs, but does not exist when starting from Programs/modules. This can make testing sample maps somewhat messy, as they need to be moved out of their \"proper\" folder if the map needs to be tested by itself, without the rest of the SFZ.","title":"Include And File Paths"},{"location":"tutorials/modular_instruments/#include-and-nesting","text":"Included files can, themselves, include files. This is not a problem, just avoid circular recursion.","title":"Include And Nesting"},{"location":"tutorials/modular_instruments/#other-use-cases-for-include","text":"In addition to sample maps, modulations can also be reused. For example, a common set of vibrato controls can be included for violin samples which need them, but left out for samples which don't, such as harmonics, percussive noises and legato transitions. Different dynamics controls for long vs. short bowed articulations are also candidates for such treatment. <master> sw_last=34 sw_label=Sustain #include \"modules/vibrato.sfz\" #include \"modules/long_dynamics.sfz\" #include \"mappings/sustain.sfz\" <master> sw_last=33 sw_label=Staccato #include \"modules/vibrato.sfz\" #include \"modules/short_dynamics.sfz\" #include \"mappings/staccato.sfz\" <master> sw_last=32 sw_label=Natural harmonics #include \"modules/long_dynamics.sfz\" #include \"mappings/harmonics.sfz\" <master> sw_last=31 sw_label=Percussive noises #include \"modules/short_dynamics.sfz\" #include \"mappings/noises.sfz\" The same file can also be included in multiple instruments, for example a violin spiccato articulation map can be used in both a spiccato-only instrument and in a keyswitch instrument which contains other articulations as well. Putting each set of round robins inside its own file without defining seq_position inside that file can also be useful for emulating double-tracking. If the basic non-doubletracked instrument is set up like this: <global> seq_length=4 <group> seq_position=1 #include \"mappings/palm_mute_rr1_map.sfz\" <group> seq_position=2 #include \"mappings/palm_mute_rr2_map.sfz\" <group> seq_position=3 #include \"mappings/palm_mute_rr3_map.sfz\" <group> seq_position=4 #include \"mappings/palm_mute_rr4_map.sfz\" It then becomes very simple to make a doubletracked instrument which uses differnt round robins in the left and right channels: <global> seq_length=4 <group> pan=100 seq_position=1 #include \"mappings/palm_mute_rr1_map.sfz\" <group> pan=100 seq_position=2 #include \"mappings/palm_mute_rr2_map.sfz\" <group> pan=100 seq_position=3 #include \"mappings/palm_mute_rr3_map.sfz\" <group> pan=100 seq_position=4 #include \"mappings/palm_mute_rr4_map.sfz\" <group> pan=-100 seq_position=1 #include \"mappings/palm_mute_rr2_map.sfz\" <group> pan=-100 seq_position=2 #include \"mappings/palm_mute_rr3_map.sfz\" <group> pan=-100 seq_position=3 #include \"mappings/palm_mute_rr4_map.sfz\" <group> pan=-100 seq_position=4 #include \"mappings/palm_mute_rr1_map.sfz\"","title":"Other Use Cases For Include"},{"location":"tutorials/modular_instruments/#include-and-headers","text":"When including files, it's common to put lower levels of header organization, such as region and group in the included file, and put higher levels in the main file. However, this is not necessary, and any levels of headers can be included. It is important to keep in mind that included files are essentially just concatenated to make the SFZ file which the SFZ instrument actually parses. Although an included file is a little like a procedure in a programming language, it isn't really one, and the end of the included file is not meaningful when SFZ opcodes set under headers within an included file will be in effect until encountering another header of the same or higher level. For example, let's say a snare drum sample map contains one-shot samples under <region> headers and also multisampled hits under a <group> header later in the file, and this file is called snare_map.sfz. <region> key=37 sample=Sidestick.wav <region> key=39 sample=Off_center.wav <region> key=40 sample=Rimshot.wav <group> key=38 seq_length=4 <region> seq_position=1 sample=Center_rr1.wav <region> seq_position=2 sample=Center_rr2.wav <region> seq_position=3 sample=Center_rr3.wav <region> seq_position=4 sample=Center_rr4.wav If we want to put snare controls which apply to all those, this would work: <master> amplitude_oncc100=100 tune_oncc101=1200 tune_curvecc101=1 #include \"snare_map.sfz\" This, however, would make the controls affect the sidesticks, off-center hits and rimshot, but not the center hits: <group> amplitude_oncc100=100 tune_oncc101=1200 tune_curvecc101=1 #include \"snare_map.sfz\" That is because the opcodes set under the <group> header would only be active until the <group> header for the center hits is reached. If a <master> header is used, they remain in force until another <master> header is encountered. When the headers are not immediately visible because they're in an included file, it is easy to fall into this kind of trap.","title":"Include And Headers"},{"location":"tutorials/modular_instruments/#the-define-statement","text":"In addition to include, #define is the other statement which is very useful in making instruments more modular. Define and include can be used together. For example, user-editable parameters, such as MIDI note assignments for drum kits and CC ranges, can also be placed in a separate file such as the below. #define $KICKKEY 36 #define $SIDESTICKKEY 37 #define $SNAREKEY 38 The defined variables can then be used throughout the instrument, and an end user who wants to change the keymap can edit the file containing the defined numbers without having to search through the entire instrument. In the specific implementation of ARIA, anything which uses the defined variables also needs to be placed in the main SFZ file using include, because of the way ARIA parses SFZ files, described in more detail under the opcode page. Using define as a constant with a single value thorughout an instrument works easily. Defining the same variable to have multiple values at different points in the same instrument, however, requires care. Using #define to set the same variable to different values at one point in the same SFZ file does not work well at least in ARIA/Sforzando when loading an instrument. However, a workaround there is to use include to put each set of define statements with different values in a separate file. In simple tests, that has been successful. Sometimes copying large chunks of SFZ code and performing search-replace within them is easier than redefining variables comes into play. There's a balance of when to use include statements and when to just copy some files and use search-replace. Multiple defined variables can be used in the same line. #define $MIC_NAME Room #define $MIC_MIX_CC 32 <control> label_cc$MIC_MIX_CC=$MIC_NAME One thing to keep in mind is that each variable name should be unique. This is good: #define $SNARE_KEY 38 #define $SNARE_RIMSHOT_KEY 40 This will fail in at least some SFZ players, because the complete name of one variable is also the start of another variable's name: #define $SNARE 38 #define $SNARE_RIMSHOT 40","title":"The Define Statement"},{"location":"tutorials/range_extension/","text":"This tutorial describes how to extend the range of an instrument which does not have samples for all notes in the desired range. This is not complicated, but there are some downsides to doing it the simple way. Things work the same way when extending up or down. When there are intermediate pitches missing, for example when an instrument is sampled every minor third or every octave, there won't be much choice, though if round robins are available the last approach can prove useful. Simple extension of closest available sample Let's say we have only one sampled violin section with the following map, and we want to be able to play the notes for another octave above the highest currently avaialble note. <region>sample=c4.wav key=48 <region>sample=db4.wav key=49 <region>sample=d4.wav key=50 <region>sample=eb4.wav key=51 <region>sample=e4.wav key=52 <region>sample=f4.wav key=53 <region>sample=gb4.wav key=54 <region>sample=g4.wav key=55 <region>sample=ab4.wav key=56 <region>sample=a4.wav key=57 <region>sample=bb4.wav key=58 <region>sample=b4.wav key=59 <region>sample=c5.wav key=60 The simplest way is to just stretch the highest note. Using lokey, hikey and pitch_keycenter as separate opcodes is better than using key and transpose, as it allows one region to cover a wide range of pitches. <region>sample=c5.wav lokey=60 hikey=72 pitch_keycenter=60 Note that ARIA will produce no sound if asked to transpose a sample more than four octaves up - if that is needed, create some extra copies of the samples and transpose them in an audio editor. This accounts for transposition, pitch bend and any other tuning adjustments, so if an octave of pitch bend is needed, the maximum effectively avaialable transpotition becomes an octave less. There is no similar limitation with downward transposition, though. Filling in missing pitches In the above case, the range is being stretched upwards, but the same principle applies if there are notes missing within the range, whether due to recording errors, or the limitations of instruments which can't produce all notes of the chromatic scale. Let's say we have a simple pentatonic xylophone. <region>sample=c4.wav key=48 <region>sample=d4.wav key=50 <region>sample=f4.wav key=53 <region>sample=g4.wav key=55 <region>sample=a4.wav key=57 <region>sample=c5.wav key=60 <region>sample=d5.wav key=62 <region>sample=f5.wav key=65 <region>sample=g5.wav key=67 <region>sample=a5.wav key=69 <region>sample=c6.wav key=72 This would work similar as above, covering every pitch with the nearest available note. Whether to stretch up or down when there are two equally distant notes available is a judgment call. It might be worth trying both to see which sounds best. The below example goes up and doesn't extend the range beyond the highest or lowest available sample, only fills in the gaps. <region>sample=c4.wav lokey=48 hikey=49 pitch_keycenter=48 <region>sample=d4.wav lokey=50 hikey=51 pitch_keycenter=50 <region>sample=f4.wav lokey=52 hikey=54 pitch_keycenter=53 <region>sample=g4.wav lokey=55 hikey=56 pitch_keycenter=55 <region>sample=a4.wav lokey=57 hikey=58 pitch_keycenter=57 <region>sample=c5.wav lokey=59 hikey=61 pitch_keycenter=59 <region>sample=d5.wav lokey=62 hikey=63 pitch_keycenter=62 <region>sample=f5.wav lokey=64 hikey=66 pitch_keycenter=65 <region>sample=g5.wav lokey=67 hikey=68 pitch_keycenter=67 <region>sample=a5.wav lokey=69 hikey=70 pitch_keycenter=69 <region>sample=c6.wav lokey=71 hikey=72 pitch_keycenter=72 Alternating several samples The above is good enough in a lot of cases, though it might become obviously audible that the entire top octave uses the same sample. We could use the top two or three samples instead, and alternate them like this: <region>sample=c5.wav key=60 <region>sample=bb4.wav lokey=61 hikey=61 pitch_keycenter=58 <region>sample=b4.wav lokey=62 hikey=62 pitch_keycenter=59 <region>sample=c5.wav lokey=63 hikey=63 pitch_keycenter=60 <region>sample=bb4.wav lokey=64 hikey=64 pitch_keycenter=58 <region>sample=b4.wav lokey=65 hikey=65 pitch_keycenter=59 <region>sample=c5.wav lokey=66 hikey=66 pitch_keycenter=60 ...and so on, continuing to the highest desired note. Using different round robins However, in the above case, notes a minor third apart will still use the same sample, and there's a minor third interval in both minor and major triads. There might not be a good way to get around this with the sample set we have above, but if we have two round robins, we could do something like this: <group> seq_length=2 <region>sample=c4_rr1.wav key=48 <region>sample=db4_rr1.wav key=49 <region>sample=d4_rr1.wav key=50 <region>sample=eb4_rr1.wav key=51 <region>sample=e4_rr1.wav key=52 <region>sample=f4_rr1.wav key=53 <region>sample=gb4_rr1.wav key=54 <region>sample=g4_rr1.wav key=55 <region>sample=ab4_rr1.wav key=56 <region>sample=a4_rr1.wav key=57 <region>sample=bb4_rr1.wav key=58 <region>sample=b4_rr1.wav key=59 <region>sample=c5_rr1.wav key=60 <region>sample=bb4_rr2.wav lokey=61 hikey=61 pitch_keycenter=58 <region>sample=b4_rr2.wav lokey=62 hikey=62 pitch_keycenter=59 <region>sample=c5_rr2.wav lokey=63 hikey=63 pitch_keycenter=60 <region>sample=bb4_rr1.wav lokey=64 hikey=64 pitch_keycenter=58 <region>sample=b4_rr1.wav lokey=65 hikey=65 pitch_keycenter=59 <region>sample=c5_rr1.wav lokey=66 hikey=66 pitch_keycenter=60 <region>sample=bb4_rr2.wav lokey=67 hikey=67 pitch_keycenter=58 <region>sample=b4_rr2.wav lokey=68 hikey=68 pitch_keycenter=59 <region>sample=c5_rr2.wav lokey=69 hikey=69 pitch_keycenter=60 <region>sample=bb4_rr1.wav lokey=70 hikey=70 pitch_keycenter=58 <region>sample=b4_rr1.wav lokey=71 hikey=71 pitch_keycenter=59 <region>sample=c5_rr1.wav lokey=72 hikey=72 pitch_keycenter=60 <group> seq_length=2 seq_position=2 <region>sample=c4_rr2.wav key=48 <region>sample=db4_rr2.wav key=49 <region>sample=d4_rr2.wav key=50 <region>sample=eb4_rr2.wav key=51 <region>sample=e4_rr2.wav key=52 <region>sample=f4_rr2.wav key=53 <region>sample=gb4_rr2.wav key=54 <region>sample=g4_rr2.wav key=55 <region>sample=ab4_rr2.wav key=56 <region>sample=a4_rr2.wav key=57 <region>sample=bb4_rr2.wav key=58 <region>sample=b4_rr2.wav key=59 <region>sample=c5_rr2.wav key=60 <region>sample=bb4_rr1.wav lokey=61 hikey=61 pitch_keycenter=58 <region>sample=b4_rr1.wav lokey=62 hikey=62 pitch_keycenter=59 <region>sample=c5_rr1.wav lokey=63 hikey=63 pitch_keycenter=60 <region>sample=bb4_rr2.wav lokey=64 hikey=64 pitch_keycenter=58 <region>sample=b4_rr2.wav lokey=65 hikey=65 pitch_keycenter=59 <region>sample=c5_rr2.wav lokey=66 hikey=66 pitch_keycenter=60 <region>sample=bb4_rr1.wav lokey=67 hikey=67 pitch_keycenter=58 <region>sample=b4_rr1.wav lokey=68 hikey=68 pitch_keycenter=59 <region>sample=c5_rr1.wav lokey=69 hikey=69 pitch_keycenter=60 <region>sample=bb4_rr2.wav lokey=70 hikey=70 pitch_keycenter=58 <region>sample=b4_rr2.wav lokey=71 hikey=71 pitch_keycenter=59 <region>sample=c5_rr2.wav lokey=72 hikey=72 pitch_keycenter=60 This is obviously much more complicated than the simple version we started with, and the extra complexity might not be worth it in many cases, but if needed things can be done this way. Recording extra notes In cases where it's very important to avoid using the same sample too many times, it's possible to start addressing this at the recording stage, and record additional samples of the notes which will need to be stretched. Of course this could be more work than just recording the target pitches in the first place, but if the pitches are difficult to produce consistently (for example are notes that a singer can hit only with considerable strain) or just physically fall outside the range, it may be a viable option. True legato samples. Extending the range with true legato samples requires extending the range for both the previous note (the sw_previous values) and the new note (the lokey/hikey values). It is important that when transposing a legato transition sample, not only lokey and hikey must be changed, but lokey, hikey and sw_previous must all be changed by the same value. Here is a process which has worked in practice for extending the range of a legato instrument upwards by a major second by transposing the samples by a minor third. Copy regions with the key to be extended. Add the amount of shift (3 if taking the second-highest and third-lowest note and extending the range by a major second) to sw_previous, lokey and hikey to the copy. Copy regions with the sw_previous to be extended (which will include some regions copied in the previous step). Likewise add the amount of shift to sw_previous, lokey and hikey to the copy. Delete the regions with sw_previous above the new max range (or could try avoiding copying them in the first step, but this way is probably safer). Delete the duplicate regions copied in both of the first two steps. There will be no legato samples covering the widest intervals from the extended notes to the farthest notes on the other side. If the instrument has legato samples only recorded within a certain range (for example only for intervals up to an octave), this isn't going to create any additional problems that didn't already have to be solved when making the non-extended legato instruments. Often the best choice us defaulting to an octave leap in the correct direction is the best choice, but other possibilities are triggering a regular sustain and even producing no sound at all. If an instrument does have every possible note transition in its range sampled, however (quite possible for instruments with a small range, such as rebab), the nearest available interval is probably the most reasonable choice.","title":"Range extension"},{"location":"tutorials/range_extension/#simple-extension-of-closest-available-sample","text":"Let's say we have only one sampled violin section with the following map, and we want to be able to play the notes for another octave above the highest currently avaialble note. <region>sample=c4.wav key=48 <region>sample=db4.wav key=49 <region>sample=d4.wav key=50 <region>sample=eb4.wav key=51 <region>sample=e4.wav key=52 <region>sample=f4.wav key=53 <region>sample=gb4.wav key=54 <region>sample=g4.wav key=55 <region>sample=ab4.wav key=56 <region>sample=a4.wav key=57 <region>sample=bb4.wav key=58 <region>sample=b4.wav key=59 <region>sample=c5.wav key=60 The simplest way is to just stretch the highest note. Using lokey, hikey and pitch_keycenter as separate opcodes is better than using key and transpose, as it allows one region to cover a wide range of pitches. <region>sample=c5.wav lokey=60 hikey=72 pitch_keycenter=60 Note that ARIA will produce no sound if asked to transpose a sample more than four octaves up - if that is needed, create some extra copies of the samples and transpose them in an audio editor. This accounts for transposition, pitch bend and any other tuning adjustments, so if an octave of pitch bend is needed, the maximum effectively avaialable transpotition becomes an octave less. There is no similar limitation with downward transposition, though.","title":"Simple extension of closest available sample"},{"location":"tutorials/range_extension/#filling-in-missing-pitches","text":"In the above case, the range is being stretched upwards, but the same principle applies if there are notes missing within the range, whether due to recording errors, or the limitations of instruments which can't produce all notes of the chromatic scale. Let's say we have a simple pentatonic xylophone. <region>sample=c4.wav key=48 <region>sample=d4.wav key=50 <region>sample=f4.wav key=53 <region>sample=g4.wav key=55 <region>sample=a4.wav key=57 <region>sample=c5.wav key=60 <region>sample=d5.wav key=62 <region>sample=f5.wav key=65 <region>sample=g5.wav key=67 <region>sample=a5.wav key=69 <region>sample=c6.wav key=72 This would work similar as above, covering every pitch with the nearest available note. Whether to stretch up or down when there are two equally distant notes available is a judgment call. It might be worth trying both to see which sounds best. The below example goes up and doesn't extend the range beyond the highest or lowest available sample, only fills in the gaps. <region>sample=c4.wav lokey=48 hikey=49 pitch_keycenter=48 <region>sample=d4.wav lokey=50 hikey=51 pitch_keycenter=50 <region>sample=f4.wav lokey=52 hikey=54 pitch_keycenter=53 <region>sample=g4.wav lokey=55 hikey=56 pitch_keycenter=55 <region>sample=a4.wav lokey=57 hikey=58 pitch_keycenter=57 <region>sample=c5.wav lokey=59 hikey=61 pitch_keycenter=59 <region>sample=d5.wav lokey=62 hikey=63 pitch_keycenter=62 <region>sample=f5.wav lokey=64 hikey=66 pitch_keycenter=65 <region>sample=g5.wav lokey=67 hikey=68 pitch_keycenter=67 <region>sample=a5.wav lokey=69 hikey=70 pitch_keycenter=69 <region>sample=c6.wav lokey=71 hikey=72 pitch_keycenter=72","title":"Filling in missing pitches"},{"location":"tutorials/range_extension/#alternating-several-samples","text":"The above is good enough in a lot of cases, though it might become obviously audible that the entire top octave uses the same sample. We could use the top two or three samples instead, and alternate them like this: <region>sample=c5.wav key=60 <region>sample=bb4.wav lokey=61 hikey=61 pitch_keycenter=58 <region>sample=b4.wav lokey=62 hikey=62 pitch_keycenter=59 <region>sample=c5.wav lokey=63 hikey=63 pitch_keycenter=60 <region>sample=bb4.wav lokey=64 hikey=64 pitch_keycenter=58 <region>sample=b4.wav lokey=65 hikey=65 pitch_keycenter=59 <region>sample=c5.wav lokey=66 hikey=66 pitch_keycenter=60 ...and so on, continuing to the highest desired note.","title":"Alternating several samples"},{"location":"tutorials/range_extension/#using-different-round-robins","text":"However, in the above case, notes a minor third apart will still use the same sample, and there's a minor third interval in both minor and major triads. There might not be a good way to get around this with the sample set we have above, but if we have two round robins, we could do something like this: <group> seq_length=2 <region>sample=c4_rr1.wav key=48 <region>sample=db4_rr1.wav key=49 <region>sample=d4_rr1.wav key=50 <region>sample=eb4_rr1.wav key=51 <region>sample=e4_rr1.wav key=52 <region>sample=f4_rr1.wav key=53 <region>sample=gb4_rr1.wav key=54 <region>sample=g4_rr1.wav key=55 <region>sample=ab4_rr1.wav key=56 <region>sample=a4_rr1.wav key=57 <region>sample=bb4_rr1.wav key=58 <region>sample=b4_rr1.wav key=59 <region>sample=c5_rr1.wav key=60 <region>sample=bb4_rr2.wav lokey=61 hikey=61 pitch_keycenter=58 <region>sample=b4_rr2.wav lokey=62 hikey=62 pitch_keycenter=59 <region>sample=c5_rr2.wav lokey=63 hikey=63 pitch_keycenter=60 <region>sample=bb4_rr1.wav lokey=64 hikey=64 pitch_keycenter=58 <region>sample=b4_rr1.wav lokey=65 hikey=65 pitch_keycenter=59 <region>sample=c5_rr1.wav lokey=66 hikey=66 pitch_keycenter=60 <region>sample=bb4_rr2.wav lokey=67 hikey=67 pitch_keycenter=58 <region>sample=b4_rr2.wav lokey=68 hikey=68 pitch_keycenter=59 <region>sample=c5_rr2.wav lokey=69 hikey=69 pitch_keycenter=60 <region>sample=bb4_rr1.wav lokey=70 hikey=70 pitch_keycenter=58 <region>sample=b4_rr1.wav lokey=71 hikey=71 pitch_keycenter=59 <region>sample=c5_rr1.wav lokey=72 hikey=72 pitch_keycenter=60 <group> seq_length=2 seq_position=2 <region>sample=c4_rr2.wav key=48 <region>sample=db4_rr2.wav key=49 <region>sample=d4_rr2.wav key=50 <region>sample=eb4_rr2.wav key=51 <region>sample=e4_rr2.wav key=52 <region>sample=f4_rr2.wav key=53 <region>sample=gb4_rr2.wav key=54 <region>sample=g4_rr2.wav key=55 <region>sample=ab4_rr2.wav key=56 <region>sample=a4_rr2.wav key=57 <region>sample=bb4_rr2.wav key=58 <region>sample=b4_rr2.wav key=59 <region>sample=c5_rr2.wav key=60 <region>sample=bb4_rr1.wav lokey=61 hikey=61 pitch_keycenter=58 <region>sample=b4_rr1.wav lokey=62 hikey=62 pitch_keycenter=59 <region>sample=c5_rr1.wav lokey=63 hikey=63 pitch_keycenter=60 <region>sample=bb4_rr2.wav lokey=64 hikey=64 pitch_keycenter=58 <region>sample=b4_rr2.wav lokey=65 hikey=65 pitch_keycenter=59 <region>sample=c5_rr2.wav lokey=66 hikey=66 pitch_keycenter=60 <region>sample=bb4_rr1.wav lokey=67 hikey=67 pitch_keycenter=58 <region>sample=b4_rr1.wav lokey=68 hikey=68 pitch_keycenter=59 <region>sample=c5_rr1.wav lokey=69 hikey=69 pitch_keycenter=60 <region>sample=bb4_rr2.wav lokey=70 hikey=70 pitch_keycenter=58 <region>sample=b4_rr2.wav lokey=71 hikey=71 pitch_keycenter=59 <region>sample=c5_rr2.wav lokey=72 hikey=72 pitch_keycenter=60 This is obviously much more complicated than the simple version we started with, and the extra complexity might not be worth it in many cases, but if needed things can be done this way.","title":"Using different round robins"},{"location":"tutorials/range_extension/#recording-extra-notes","text":"In cases where it's very important to avoid using the same sample too many times, it's possible to start addressing this at the recording stage, and record additional samples of the notes which will need to be stretched. Of course this could be more work than just recording the target pitches in the first place, but if the pitches are difficult to produce consistently (for example are notes that a singer can hit only with considerable strain) or just physically fall outside the range, it may be a viable option.","title":"Recording extra notes"},{"location":"tutorials/range_extension/#true-legato-samples","text":"Extending the range with true legato samples requires extending the range for both the previous note (the sw_previous values) and the new note (the lokey/hikey values). It is important that when transposing a legato transition sample, not only lokey and hikey must be changed, but lokey, hikey and sw_previous must all be changed by the same value. Here is a process which has worked in practice for extending the range of a legato instrument upwards by a major second by transposing the samples by a minor third. Copy regions with the key to be extended. Add the amount of shift (3 if taking the second-highest and third-lowest note and extending the range by a major second) to sw_previous, lokey and hikey to the copy. Copy regions with the sw_previous to be extended (which will include some regions copied in the previous step). Likewise add the amount of shift to sw_previous, lokey and hikey to the copy. Delete the regions with sw_previous above the new max range (or could try avoiding copying them in the first step, but this way is probably safer). Delete the duplicate regions copied in both of the first two steps. There will be no legato samples covering the widest intervals from the extended notes to the farthest notes on the other side. If the instrument has legato samples only recorded within a certain range (for example only for intervals up to an octave), this isn't going to create any additional problems that didn't already have to be solved when making the non-extended legato instruments. Often the best choice us defaulting to an octave leap in the correct direction is the best choice, but other possibilities are triggering a regular sustain and even producing no sound at all. If an instrument does have every possible note transition in its range sampled, however (quite possible for instruments with a small range, such as rebab), the nearest available interval is probably the most reasonable choice.","title":"True legato samples."},{"location":"tutorials/sfz1_modulations/","text":"The set of modulations available under the SFZ1 specification is fixed, and there's a dedicated opcode for every possible modulation, including fairly esoteric ones such as using note velocity to modulate the hold stage of the pitch envelope. Basic MIDI CC modulation A few opcodes can be modulated simply by MIDI CC, with the modulation adding to what the opcode would normally do. These are: offset and delay . For example, this would have a sample offset of 500 when the modulating CC is at 0, and a sample offset of 1000 when the modulating CC is at max: offset=500 offset_cc100=500 It's also possible to just specify the modulation, in which case the default value is what will be modulated. The defaults for offset, delay and EQ band gain are 0, so this would result in the offset being modulated between 0 and 1000: offset_cc100=1000 Modulating default values The three EQ bands' frequency , bandwidth and gain work similarly, but also add velocity tracking. The EQ bandwidth and center frequency also have non-zero defaults, for example eq2_freq is 500 if not specified. So, this would modulate the center frequency of the second EQ band between 500 and 1500 if eq2_freq is left at default: eq2_freqcc110=1000 Velocity tracking, keytracking and randomization EQ frequency and gain (but not bandwidth) can additionally be modulated by velocity. For example, if we want to make a sound brighter when the velocity is higher, we might use something like this: eq1_vel2gain=-6 eq2_vel2gain=12 eq2_vel2freq=500 The xfin / xfout CCs are also a way to fade sounds in and out using MIDI CC. An example of one note with two dynamic layers being crossfaded: <region>sample=e4_ft_p.wav xfin_locc1=0 xfin_hicc1=63 xfout_locc1=64 xfout_hicc1=127 <region>sample=e4_ft_f.wav xfin_locc1=64 xfin_hicc1=127 In addition to MIDI CC, crossfades can also use MIDI note number and velocity as modulation sources, and the xf_cccurve , xf_keycurve and xf_velcurve give the choice of two curves for each of these modulations. More sophisticated modulations are possible with volume, pitch and filter cutoff . Volume and cutoff can be modulated by MIDI CC directly (pitch can't in SFZ1 - the tune_ccN modulation is an ARIA extension). All three can also have randomization applied and be modulated by MIDI note number and velocity. The nomenclature for volume is a little confusing, with gain_ccN using \"gain\" in the name, while the others are called amp_random , amp_keytrack and amp_veltrack . gain_cc80=-6 amp_random=3 amp_keytrack=-1.3 amp_veltrack=80 LFOs and envelopes Volume, filter and cutoff also each get an LFO and an envelope . The LFO rate and depth can be modulated by MIDI CC. Each LFO also has a simple envelope with delay and fade, but modulating the duration of these is not allowed under the SFZ1 spec (though it is with SFZ2 LFOs). Here's a typical pitch vibrato LFO: pitchlfo_freq=2 pitchlfo_freqcc50=10 pitchlfo_depthcc51=33 Each envelope parameter can also be modulated by CC, or by velocity. Here's a exmple setup for a synth-style ADSR volume envelope (hold is not specified so the default hold value of 0 is used) controlled by CCs and some initial minimum values set for attack and release, along with a default sustain of 0: ampeg_attack=0.001 ampeg_attack_oncc40=1 ampeg_decay_oncc41=4 ampeg_sustain=1 ampeg_sustain_oncc42=100 ampeg_release=0.1 ampeg_release_oncc43=0.9 Modulating envelope parameters with velocity allows, for example, setting up a filter on an acid bass which will sweep farther with higher velocity, and also sweep faster. cutoff=120 resonance=12 fileg_attack=0.5 fileg_decay=1 fileg_depth=500 fileg_vel2attack=-0.4 fileg_vel2decay=-0.8 fileg_vel2depth=4000 If something is not described above, then modulating it is not possible under the SFZ1 specification, and will require using SFZ2 or possibly some extension opcodes.","title":"SFZ1 modulations"},{"location":"tutorials/sfz1_modulations/#basic-midi-cc-modulation","text":"A few opcodes can be modulated simply by MIDI CC, with the modulation adding to what the opcode would normally do. These are: offset and delay . For example, this would have a sample offset of 500 when the modulating CC is at 0, and a sample offset of 1000 when the modulating CC is at max: offset=500 offset_cc100=500 It's also possible to just specify the modulation, in which case the default value is what will be modulated. The defaults for offset, delay and EQ band gain are 0, so this would result in the offset being modulated between 0 and 1000: offset_cc100=1000","title":"Basic MIDI CC modulation"},{"location":"tutorials/sfz1_modulations/#modulating-default-values","text":"The three EQ bands' frequency , bandwidth and gain work similarly, but also add velocity tracking. The EQ bandwidth and center frequency also have non-zero defaults, for example eq2_freq is 500 if not specified. So, this would modulate the center frequency of the second EQ band between 500 and 1500 if eq2_freq is left at default: eq2_freqcc110=1000","title":"Modulating default values"},{"location":"tutorials/sfz1_modulations/#velocity-tracking-keytracking-and-randomization","text":"EQ frequency and gain (but not bandwidth) can additionally be modulated by velocity. For example, if we want to make a sound brighter when the velocity is higher, we might use something like this: eq1_vel2gain=-6 eq2_vel2gain=12 eq2_vel2freq=500 The xfin / xfout CCs are also a way to fade sounds in and out using MIDI CC. An example of one note with two dynamic layers being crossfaded: <region>sample=e4_ft_p.wav xfin_locc1=0 xfin_hicc1=63 xfout_locc1=64 xfout_hicc1=127 <region>sample=e4_ft_f.wav xfin_locc1=64 xfin_hicc1=127 In addition to MIDI CC, crossfades can also use MIDI note number and velocity as modulation sources, and the xf_cccurve , xf_keycurve and xf_velcurve give the choice of two curves for each of these modulations. More sophisticated modulations are possible with volume, pitch and filter cutoff . Volume and cutoff can be modulated by MIDI CC directly (pitch can't in SFZ1 - the tune_ccN modulation is an ARIA extension). All three can also have randomization applied and be modulated by MIDI note number and velocity. The nomenclature for volume is a little confusing, with gain_ccN using \"gain\" in the name, while the others are called amp_random , amp_keytrack and amp_veltrack . gain_cc80=-6 amp_random=3 amp_keytrack=-1.3 amp_veltrack=80","title":"Velocity tracking, keytracking and randomization"},{"location":"tutorials/sfz1_modulations/#lfos-and-envelopes","text":"Volume, filter and cutoff also each get an LFO and an envelope . The LFO rate and depth can be modulated by MIDI CC. Each LFO also has a simple envelope with delay and fade, but modulating the duration of these is not allowed under the SFZ1 spec (though it is with SFZ2 LFOs). Here's a typical pitch vibrato LFO: pitchlfo_freq=2 pitchlfo_freqcc50=10 pitchlfo_depthcc51=33 Each envelope parameter can also be modulated by CC, or by velocity. Here's a exmple setup for a synth-style ADSR volume envelope (hold is not specified so the default hold value of 0 is used) controlled by CCs and some initial minimum values set for attack and release, along with a default sustain of 0: ampeg_attack=0.001 ampeg_attack_oncc40=1 ampeg_decay_oncc41=4 ampeg_sustain=1 ampeg_sustain_oncc42=100 ampeg_release=0.1 ampeg_release_oncc43=0.9 Modulating envelope parameters with velocity allows, for example, setting up a filter on an acid bass which will sweep farther with higher velocity, and also sweep faster. cutoff=120 resonance=12 fileg_attack=0.5 fileg_decay=1 fileg_depth=500 fileg_vel2attack=-0.4 fileg_vel2decay=-0.8 fileg_vel2depth=4000 If something is not described above, then modulating it is not possible under the SFZ1 specification, and will require using SFZ2 or possibly some extension opcodes.","title":"LFOs and envelopes"},{"location":"tutorials/sfz2_modulations/","text":"The modulations available under SFZ2 are much more flexible than the fixed set specified by SFZ1 . All SFZ1 modulations are still available under the SFZ2 spec, and will often be easier to use in cases such as envelopes where the standard AHDSR shape is all that's needed. The basic difference is that SFZ1 has three envelopes - one assigned to volume, one to pitch, and one to filter cutoff. There are also three LFOs, one for each of those modulation targets. SFZ2 can have an arbitraty number of envelopes and LFOs, with the ability to specify one or more modulation targets from a list. It is even possible for LFOs to modulate other LFOs and envelopes to modulate LFOs (but not for LFOs to modulate envelopes). In addition, SFZ2 envelopes can have an arbitrary number of points. Additional MIDI CC modulation SFZ2 adds one more paramter which can be modulated with MIDI CC - stereo width . Also need to document pan_onccX and find out whether it's SFZ1 or SFZ2 - currently not sure, needs testing. LFOs For each LFO, an LFO number must be specified - lfo01, lfo02 etc. Each LFO has the following parameters: lfoN_wave lfoN_freq_onccX lfoN_freq_stepccX lfoN_delay_onccX lfoN_fade_onccX lfoN_phase_onccX Click on each link for a detailed description. Similarly to SFZ1 LFOs, there's a frequency, a delay and a fade-in time. In addition, the waveform shape and initial phase can be specified and the LFO can be configured to run for a limited number of counts. The frequency, delay, fade and initial phase can all be modulated by MIDI CC. There is no modulation for LFO depth - to control the depth of vibrato etc, use MIDI CC to modulate how much the LFO affects the desired target. Available LFO targets The available modulation targets for LFOs are These destinations are added as a suffix to 'lfoN_'. For example lfo01_pitch=100 makes LFO 01 affect pitch with a max depth of 100 cents. lfo03_freq_lfo01_oncc117=1.3 would make LFO 03 add up to 1.3 Hertz to the frequency of LFO 01, with the amount modulated by MIDI CC 117. The avaialble targets related to volume and stereo positioning are: volume volume_oncc volume_smoothcc volume_stepcc amplitude amplitude_oncc amplitude_smoothcc amplitude_stepcc pan pan_oncc pan_smoothcc pan_stepcc width width_oncc width_smoothcc width_stepcc The targets for pitch modulation are: pitch pitch_oncc pitch_smoothcc pitch_stepcc The targets for filter modulation are cutoff and resonance, for both the first and second filter: cutoff cutoff_oncc cutoff_smoothcc cutoff_stepcc resonance resonance_oncc resonance_smoothcc resonance_stepcc cutoff2 cutoff2_oncc cutoff2_smoothcc cutoff2_stepcc resonance2 resonance2_oncc resonance2_smoothcc resonance2_stepcc The modulations of the EQ bands are: eqNfreq eqNfreq_oncc eqNfreq_smoothcc eqNfreq_stepcc eqNbw eqNbw_oncc eq1bw_smoothcc eqNbw_stepcc eqNgain eqNgain_oncc eqNgain_smoothcc eqNgain_stepcc The following targets affect other LFOs: freq_lfoX depth_lfoX depthadd_lfoX Some Cakewalk instruments can also modulate the decim and bitred effects: decim decim_oncc decim_smoothcc decim_stepcc bitred bitred_oncc bitred_smoothcc bitred_stepcc LFO examples Here is an example of how one LFO could be used to control both pitch vibrato and volume vibrato (tremolo) with the rate, pitch vibrato depth, tremolo depth, delay and fade each controlled by a separate MIDI CC parameter: lfo01_pitch_oncc111=22 // Vibrato LFO lfo01_freq=2 lfo01_freq_oncc113=7 lfo01_delay_oncc114=0.500 lfo01_fade_oncc115=0.500 lfo01_volume=0 // This LFO also does tremolo lfo01_volume_oncc112=2 And an LFO which does just pitch vibrato, and has a second LFO modulating its rate to create some unsteadiness: lfo01_pitch_oncc111=22 // Vibrato LFO lfo01_freq=2 lfo01_freq_oncc113=7 lfo01_delay_oncc114=0.500 lfo01_fade_oncc115=0.500 lfo2_freq_lfo1_oncc116=3 //Affect the rate of the other LFO for unsteady vibrato lfo02_wave=1 lfo02_freq=0.1 lfo02_freq_oncc116=0.9 For randomized humanization, the extended MIDI CC 135 can be used to randomize the initial phase and speed of the second LFO. lfo01_pitch_oncc111=22 // Vibrato LFO lfo01_freq=2 lfo01_freq_oncc113=7 lfo01_delay_oncc114=0.500 lfo01_fade_oncc115=0.500 lfo2_freq_lfo1_oncc116=3 //Affect the rate of the other LFO for unsteady vibrato lfo02_wave=1 lfo02_freq=0.1 lfo02_freq_oncc116=0.8 lfo02_phase_oncc135=1 lfo02_freq_oncc135=0.2 Envelopes SFZ2 envelopes are numbered and can have an arbitrary number of points, with the level at each point and its modulation set separately. The opcodes used to create these envelopes are: egN_points egN_levelX egN_levelX_onccY egN_timeX egN_timeX_onccY egN_shapeX egN_curveX egN_sustain egN_loop Envelope targets Similarly to LFOs, envelopes have assignable modulation targets. These destinations are added as a suffix to \u2018egN_\u2019 - so, for example: eg01_pitch=2400 would have envelope 01 modulate pitch, with an envelope depth of 2400 cents. These are the available targets related to amplitude and stereo positioning: amplitude amplitude_oncc volume volume_oncc pan pan_oncc width width_oncc Targets for pitch: pitch pitch_oncc Targets for filters: cutoff cutoff_oncc resonance resonance_oncc cutoff2 cutoff2_oncc resonance2 resonance2_oncc Targets for EQ bands: eqNbw eqNbw_oncc eqNfreq eqNfreq_oncc eqNgain eqNgain_oncc Targets for modulating LFOs: depth_lfo depthadd_lfo freq_lfo These two need to be tested - are they for envelopes to modulate other envelopes? depth depth_oncc Targets for modulating decim and bitred do not appear to have been included in the specification. Example envelope Here is a simple pitch envelope which will start a note with a glide from up to an octave lower, with the depth and time modulated by MIDI CCs. The envelope will statt at a lower value at envelope point 0, and return the pitch to normal at envelope point 1. eg01_sustain=1 //Pitch envelope setup for slides eg01_level0=1 eg01_level1=0 eg01_time0=0 eg01_time1=0 eg01_pitch_oncc100=-1200 eg01_time1_oncc101=1 Using LFOs and envelopes together Here is an example of using both an envelope and an LFO to modulate pitch, with common depth and delay parameters. The goal here is asymmetrical pitch vibrato - vibrato which does not go up and down around the original pitch, but instead only goes below it. This is idiomatic with saxophones, and is also how vibrato with certain types of non-floating guitar bridges works (string-bending vibrato is similar, of course, but in the other direction). Shifting the phase of LFO01 will make the vibrato waveform start at the top. We also need to lower the pitch by the same amount as the vibrato depth. Using an envelope for this allows us to delay the onset of the vibrato (again, an important element of idiomatic saxophone vibrato) without a discontinuous jump in pitch. lfo01_pitch_oncc111=20 //Saxy vibrato LFO - goes down from the main pitch lfo01_freq=2 lfo01_freq_oncc112=8 lfo01_phase=0.25 //To make it start at the top lfo01_delay_oncc116=1 eg01_pitch_oncc111=20 eg01_sustain=1 eg01_level0=0 eg01_level1=0 eg01_level2=-1 eg01_time0=0 eg01_time1=0 eg01_time1_oncc116=1 eg01_time2=0 Using SFZ1 and SFZ2 modulations together Both SFZ1 and SFZ2 modulations may be mixed freely. Indeed, it may be simpler to accomplish the above using the SFZ1 pitch envelope, as it is sufficient in this case, with the SFZ2 LFO. Setting the initial phase and modulating the delay with MIDI CC would not be possible with the SFZ1 pitch LFO. lfo01_pitch_oncc111=20 //Saxy vibrato LFO - goes down from the main pitch lfo01_freq=2 lfo01_freq_oncc112=8 lfo01_phase=0.25 //To make it start at the top lfo01_delay_oncc116=1 pitcheg_delay_oncc116=1 //Pitch envelope to drop the central pitch when sax vibrato kicks in pitcheg_depth_oncc111=-20 SmoothccN and stepccN Most MIDI CC modulations, though not all, can have use smoothccN and stepccN . These work similarly to bend_smooth and bend_step . SmoothccN adds \"inertia\" to a modulation, so quickly changing the MIDI CC value has a slower effect on the modulation target than it would normally. StepccN causes the modulation to happen in a discrete number of steps. Setting the number of steps to 1 would make the modulation an all-or-nothing control. This is what's possible under the SFZ2 specification. There are some additional modulations available as ARIA extensions , with amplitude_onccN being a very useful one.","title":"SFZ2 modulations"},{"location":"tutorials/sfz2_modulations/#additional-midi-cc-modulation","text":"SFZ2 adds one more paramter which can be modulated with MIDI CC - stereo width . Also need to document pan_onccX and find out whether it's SFZ1 or SFZ2 - currently not sure, needs testing.","title":"Additional MIDI CC modulation"},{"location":"tutorials/sfz2_modulations/#lfos","text":"For each LFO, an LFO number must be specified - lfo01, lfo02 etc. Each LFO has the following parameters: lfoN_wave lfoN_freq_onccX lfoN_freq_stepccX lfoN_delay_onccX lfoN_fade_onccX lfoN_phase_onccX Click on each link for a detailed description. Similarly to SFZ1 LFOs, there's a frequency, a delay and a fade-in time. In addition, the waveform shape and initial phase can be specified and the LFO can be configured to run for a limited number of counts. The frequency, delay, fade and initial phase can all be modulated by MIDI CC. There is no modulation for LFO depth - to control the depth of vibrato etc, use MIDI CC to modulate how much the LFO affects the desired target.","title":"LFOs"},{"location":"tutorials/sfz2_modulations/#available-lfo-targets","text":"The available modulation targets for LFOs are These destinations are added as a suffix to 'lfoN_'. For example lfo01_pitch=100 makes LFO 01 affect pitch with a max depth of 100 cents. lfo03_freq_lfo01_oncc117=1.3 would make LFO 03 add up to 1.3 Hertz to the frequency of LFO 01, with the amount modulated by MIDI CC 117. The avaialble targets related to volume and stereo positioning are: volume volume_oncc volume_smoothcc volume_stepcc amplitude amplitude_oncc amplitude_smoothcc amplitude_stepcc pan pan_oncc pan_smoothcc pan_stepcc width width_oncc width_smoothcc width_stepcc The targets for pitch modulation are: pitch pitch_oncc pitch_smoothcc pitch_stepcc The targets for filter modulation are cutoff and resonance, for both the first and second filter: cutoff cutoff_oncc cutoff_smoothcc cutoff_stepcc resonance resonance_oncc resonance_smoothcc resonance_stepcc cutoff2 cutoff2_oncc cutoff2_smoothcc cutoff2_stepcc resonance2 resonance2_oncc resonance2_smoothcc resonance2_stepcc The modulations of the EQ bands are: eqNfreq eqNfreq_oncc eqNfreq_smoothcc eqNfreq_stepcc eqNbw eqNbw_oncc eq1bw_smoothcc eqNbw_stepcc eqNgain eqNgain_oncc eqNgain_smoothcc eqNgain_stepcc The following targets affect other LFOs: freq_lfoX depth_lfoX depthadd_lfoX Some Cakewalk instruments can also modulate the decim and bitred effects: decim decim_oncc decim_smoothcc decim_stepcc bitred bitred_oncc bitred_smoothcc bitred_stepcc","title":"Available LFO targets"},{"location":"tutorials/sfz2_modulations/#lfo-examples","text":"Here is an example of how one LFO could be used to control both pitch vibrato and volume vibrato (tremolo) with the rate, pitch vibrato depth, tremolo depth, delay and fade each controlled by a separate MIDI CC parameter: lfo01_pitch_oncc111=22 // Vibrato LFO lfo01_freq=2 lfo01_freq_oncc113=7 lfo01_delay_oncc114=0.500 lfo01_fade_oncc115=0.500 lfo01_volume=0 // This LFO also does tremolo lfo01_volume_oncc112=2 And an LFO which does just pitch vibrato, and has a second LFO modulating its rate to create some unsteadiness: lfo01_pitch_oncc111=22 // Vibrato LFO lfo01_freq=2 lfo01_freq_oncc113=7 lfo01_delay_oncc114=0.500 lfo01_fade_oncc115=0.500 lfo2_freq_lfo1_oncc116=3 //Affect the rate of the other LFO for unsteady vibrato lfo02_wave=1 lfo02_freq=0.1 lfo02_freq_oncc116=0.9 For randomized humanization, the extended MIDI CC 135 can be used to randomize the initial phase and speed of the second LFO. lfo01_pitch_oncc111=22 // Vibrato LFO lfo01_freq=2 lfo01_freq_oncc113=7 lfo01_delay_oncc114=0.500 lfo01_fade_oncc115=0.500 lfo2_freq_lfo1_oncc116=3 //Affect the rate of the other LFO for unsteady vibrato lfo02_wave=1 lfo02_freq=0.1 lfo02_freq_oncc116=0.8 lfo02_phase_oncc135=1 lfo02_freq_oncc135=0.2","title":"LFO examples"},{"location":"tutorials/sfz2_modulations/#envelopes","text":"SFZ2 envelopes are numbered and can have an arbitrary number of points, with the level at each point and its modulation set separately. The opcodes used to create these envelopes are: egN_points egN_levelX egN_levelX_onccY egN_timeX egN_timeX_onccY egN_shapeX egN_curveX egN_sustain egN_loop","title":"Envelopes"},{"location":"tutorials/sfz2_modulations/#envelope-targets","text":"Similarly to LFOs, envelopes have assignable modulation targets. These destinations are added as a suffix to \u2018egN_\u2019 - so, for example: eg01_pitch=2400 would have envelope 01 modulate pitch, with an envelope depth of 2400 cents. These are the available targets related to amplitude and stereo positioning: amplitude amplitude_oncc volume volume_oncc pan pan_oncc width width_oncc Targets for pitch: pitch pitch_oncc Targets for filters: cutoff cutoff_oncc resonance resonance_oncc cutoff2 cutoff2_oncc resonance2 resonance2_oncc Targets for EQ bands: eqNbw eqNbw_oncc eqNfreq eqNfreq_oncc eqNgain eqNgain_oncc Targets for modulating LFOs: depth_lfo depthadd_lfo freq_lfo These two need to be tested - are they for envelopes to modulate other envelopes? depth depth_oncc Targets for modulating decim and bitred do not appear to have been included in the specification.","title":"Envelope targets"},{"location":"tutorials/sfz2_modulations/#example-envelope","text":"Here is a simple pitch envelope which will start a note with a glide from up to an octave lower, with the depth and time modulated by MIDI CCs. The envelope will statt at a lower value at envelope point 0, and return the pitch to normal at envelope point 1. eg01_sustain=1 //Pitch envelope setup for slides eg01_level0=1 eg01_level1=0 eg01_time0=0 eg01_time1=0 eg01_pitch_oncc100=-1200 eg01_time1_oncc101=1","title":"Example envelope"},{"location":"tutorials/sfz2_modulations/#using-lfos-and-envelopes-together","text":"Here is an example of using both an envelope and an LFO to modulate pitch, with common depth and delay parameters. The goal here is asymmetrical pitch vibrato - vibrato which does not go up and down around the original pitch, but instead only goes below it. This is idiomatic with saxophones, and is also how vibrato with certain types of non-floating guitar bridges works (string-bending vibrato is similar, of course, but in the other direction). Shifting the phase of LFO01 will make the vibrato waveform start at the top. We also need to lower the pitch by the same amount as the vibrato depth. Using an envelope for this allows us to delay the onset of the vibrato (again, an important element of idiomatic saxophone vibrato) without a discontinuous jump in pitch. lfo01_pitch_oncc111=20 //Saxy vibrato LFO - goes down from the main pitch lfo01_freq=2 lfo01_freq_oncc112=8 lfo01_phase=0.25 //To make it start at the top lfo01_delay_oncc116=1 eg01_pitch_oncc111=20 eg01_sustain=1 eg01_level0=0 eg01_level1=0 eg01_level2=-1 eg01_time0=0 eg01_time1=0 eg01_time1_oncc116=1 eg01_time2=0","title":"Using LFOs and envelopes together"},{"location":"tutorials/sfz2_modulations/#using-sfz1-and-sfz2-modulations-together","text":"Both SFZ1 and SFZ2 modulations may be mixed freely. Indeed, it may be simpler to accomplish the above using the SFZ1 pitch envelope, as it is sufficient in this case, with the SFZ2 LFO. Setting the initial phase and modulating the delay with MIDI CC would not be possible with the SFZ1 pitch LFO. lfo01_pitch_oncc111=20 //Saxy vibrato LFO - goes down from the main pitch lfo01_freq=2 lfo01_freq_oncc112=8 lfo01_phase=0.25 //To make it start at the top lfo01_delay_oncc116=1 pitcheg_delay_oncc116=1 //Pitch envelope to drop the central pitch when sax vibrato kicks in pitcheg_depth_oncc111=-20","title":"Using SFZ1 and SFZ2 modulations together"},{"location":"tutorials/sfz2_modulations/#smoothccn-and-stepccn","text":"Most MIDI CC modulations, though not all, can have use smoothccN and stepccN . These work similarly to bend_smooth and bend_step . SmoothccN adds \"inertia\" to a modulation, so quickly changing the MIDI CC value has a slower effect on the modulation target than it would normally. StepccN causes the modulation to happen in a discrete number of steps. Setting the number of steps to 1 would make the modulation an all-or-nothing control. This is what's possible under the SFZ2 specification. There are some additional modulations available as ARIA extensions , with amplitude_onccN being a very useful one.","title":"SmoothccN and stepccN"},{"location":"tutorials/strum/","text":"Strumming can be difficult to produce with samples. SFZ does have some capabilities to make it a little easier. Creating a strum is basically triggering several single-string samples with some of them delayed slightly. Similar but even simpler is a drum flam, which is two drum hits in rapid succession. <region> sample=snare1.wav <region> delay=0.03 sample=snare2.wav Basic Guitar Chord Strum Here is how an open E major chord could be triggered with a single key: <group> key=40 <region> sample=e4.wav <region> delay=0.02 sample=b4.wav <region> delay=0.04 sample=e5.wav <region> delay=0.06 sample=g#4.wav <region> delay=0.08 sample=b4.wav <region> delay=0.1 sample=e6.wav This is a downward strum - physically the lower strings on a guitar are located higher, so downward strums begin with the lowest notes. An upstroke would have the same samples but with the delays in reversed order, so it starts with the higest notes. <group> key=40 <region> sample=e4.wav delay=0.1 <region> delay=0.08 sample=b4.wav <region> delay=0.06 sample=e5.wav <region> delay=0.04 sample=g#4.wav <region> delay=0.02 sample=b4.wav <region> sample=e6.wav Different Chord Types An E minor chord would be similar, only with a G instead of the G#. Leaving out the upward strum: <global> sw_lokey=36 sw_hikey=37 sw_default=36 <group> key=40 <region> sample=e4.wav <region> delay=0.02 sample=b4.wav <region> delay=0.04 sample=e5.wav //Fourth string is different for major versus minor chords. <region> sw_last=36 sw_label=Major delay=0.06 sample=g#4.wav <region> sw_last=37 sw_label=Minor delay=0.06 sample=g4.wav <region> delay=0.08 sample=b4.wav <region> delay=0.1 sample=e6.wav Of course for non-barre chords, there could be differences in voicings for more than one string, but the principle remains the same. The free Emilyguitar instrument located at https://github.com/sfzinstruments/karoryfer.emilyguitar includes a simple strum patch with keyswitchable power chords, major barre chords and minor barre chords. It has downward strums only with a very short strum time. However, it is not well-organized and not at all commented, its patches being just output from sfzed. Somewhat more organized and including power chords (which are simply the lowest three strings of the barre chord), our E chord might look like this: <global> sw_lokey=36 sw_hikey=38 sw_default=36 <group> key=40 //Lowest three strings are the same regardless of keyswitch <region> sample=e4.wav <region> delay=0.02 sample=b4.wav <region> delay=0.04 sample=e5.wav //In order to display the keyswitch label for power chords, //we need a placeholder <group> key=40 sw_last=37 sw_label=Power <region> sample=*silence ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 //Fourth string is different for major versus minor chords //It is not triggered at all for power chords <group> key=40 <region> sw_last=36 sw_label=Major delay=0.06 sample=g#4.wav <region> sw_last=37 sw_label=Minor delay=0.06 sample=g4.wav //Top two strings are not triggered for power chords //Duplicated for major and minor keyswitches <group> key=40 sw_last=36 sw_label=Major <region> delay=0.08 sample=b4.wav <region> delay=0.1 sample=e6.wav <group> key=40 sw_last=37 sw_label=Minor <region> delay=0.08 sample=b4.wav <region> delay=0.1 sample=e6.wav For upwards strums, simply reversing the order of delay values would result in the power chords being delayed as the e5.wav region would be the first sample triggered, and it would have 0.006 seconds of delay. This would not be good. Therefore, if we want to add upwards strums on lower keyswitches, we might end up with something like this: <global> sw_lokey=33 sw_hikey=38 sw_default=36 //Default is major chord, downward strum //Lower three strings for barre chords <group> key=40 sw_last=35 sw_label=Major Up <region> sample=e4.wav delay=0.1 <region> delay=0.08 sample=b4.wav <region> delay=0.06 sample=e5.wav <group> key=40 sw_last=34 sw_label=Minor Up <region> sample=e4.wav delay=0.1 <region> delay=0.08 sample=b4.wav <region> delay=0.06 sample=e5.wav //Lower three strings for power chords <group> key=40 sw_last=33 sw_label=Power Up <region> sample=e4.wav delay=0.04 <region> delay=0.02 sample=b4.wav <region> sample=e5.wav //Fourth string is different for major versus minor chords //It is not triggered at all for power chords <group> key=40 <region> sw_last=35 sw_label=Major Up delay=0.004 sample=g#4.wav <region> sw_last=34 sw_label=Minor Up delay=0.004 sample=g4.wav //Top two strings are not triggered for power chords //Duplicated for major and minor keyswitches <group> key=40 sw_last=35 sw_label=Major Up <region> delay=0.02 sample=b4.wav <region> sample=e6.wav <group> key=40 sw_last=34 sw_label=Minor up <region> delay=0.02 sample=b4.wav <region> sample=e6.wav Depending on needs, this might not be worth implementing, as duplicaton of regions adds to the time required for many SFZ players (certainly ARIA/sforzando) to parse and open an instrument. It is, however, certainly possible. Adjusting Time The above strums all have a fixed duration. Adjusting strum time is easily done by replacing the fixed delay with a modulated one. Going back to the simple E major example for brevity's sake: <group> key=40 <region> sample=e4.wav <region> delay_cc1=0.2 sample=b4.wav <region> delay_cc1=0.4 sample=e5.wav <region> delay_cc1=0.6 sample=g#4.wav <region> delay_cc1=0.8 sample=b4.wav <region> delay_cc1=1 sample=e6.wav It would also be easy to add a small random delay to each voice. However, because delay is not an available target for the var modulator, it is not possible to have an adjustable amount of randomization, or make the random amount smaller when the CC adjusting the non-random delay is low. This means adding a simple delay_random to each voice would create the risk of \"earlier\" notes actually sounding after \"later\" ones when the non-random delay is close to zero. However, making the delay partially fixed and partially adjustable avoids this. <group> key=40 <region> sample=e4.wav <region> delay=0.01 delay_cc1=0.2 delay_random=0.01 sample=b4.wav <region> delay=0.02 delay_cc1=0.4 delay_random=0.01 sample=e5.wav <region> delay=0.03 delay_cc1=0.6 delay_random=0.01 sample=g#4.wav <region> delay=0.04 delay_cc1=0.8 delay_random=0.01 sample=b4.wav <region> delay=0.05 delay_cc1=1 delay_random=0.01 sample=e6.wav Ringing And Muting With the above examples, the samples will play until a note-off message, then follow the usual amp envelope release. In reality, the strings will often ring until the string is hit again, and it can be more convenient to have the samples always play in their entirety unless muted: <global> loop_mode=one_shot <group> key=40 <region> sample=e4.wav group=6 off_by=6 <region> delay_cc1=0.2 sample=b4.wav group=5 off_by=5 <region> delay_cc1=0.4 sample=e5.wav group=4 off_by=4 <region> delay_cc1=0.6 sample=g#4.wav group=3 off_by=3 <region> delay_cc1=0.8 sample=b4.wav group=2 off_by=2 <region> delay_cc1=1 sample=e6.wav group=1 off_by=1 Note that a new strum will mute all strings, without waiting for their delay for that specific string to be completed. There is currently elegant solution known for this. Using a longer off time or triggering a release sample could be possible workarounds to fill the sonic gap, though. On the positive side, a partial strum that does not hit all the strings would let the other strings keep ringing. If one shot mode is used, it's probably also useful to allow for quickly muting all strings when desired. That can be done with a placeholder region for each string, and combining those regions on another key, here one above the octave of the strums. <group> key=60 ampeg_sustain=0 ampeg_release=0 <region> sample=*silence group=6 off_by=6 <region> sample=*silence group=5 off_by=5 <region> sample=*silence group=4 off_by=4 <region> sample=*silence group=3 off_by=3 <region> sample=*silence group=2 off_by=2 <region> sample=*silence group=1 off_by=1 Harp Glissandi Harp glissandi could be set up very similarly to a guitar strum, only with potentially a lot more notes. For simplicty's sake, let's consider just one octave. Speed is still controlled by CC1, and MIDI note 24 will trigger an upward glissando starting with the C4 note. <group> key=24 <region> sample=c4.wav <region> sample=d4.wav delay_cc1=0.1 <region> sample=e4.wav delay_cc1=0.2 <region> sample=f4.wav delay_cc1=0.3 <region> sample=g4.wav delay_cc1=0.4 <region> sample=a4.wav delay_cc1=0.5 <region> sample=b4.wav delay_cc1=0.6 <region> sample=c5.wav delay_cc1=0.7 In order to make this more usable, we can add another control which will determine for how many notes the gliss keeps going before it stops. Let's use CC4. <group> key=24 //First three notes are not affected by CC4, and are always played <region> sample=c4.wav <region> sample=d4.wav delay_cc1=0.1 <region> sample=e4.wav delay_cc1=0.2 <region> sample=f4.wav delay_cc1=0.3 locc4=1 <region> sample=g4.wav delay_cc1=0.4 locc4=32 <region> sample=a4.wav delay_cc1=0.5 locc4=64 <region> sample=b4.wav delay_cc1=0.6 locc4=96 <region> sample=c5.wav delay_cc1=0.7 locc4=127 This is essentially how a harp glissando on a folk harp operates. Concert harps have pedals which allow the retuning of strings to allow playing other scales, and this would need to be implemented, perhaps with a different MIDI CC for each pitch class. Strumming the drone strings on a Hungarian zither also works essentially as described here. Lyres And Zithers Many folk lyres, guslis etc. are tuned diatonically and chords on those are played by muting some strings, and strumming across both the open and muted strings. Keyswitches in another octave could be added to mute the strings, so that samples are only played when the switch matching that string is down. This basically works like a harp gliss, but the samples for the muted strings are not played. The keyswitches will not be displayed on the keyboard by most sfz players, so it will also likely be necessary to add some placeholder regions just to make them display. It's also common to strum across fewer than all the strings; this is basically what the power chord in the above guitar examples is. Instead of keyswitching, it is also possible to have partial strums on different keys (though this can easily require more keys than an 88-key keyboard), or selectable by CC, note velocity and possibly other variables as well. The below example uses CC4 to control how many strings are strummed. <group> key=24 //First three notes are not affected by CC4 <region> sample=c4.wav sw_down=36 <region> sample=d4.wav delay_cc1=0.1 sw_down=38 <region> sample=e4.wav delay_cc1=0.2 sw_down=40 <region> sample=f4.wav delay_cc1=0.3 sw_down=41 locc4=1 <region> sample=g4.wav delay_cc1=0.4 sw_down=43 locc4=32 <region> sample=a4.wav delay_cc1=0.5 sw_down=45 locc4=64 <region> sample=b4.wav delay_cc1=0.6 sw_down=47 locc4=96 <region> sample=c5.wav delay_cc1=0.7 sw_down=48 locc4=127 //Placeholders to get the switch keys to be visible <group> sample=*silence ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 <region> key=36 <region> key=38 <region> key=40 <region> key=41 <region> key=43 <region> key=45 <region> key=47 <region> key=48 For more realism, muted samples could be triggered for the strings which are not down. Although muting the strings for the keyswitches which are up and skipping the strings where the switch is down would be more analogous to the way the instruments are played in real life, this sort of \"negative space\" chord fingering is much more awkward for most users to play on a keyboard. It could easily be accomplished by merely switching the sw_up and sw_down opcodes in the below example. <group> key=24 //Ringing strings //First three notes are not affected by CC4 <region> sample=c4.wav sw_down=36 <region> sample=d4.wav delay_cc1=0.1 sw_down=38 <region> sample=e4.wav delay_cc1=0.2 sw_down=40 <region> sample=f4.wav delay_cc1=0.3 sw_down=41 locc4=1 <region> sample=g4.wav delay_cc1=0.4 sw_down=43 locc4=32 <region> sample=a4.wav delay_cc1=0.5 sw_down=45 locc4=64 <region> sample=b4.wav delay_cc1=0.6 sw_down=47 locc4=96 <region> sample=c5.wav delay_cc1=0.7 sw_down=48 locc4=127 //Muted strings //First three notes are not affected by CC4 <region> sample=c4_muted.wav sw_up=36 <region> sample=d4_muted.wav delay_cc1=0.1 sw_up=38 <region> sample=e4_muted.wav delay_cc1=0.2 sw_up=40 <region> sample=f4_muted.wav delay_cc1=0.3 sw_up=41 locc4=1 <region> sample=g4_muted.wav delay_cc1=0.4 sw_up=43 locc4=32 <region> sample=a4_muted.wav delay_cc1=0.5 sw_up=45 locc4=64 <region> sample=b4_muted.wav delay_cc1=0.6 sw_up=47 locc4=96 <region> sample=c5_muted.wav delay_cc1=0.7 sw_up=48 locc4=127 //Placeholders to get the switch keys to be visible <group> sample=*silence ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 <region> key=36 <region> key=38 <region> key=40 <region> key=41 <region> key=43 <region> key=45 <region> key=47 <region> key=48 Chromatic Strumming On Diatonic Instruments The cithara barbarica instrument at https://github.com/sfzinstruments/cithara-barbarica has a patch like this. It simply duplicates each string's regions to cover the \"missing\" pitches. This works fine as long as there are no muted samples used for the stopped strings, and having a muted string sound every half-step would not be idiomatic for instruments other than the very rare chromatic gusli. One way to have muted sounds while playing chromatically would be to always trigger a muted sound for whatever the \"real\" pitch of each string should be, but have it instantly muted if a pitch in that string's range is played. This is not great, as the muted sound would be a half-step off, but as the muted strings are shortened and produce a higher pitch anyway, it seems to work well enough. <group> key=26 //Muted regions, each with its own group and off_by <region> sample=d4_muted.wav group=11 off_by=21 <region> sample=e4_muted.wav group=12 off_by=22 delay_cc1=0.100 <region> sample=f4_muted.wav group=13 off_by=23 delay_cc1=0.200 //Non-muted regions, with groups that will mute the above regions if one of the keys covered by that sample is held down <region> sample=d4_finger.wav sw_down=36 group=21 transpose=-2 <region> sample=d4_finger.wav sw_down=37 group=21 transpose=-1 <region> sample=d4_finger.wav sw_down=38 group=21 <region> sample=e4_finger.wav sw_down=39 group=22 transpose=-1 delay_cc1=0.100 <region> sample=e4_finger.wav sw_down=40 group=22 delay_cc1=0.100 <region> sample=f4_finger.wav sw_down=41 group=23 delay_cc1=0.200 A more realistic way to handle this would be to have a MIDI CC for each string to set its tuning, so for example the C string could sound a B or C# note, like on a concert harp with pedals. However, this is probably not very convenient for most players who would rather hit a B note to sound a B. This, of course, would not actually be chromatic - but not limited to a single scale. Further Possibilities In reality, a strum will transfer force to the first strings it hits, and subsequent strings will be hit with a little less force, and the delay between strings might also be nonlinear. This tutorial is open source, so feel free to contribute.","title":"Strums"},{"location":"tutorials/strum/#basic-guitar-chord-strum","text":"Here is how an open E major chord could be triggered with a single key: <group> key=40 <region> sample=e4.wav <region> delay=0.02 sample=b4.wav <region> delay=0.04 sample=e5.wav <region> delay=0.06 sample=g#4.wav <region> delay=0.08 sample=b4.wav <region> delay=0.1 sample=e6.wav This is a downward strum - physically the lower strings on a guitar are located higher, so downward strums begin with the lowest notes. An upstroke would have the same samples but with the delays in reversed order, so it starts with the higest notes. <group> key=40 <region> sample=e4.wav delay=0.1 <region> delay=0.08 sample=b4.wav <region> delay=0.06 sample=e5.wav <region> delay=0.04 sample=g#4.wav <region> delay=0.02 sample=b4.wav <region> sample=e6.wav","title":"Basic Guitar Chord Strum"},{"location":"tutorials/strum/#different-chord-types","text":"An E minor chord would be similar, only with a G instead of the G#. Leaving out the upward strum: <global> sw_lokey=36 sw_hikey=37 sw_default=36 <group> key=40 <region> sample=e4.wav <region> delay=0.02 sample=b4.wav <region> delay=0.04 sample=e5.wav //Fourth string is different for major versus minor chords. <region> sw_last=36 sw_label=Major delay=0.06 sample=g#4.wav <region> sw_last=37 sw_label=Minor delay=0.06 sample=g4.wav <region> delay=0.08 sample=b4.wav <region> delay=0.1 sample=e6.wav Of course for non-barre chords, there could be differences in voicings for more than one string, but the principle remains the same. The free Emilyguitar instrument located at https://github.com/sfzinstruments/karoryfer.emilyguitar includes a simple strum patch with keyswitchable power chords, major barre chords and minor barre chords. It has downward strums only with a very short strum time. However, it is not well-organized and not at all commented, its patches being just output from sfzed. Somewhat more organized and including power chords (which are simply the lowest three strings of the barre chord), our E chord might look like this: <global> sw_lokey=36 sw_hikey=38 sw_default=36 <group> key=40 //Lowest three strings are the same regardless of keyswitch <region> sample=e4.wav <region> delay=0.02 sample=b4.wav <region> delay=0.04 sample=e5.wav //In order to display the keyswitch label for power chords, //we need a placeholder <group> key=40 sw_last=37 sw_label=Power <region> sample=*silence ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 //Fourth string is different for major versus minor chords //It is not triggered at all for power chords <group> key=40 <region> sw_last=36 sw_label=Major delay=0.06 sample=g#4.wav <region> sw_last=37 sw_label=Minor delay=0.06 sample=g4.wav //Top two strings are not triggered for power chords //Duplicated for major and minor keyswitches <group> key=40 sw_last=36 sw_label=Major <region> delay=0.08 sample=b4.wav <region> delay=0.1 sample=e6.wav <group> key=40 sw_last=37 sw_label=Minor <region> delay=0.08 sample=b4.wav <region> delay=0.1 sample=e6.wav For upwards strums, simply reversing the order of delay values would result in the power chords being delayed as the e5.wav region would be the first sample triggered, and it would have 0.006 seconds of delay. This would not be good. Therefore, if we want to add upwards strums on lower keyswitches, we might end up with something like this: <global> sw_lokey=33 sw_hikey=38 sw_default=36 //Default is major chord, downward strum //Lower three strings for barre chords <group> key=40 sw_last=35 sw_label=Major Up <region> sample=e4.wav delay=0.1 <region> delay=0.08 sample=b4.wav <region> delay=0.06 sample=e5.wav <group> key=40 sw_last=34 sw_label=Minor Up <region> sample=e4.wav delay=0.1 <region> delay=0.08 sample=b4.wav <region> delay=0.06 sample=e5.wav //Lower three strings for power chords <group> key=40 sw_last=33 sw_label=Power Up <region> sample=e4.wav delay=0.04 <region> delay=0.02 sample=b4.wav <region> sample=e5.wav //Fourth string is different for major versus minor chords //It is not triggered at all for power chords <group> key=40 <region> sw_last=35 sw_label=Major Up delay=0.004 sample=g#4.wav <region> sw_last=34 sw_label=Minor Up delay=0.004 sample=g4.wav //Top two strings are not triggered for power chords //Duplicated for major and minor keyswitches <group> key=40 sw_last=35 sw_label=Major Up <region> delay=0.02 sample=b4.wav <region> sample=e6.wav <group> key=40 sw_last=34 sw_label=Minor up <region> delay=0.02 sample=b4.wav <region> sample=e6.wav Depending on needs, this might not be worth implementing, as duplicaton of regions adds to the time required for many SFZ players (certainly ARIA/sforzando) to parse and open an instrument. It is, however, certainly possible.","title":"Different Chord Types"},{"location":"tutorials/strum/#adjusting-time","text":"The above strums all have a fixed duration. Adjusting strum time is easily done by replacing the fixed delay with a modulated one. Going back to the simple E major example for brevity's sake: <group> key=40 <region> sample=e4.wav <region> delay_cc1=0.2 sample=b4.wav <region> delay_cc1=0.4 sample=e5.wav <region> delay_cc1=0.6 sample=g#4.wav <region> delay_cc1=0.8 sample=b4.wav <region> delay_cc1=1 sample=e6.wav It would also be easy to add a small random delay to each voice. However, because delay is not an available target for the var modulator, it is not possible to have an adjustable amount of randomization, or make the random amount smaller when the CC adjusting the non-random delay is low. This means adding a simple delay_random to each voice would create the risk of \"earlier\" notes actually sounding after \"later\" ones when the non-random delay is close to zero. However, making the delay partially fixed and partially adjustable avoids this. <group> key=40 <region> sample=e4.wav <region> delay=0.01 delay_cc1=0.2 delay_random=0.01 sample=b4.wav <region> delay=0.02 delay_cc1=0.4 delay_random=0.01 sample=e5.wav <region> delay=0.03 delay_cc1=0.6 delay_random=0.01 sample=g#4.wav <region> delay=0.04 delay_cc1=0.8 delay_random=0.01 sample=b4.wav <region> delay=0.05 delay_cc1=1 delay_random=0.01 sample=e6.wav","title":"Adjusting Time"},{"location":"tutorials/strum/#ringing-and-muting","text":"With the above examples, the samples will play until a note-off message, then follow the usual amp envelope release. In reality, the strings will often ring until the string is hit again, and it can be more convenient to have the samples always play in their entirety unless muted: <global> loop_mode=one_shot <group> key=40 <region> sample=e4.wav group=6 off_by=6 <region> delay_cc1=0.2 sample=b4.wav group=5 off_by=5 <region> delay_cc1=0.4 sample=e5.wav group=4 off_by=4 <region> delay_cc1=0.6 sample=g#4.wav group=3 off_by=3 <region> delay_cc1=0.8 sample=b4.wav group=2 off_by=2 <region> delay_cc1=1 sample=e6.wav group=1 off_by=1 Note that a new strum will mute all strings, without waiting for their delay for that specific string to be completed. There is currently elegant solution known for this. Using a longer off time or triggering a release sample could be possible workarounds to fill the sonic gap, though. On the positive side, a partial strum that does not hit all the strings would let the other strings keep ringing. If one shot mode is used, it's probably also useful to allow for quickly muting all strings when desired. That can be done with a placeholder region for each string, and combining those regions on another key, here one above the octave of the strums. <group> key=60 ampeg_sustain=0 ampeg_release=0 <region> sample=*silence group=6 off_by=6 <region> sample=*silence group=5 off_by=5 <region> sample=*silence group=4 off_by=4 <region> sample=*silence group=3 off_by=3 <region> sample=*silence group=2 off_by=2 <region> sample=*silence group=1 off_by=1","title":"Ringing And Muting"},{"location":"tutorials/strum/#harp-glissandi","text":"Harp glissandi could be set up very similarly to a guitar strum, only with potentially a lot more notes. For simplicty's sake, let's consider just one octave. Speed is still controlled by CC1, and MIDI note 24 will trigger an upward glissando starting with the C4 note. <group> key=24 <region> sample=c4.wav <region> sample=d4.wav delay_cc1=0.1 <region> sample=e4.wav delay_cc1=0.2 <region> sample=f4.wav delay_cc1=0.3 <region> sample=g4.wav delay_cc1=0.4 <region> sample=a4.wav delay_cc1=0.5 <region> sample=b4.wav delay_cc1=0.6 <region> sample=c5.wav delay_cc1=0.7 In order to make this more usable, we can add another control which will determine for how many notes the gliss keeps going before it stops. Let's use CC4. <group> key=24 //First three notes are not affected by CC4, and are always played <region> sample=c4.wav <region> sample=d4.wav delay_cc1=0.1 <region> sample=e4.wav delay_cc1=0.2 <region> sample=f4.wav delay_cc1=0.3 locc4=1 <region> sample=g4.wav delay_cc1=0.4 locc4=32 <region> sample=a4.wav delay_cc1=0.5 locc4=64 <region> sample=b4.wav delay_cc1=0.6 locc4=96 <region> sample=c5.wav delay_cc1=0.7 locc4=127 This is essentially how a harp glissando on a folk harp operates. Concert harps have pedals which allow the retuning of strings to allow playing other scales, and this would need to be implemented, perhaps with a different MIDI CC for each pitch class. Strumming the drone strings on a Hungarian zither also works essentially as described here.","title":"Harp Glissandi"},{"location":"tutorials/strum/#lyres-and-zithers","text":"Many folk lyres, guslis etc. are tuned diatonically and chords on those are played by muting some strings, and strumming across both the open and muted strings. Keyswitches in another octave could be added to mute the strings, so that samples are only played when the switch matching that string is down. This basically works like a harp gliss, but the samples for the muted strings are not played. The keyswitches will not be displayed on the keyboard by most sfz players, so it will also likely be necessary to add some placeholder regions just to make them display. It's also common to strum across fewer than all the strings; this is basically what the power chord in the above guitar examples is. Instead of keyswitching, it is also possible to have partial strums on different keys (though this can easily require more keys than an 88-key keyboard), or selectable by CC, note velocity and possibly other variables as well. The below example uses CC4 to control how many strings are strummed. <group> key=24 //First three notes are not affected by CC4 <region> sample=c4.wav sw_down=36 <region> sample=d4.wav delay_cc1=0.1 sw_down=38 <region> sample=e4.wav delay_cc1=0.2 sw_down=40 <region> sample=f4.wav delay_cc1=0.3 sw_down=41 locc4=1 <region> sample=g4.wav delay_cc1=0.4 sw_down=43 locc4=32 <region> sample=a4.wav delay_cc1=0.5 sw_down=45 locc4=64 <region> sample=b4.wav delay_cc1=0.6 sw_down=47 locc4=96 <region> sample=c5.wav delay_cc1=0.7 sw_down=48 locc4=127 //Placeholders to get the switch keys to be visible <group> sample=*silence ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 <region> key=36 <region> key=38 <region> key=40 <region> key=41 <region> key=43 <region> key=45 <region> key=47 <region> key=48 For more realism, muted samples could be triggered for the strings which are not down. Although muting the strings for the keyswitches which are up and skipping the strings where the switch is down would be more analogous to the way the instruments are played in real life, this sort of \"negative space\" chord fingering is much more awkward for most users to play on a keyboard. It could easily be accomplished by merely switching the sw_up and sw_down opcodes in the below example. <group> key=24 //Ringing strings //First three notes are not affected by CC4 <region> sample=c4.wav sw_down=36 <region> sample=d4.wav delay_cc1=0.1 sw_down=38 <region> sample=e4.wav delay_cc1=0.2 sw_down=40 <region> sample=f4.wav delay_cc1=0.3 sw_down=41 locc4=1 <region> sample=g4.wav delay_cc1=0.4 sw_down=43 locc4=32 <region> sample=a4.wav delay_cc1=0.5 sw_down=45 locc4=64 <region> sample=b4.wav delay_cc1=0.6 sw_down=47 locc4=96 <region> sample=c5.wav delay_cc1=0.7 sw_down=48 locc4=127 //Muted strings //First three notes are not affected by CC4 <region> sample=c4_muted.wav sw_up=36 <region> sample=d4_muted.wav delay_cc1=0.1 sw_up=38 <region> sample=e4_muted.wav delay_cc1=0.2 sw_up=40 <region> sample=f4_muted.wav delay_cc1=0.3 sw_up=41 locc4=1 <region> sample=g4_muted.wav delay_cc1=0.4 sw_up=43 locc4=32 <region> sample=a4_muted.wav delay_cc1=0.5 sw_up=45 locc4=64 <region> sample=b4_muted.wav delay_cc1=0.6 sw_up=47 locc4=96 <region> sample=c5_muted.wav delay_cc1=0.7 sw_up=48 locc4=127 //Placeholders to get the switch keys to be visible <group> sample=*silence ampeg_decay=0 ampeg_sustain=0 ampeg_release=0 <region> key=36 <region> key=38 <region> key=40 <region> key=41 <region> key=43 <region> key=45 <region> key=47 <region> key=48","title":"Lyres And Zithers"},{"location":"tutorials/strum/#chromatic-strumming-on-diatonic-instruments","text":"The cithara barbarica instrument at https://github.com/sfzinstruments/cithara-barbarica has a patch like this. It simply duplicates each string's regions to cover the \"missing\" pitches. This works fine as long as there are no muted samples used for the stopped strings, and having a muted string sound every half-step would not be idiomatic for instruments other than the very rare chromatic gusli. One way to have muted sounds while playing chromatically would be to always trigger a muted sound for whatever the \"real\" pitch of each string should be, but have it instantly muted if a pitch in that string's range is played. This is not great, as the muted sound would be a half-step off, but as the muted strings are shortened and produce a higher pitch anyway, it seems to work well enough. <group> key=26 //Muted regions, each with its own group and off_by <region> sample=d4_muted.wav group=11 off_by=21 <region> sample=e4_muted.wav group=12 off_by=22 delay_cc1=0.100 <region> sample=f4_muted.wav group=13 off_by=23 delay_cc1=0.200 //Non-muted regions, with groups that will mute the above regions if one of the keys covered by that sample is held down <region> sample=d4_finger.wav sw_down=36 group=21 transpose=-2 <region> sample=d4_finger.wav sw_down=37 group=21 transpose=-1 <region> sample=d4_finger.wav sw_down=38 group=21 <region> sample=e4_finger.wav sw_down=39 group=22 transpose=-1 delay_cc1=0.100 <region> sample=e4_finger.wav sw_down=40 group=22 delay_cc1=0.100 <region> sample=f4_finger.wav sw_down=41 group=23 delay_cc1=0.200 A more realistic way to handle this would be to have a MIDI CC for each string to set its tuning, so for example the C string could sound a B or C# note, like on a concert harp with pedals. However, this is probably not very convenient for most players who would rather hit a B note to sound a B. This, of course, would not actually be chromatic - but not limited to a single scale.","title":"Chromatic Strumming On Diatonic Instruments"},{"location":"tutorials/strum/#further-possibilities","text":"In reality, a strum will transfer force to the first strings it hits, and subsequent strings will be hit with a little less force, and the delay between strings might also be nonlinear. This tutorial is open source, so feel free to contribute.","title":"Further Possibilities"},{"location":"tutorials/subtractive_synths/","text":"Introduction This tutorial describes implementing typical subtractive synthesizer modulations - filters, envelopes and LFOs - in SFZ. It uses the Caveman Cosmonaut instrument by Karoryfer Samples as an example. This does not cover all modulations used in classic hardware subtractive synths, but it's a start. Basic amplifier envelope Though subtractive synths get their name from having frequencies subtracted from the sound by filter, the volume envelope is probably the most fundamental modulation. Here is an AHDSR envelope including \u2039control\u203a parameter labels and defaults. <control> label_cc100=Attack time label_cc101=Hold time label_cc102=Decay time label_cc103=Sustain level label_cc104=Release time set_cc102=63 set_cc103=51 set_cc104=31 <global> //AHDSR ampeg_attack=0.002 ampeg_sustain=0 ampeg_release=0.002 ampeg_attack_oncc100=0.5 ampeg_hold_oncc101=1 ampeg_decay_oncc102=5 ampeg_sustain_oncc103=100 ampeg_release_oncc104=2 An ADSR envelope would simple leave out the hold stage control, leaving the default hold time of zero. Further envelope possibilities The above envelope will affect all sounds, as it's set at the global level. In many classic synths, it's possible to have separate envelopes modulating the volume of different oscillators, for example using a shorter envelope to turn a noise oscillator into a short transient. If more envelope stages are required, an SFZ2 envelope with an arbitrary amount of points can be used to modulate amplitude instead of the SFZ1 envelope above. In the ARIA SFZ player, amplifier envelope durations are calculated once on trigger, which means changing envelope parameters other than sustain and release while a note is playing will not change the sound. The ampeg_dynamic opcode could be set to 1 in order to recalculate envelope parameters every time one of the control parameters receives a MIDI message, which could be closer to the behavior of most analog synthesizer hardware. Caveman Cosmonaut has a more unusual parameter called Env Soften, which has no effect on some oscillators which have more high-frequency content, and adds to the release and decay times of the warmer-sounding oscillators. This is highly unusual, but can be musically useful for things such as plucks, as the warmer sounds linger longer. This is similar to the effect of release or decay on a lowpass filter cutoff, but perhaps a little more organic. That's set per oscillator, rather than globally, like this, with CC 18 selecting the oscillator, and CC 106 being the envelope soften: <master> locc18=11 hicc18=20 ampeg_decay_oncc106=1.25 ampeg_release_oncc106=0.7 #include \"mappings/unitra_flutes.sfz\" <master> locc18=21 hicc18=30 ampeg_decay_oncc106=1 ampeg_release_oncc106=0.4 #include \"mappings/unitra_clarinet.sfz\" <master> locc18=31 hicc18=40 ampeg_decay_oncc106=1.5 ampeg_release_oncc106=0.6 #include \"mappings/unitra_trombone.sfz\" <master> locc18=41 hicc18=50 ampeg_decay_oncc106=0.5 ampeg_release_oncc106=0.2 #include \"mappings/unitra_trompette.sfz\" <master> locc18=51 hicc18=60 ampeg_decay_oncc106=1.25 ampeg_release_oncc106=0.5 #include \"mappings/unitra_violin.sfz\" <master> locc18=61 hicc18=70 #include \"mappings/unitra_tremolo.sfz\" <master> locc18=71 #include \"mappings/unitra_all.sfz\" Basic filter The filter in the example instrument is a single lowpass filter with cutoff and resonance controls, adjustable velocity tracking using var a two-stage filter cutoff envelope . <control> label_cc120=Filter cutoff label_cc121=Resonance label_cc124=Veltrack label_cc125=Pluck label_cc126=Filter attack label_cc127=Filter decay set_cc120=127 set_cc127=40 <global> //Lowpass filter cutoff=250 cutoff_cc120=9600 fil_keytrack=100 resonance=0 resonance_cc121=18 var01_cutoff=6000 //Velocity track var01_mod=mult var01_oncc131=1 var01_oncc124=1 cutoff_cc124=-3000 //Pluck envelope fileg_depth=0 fileg_depthcc125=8400 fileg_sustain=0 fileg_attack=0 fileg_attackcc126=0.5 fileg_decay=0.001 fileg_decaycc127=2 Filter keytracking Making the filter cutoff keytrack is a simple matter of setting the fil_keytrack to 100; however, things get more complicated if filter keytracking is not desired. Although fil_keytrack can be set to 0 and the base filter cutoff will then not keytrack, the filter cutoff modulation in SFZ is specified in cents, not Hertz. This means the amount of the cutoff which is modulated will keytrack, regardless of what fil_keytrack is set to. This isn't a big issue with most synthesizers, but when trying to make an adjustable highpass filter for all pieces of a drum kit except the kick, for example, it can make things complicated. Adjusting keytracking for the modulated amount requires using var and the extended CC 133 (MIDI key number). Var and extended CCs are already used above for the velocity tracking on the filter cutoff. The example instrument has a somewhat convoluted and unusual configuration for the filter keytracking, where when CC 120 has a very high value, the cutoff will be slightly above 22.05 kHz for all keys in the instrument's range, while the cutoff when CC 120 is at zero has 70% keytracking. This is not at all standard, and means the base cutoff has moderate positive keytracking while the cutoff modulation has negative keytracking. //By default, cutoff modulation is measured in cents //To make the modulation not keytrack, we make a kludge //Using var cutoff=250 var02_cutoff=9000 var02_mod=mult var02_oncc120=1 var02_curvecc120=0 var02_oncc133=1 var02_curvecc133=11 fil_keytrack=70 At the end of the SFZ file, the \u2039curve\u203a is then specified: <curve> curve_index=11 v000=1 v024=1 v084=0.63 v127=0.25 More filter possibilities It would be easy to have more filter envelope stages; only attack and decay are used above to keep things simple, as those parameters are enough to create basic plucks (zero attack, moderate decay) and 303 style basses (slightly longer attack, moderate decay). Using fil2_type and cutoff2 allows two filters in series, for example a lowpass and highpass filter. Fil_type can also be used to choose different filter types, perhaps with locc/hicc . Modulating the filter cutoff with LFOs is added below, in the vibrato section. Vibrato Vibrato can affect pitch, volume (for tremolo) and filter cutoff (for wobble). Here is a typical setup using one LFO to modulate all three. <control> label_cc111=Vibrato to pitch label_cc112=Vibrato speed label_cc113=Vibrato to cutoff label_cc114=Vibrato to volume label_cc115=Vibrato delay label_cc116=Vibrato fade set_cc112=40 <global> lfo01_pitch_oncc111=22 //Vibrato LFO lfo01_freq=0.1 lfo01_freq_oncc112=9.9 lfo01_delay_oncc115=0.500 lfo01_fade_oncc116=0.500 lfo01_volume_oncc114=6 //Wobble lfo01_cutoff=0 lfo01_cutoff_oncc113=3600 Humanized vibrato Humanization is obviously not a standard feature of synthesizers. Technically, though, it's not difficult to implement. The example instrument adds CC 117 for controlling the amount of randomization of the vibrato LFOs. This is similar to the humanization described in the vibrato tutorial , but using CC 135 to generate a true random number for each voice, which means any unison voices' vibrato will drift out of sync with those belonging to other voices. This is musically useful for creating more complex pads, for example. Similar principles could also be used to emulate analog oscillators' much more subtle pitch drift. <control> label_cc111=Vibrato to pitch label_cc112=Vibrato speed label_cc113=Vibrato to cutoff label_cc114=Vibrato to volume label_cc115=Vibrato delay label_cc116=Vibrato fade label_cc117=Vibrato humanize set_cc112=40 <global> //Vibrato and humanization setup lfo01_pitch_oncc111=22 //Vibrato LFO lfo01_freq=0.1 lfo01_freq_oncc112=9.9 lfo01_delay_oncc115=0.500 lfo01_fade_oncc116=0.500 lfo01_volume_oncc114=6 //Wobble lfo01_cutoff=0 lfo01_cutoff_oncc113=3600 lfo02_wave=1 //Second LFO to make things wobblier lfo02_phase=0 lfo02_phase_oncc135=1 //Phase randomized lfo02_freq=0.01 //Basically no movement at very slow speeds, just randomization lfo02_freq_oncc117=1 //Max rate is not very high, so it doesn't sound too obvious lfo02_pitch_oncc117=6 //Slight pitch wobbliness lfo02_freq_lfo01_oncc117=0.5 //Affect the rate of the other LFO for unsteady vibrato lfo02_freq_lfo01_oncc112=2.5 //Faster when the first LFO is going faster lfo03_wave=1 //And a third LFO for secondhand complex wobbliness lfo03_phase=0.4 lfo03_phase_oncc135=0.179 //Different phase response to random than the second LFO lfo03_freq=0.5 lfo03_freq_oncc117=-0.4 lfo03_freq_lfo2_oncc117=1 lfo03_pitch_oncc117=-4 lfo04_wave=1 //Fourth LFO for slowly changing the oscillator mix lfo04_phase_oncc135=1 lfo04_freq=0.01 lfo04_freq_oncc135=0.25 //Randomly from almost not moving at all to still pretty slow lfo04_volume_oncc117=1.5 //Slight volume changes Unison and detune Unison is a simple matter of triggering multiple regions with one MIDI note. If using a simple sound source such as a saw oscillators, all regions will sound identical so the only result will be additional volume. Making the unison more interesting requires some of: using different samples for each voice, detuning the voices, and shifting the phase of the voices. The example instrument uses many sets of samples from an analog keyboard, with every key producing a slightly different timbre, and transposed versions of those sounds used for unison. The detune and width amounts vary for each of the three oscillators, but here is a simplified version assuming there is only one oscillator. Note that although there is a width opcodes for use with stereo samples, in this case the left channel and right are separate mono samples, so pan is used to spread them in stereo - not width. As the samples here are quite long, offset_random is applied globally to effecitvely randomize each voice's phase. With true single-cycle waveforms, the max offset would have to be set to match each voice's max sample length. <control> label_cc25=Unison label_cc26=Width label_cc27=Detune set_cc26=63 set_cc27=63 <global> //Randomizing the start points of the samples to randomize phase offset_random=1000 //Center voice <master> #include \"sample_map_basic.sfz\" //Left voice <region> amplitude_cc25=100 amplitude_cc25=100 locc25=1 pan_cc26=-100 tune_cc27=-33 #include \"sample_map_transposed_1.sfz\" //Right voice <region> amplitude_cc25=100 locc25=1 pan_cc26=100 tune_cc27=33 amplitude_cc25=100 #include \"sample_map_transposed_2.sfz\" More complex detune Another highly unsual feature of Caveman Cosmonaut, though, is that the detune doesn't have to be fixed. There are additional detune controls which detune the additional voices more at the start of the note, and then drift towards a common pitch over time, using pitch envelopes . This is definitely not part of any typical hardware analog synthesizer's feature set, but it does have something in common with the way real world choirs or instrumental ensembles find a commmon pitch. <control> label_cc25=Unison label_cc26=Width label_cc27=Detune label_cc28=Extra detune amt label_cc29=Extra detune time set_cc26=63 set_cc27=63 set_cc29=16 <global> //Randomizing the start points of the samples to randomize phase offset_random=1000 //Pitch envelope defaults for the fancy detune pitcheg_sustain=0 pitcheg_decay_shape=-2 //Center voice <master> #include \"sample_map_basic.sfz\" //Left voice <region> amplitude_cc25=100 locc25=1 pan_cc26=-100 tune_cc27=-33 pitcheg_depth_oncc28=-150 pitcheg_decay_oncc29=5 #include \"sample_map_transposed_1.sfz\" //Right voice <region> amplitude_cc25=100 locc25=1 pan_cc26=100 tune_cc27=33 pitcheg_depth_oncc28=150 pitcheg_decay_oncc29=5 #include \"sample_map_transposed_2.sfz\" Waveform selection and oscillator mixing This is just locc/hicc for selection, and amplitude for volume controls. Mono mode and portamento This is implemented similarly to any non-synth - see our legato tutorial . Putting it all together This is the main file for the example instrument. The unison and detune settings, along with oscillator selection and mixing, are inside SFZ files added via the #include directives. <control> label_cc15=Bass Osc Vol label_cc16=Bass Osc Sel label_cc17=Osc 1 Vol label_cc18=Osc 1 Sel label_cc19=Osc 2 Vol label_cc20=Osc 2 Sel label_cc21=Osc 3 Vol label_cc22=Osc 3 Sel label_cc25=Unison label_cc26=Width label_cc27=Detune label_cc28=Extra detune amt label_cc29=Extra detune time label_cc100=Attack time label_cc101=Hold time label_cc102=Decay time label_cc103=Sustain level label_cc104=Release time label_cc106=Env soften label_cc108=Legato switch label_cc109=Porta time label_cc111=Vibrato to pitch label_cc112=Vibrato speed label_cc113=Vibrato to cutoff label_cc114=Vibrato to volume label_cc115=Vibrato delay label_cc116=Vibrato fade label_cc117=Unsteadiness label_cc120=Filter cutoff label_cc121=Resonance label_cc124=Veltrack label_cc125=Pluck label_cc126=Filter attack label_cc127=Filter decay set_cc15=100 set_cc16=15 set_cc17=127 set_cc18=63 set_cc19=100 set_cc20=15 set_cc21=100 set_cc22=44 set_cc26=63 set_cc27=63 set_cc29=16 set_cc102=63 set_cc103=51 set_cc104=31 set_cc109=31 set_cc112=40 set_cc120=127 set_cc127=40 <global> bend_down=-2400 bend_up=2400 off_mode=normal loop_mode=continuous offset=10000 offset_random=1000 //AHDSR ampeg_attack=0.002 ampeg_sustain=0 ampeg_release=0.002 ampeg_attack_oncc100=0.5 ampeg_hold_oncc101=1 ampeg_decay_oncc102=5 ampeg_sustain_oncc103=100 ampeg_release_oncc104=2 //Decay and release are affected by the soften parameter also //This is set separately for each oscillator //Filter //Lowpass filter //By default, cutoff modulation is measured in cents //To make the modulation not keytrack, we make a kludge //Using var cutoff=250 var02_cutoff=9000 var02_mod=mult var02_oncc120=1 var02_curvecc120=0 var02_oncc133=1 var02_curvecc133=11 fil_keytrack=70 resonance=0 resonance_cc121=18 var01_cutoff=6000 //Velocity track var01_mod=mult var01_oncc131=1 var01_oncc124=1 cutoff_cc124=-3000 //Pluck envelope fileg_depth=0 fileg_depthcc125=8400 fileg_sustain=0 fileg_attack=0 fileg_attackcc126=0.5 fileg_decay=0.001 fileg_decaycc127=2 //Vibrato and humanization setup lfo01_pitch_oncc111=22 //Vibrato LFO lfo01_freq=0.1 lfo01_freq_oncc112=9.9 lfo01_delay_oncc115=0.500 lfo01_fade_oncc116=0.500 lfo01_volume_oncc114=6 //Wobble lfo01_cutoff=0 lfo01_cutoff_oncc113=3600 lfo02_wave=1 //Second LFO to make things wobblier lfo02_phase=0 lfo02_phase_oncc135=1 //Phase randomized lfo02_freq=0.01 //Basically no movement at very slow speeds, just randomization lfo02_freq_oncc117=1 //Max rate is not very high, so it doesn't sound too obvious lfo02_pitch_oncc117=6 //Slight pitch wobbliness lfo02_freq_lfo01_oncc117=0.5 //Affect the rate of the other LFO for unsteady vibrato lfo02_freq_lfo01_oncc112=2.5 //Faster when the first LFO is going faster lfo03_wave=1 //And a third LFO for secondhand complex wobbliness lfo03_phase=0.4 lfo03_phase_oncc135=0.179 //Different phase response to random than the second LFO lfo03_freq=0.5 lfo03_freq_oncc117=-0.4 lfo03_freq_lfo2_oncc117=1 lfo03_pitch_oncc117=-4 lfo04_wave=1 //Fourth LFO for slowly changing the oscillator mix lfo04_phase_oncc135=1 lfo04_freq=0.01 lfo04_freq_oncc135=0.25 //Randomly from almost not moving at all to still pretty slow lfo04_volume_oncc117=1.5 //Slight volume changes //Some defaults for the fancy detune stuff pitcheg_sustain=0 pitcheg_decay_shape=-2 //And here come the oscillator mappings //First polyphonic mode #include \"mappings/poly_map.sfz\" #include \"mappings/mono_first_map.sfz\" #include \"mappings/mono_legato_map.sfz\" <curve> curve_index=11 v000=1 v024=1 v084=0.63 v127=0.25","title":"Subtractive synthesizers"},{"location":"tutorials/subtractive_synths/#introduction","text":"This tutorial describes implementing typical subtractive synthesizer modulations - filters, envelopes and LFOs - in SFZ. It uses the Caveman Cosmonaut instrument by Karoryfer Samples as an example. This does not cover all modulations used in classic hardware subtractive synths, but it's a start.","title":"Introduction"},{"location":"tutorials/subtractive_synths/#basic-amplifier-envelope","text":"Though subtractive synths get their name from having frequencies subtracted from the sound by filter, the volume envelope is probably the most fundamental modulation. Here is an AHDSR envelope including \u2039control\u203a parameter labels and defaults. <control> label_cc100=Attack time label_cc101=Hold time label_cc102=Decay time label_cc103=Sustain level label_cc104=Release time set_cc102=63 set_cc103=51 set_cc104=31 <global> //AHDSR ampeg_attack=0.002 ampeg_sustain=0 ampeg_release=0.002 ampeg_attack_oncc100=0.5 ampeg_hold_oncc101=1 ampeg_decay_oncc102=5 ampeg_sustain_oncc103=100 ampeg_release_oncc104=2 An ADSR envelope would simple leave out the hold stage control, leaving the default hold time of zero.","title":"Basic amplifier envelope"},{"location":"tutorials/subtractive_synths/#further-envelope-possibilities","text":"The above envelope will affect all sounds, as it's set at the global level. In many classic synths, it's possible to have separate envelopes modulating the volume of different oscillators, for example using a shorter envelope to turn a noise oscillator into a short transient. If more envelope stages are required, an SFZ2 envelope with an arbitrary amount of points can be used to modulate amplitude instead of the SFZ1 envelope above. In the ARIA SFZ player, amplifier envelope durations are calculated once on trigger, which means changing envelope parameters other than sustain and release while a note is playing will not change the sound. The ampeg_dynamic opcode could be set to 1 in order to recalculate envelope parameters every time one of the control parameters receives a MIDI message, which could be closer to the behavior of most analog synthesizer hardware. Caveman Cosmonaut has a more unusual parameter called Env Soften, which has no effect on some oscillators which have more high-frequency content, and adds to the release and decay times of the warmer-sounding oscillators. This is highly unusual, but can be musically useful for things such as plucks, as the warmer sounds linger longer. This is similar to the effect of release or decay on a lowpass filter cutoff, but perhaps a little more organic. That's set per oscillator, rather than globally, like this, with CC 18 selecting the oscillator, and CC 106 being the envelope soften: <master> locc18=11 hicc18=20 ampeg_decay_oncc106=1.25 ampeg_release_oncc106=0.7 #include \"mappings/unitra_flutes.sfz\" <master> locc18=21 hicc18=30 ampeg_decay_oncc106=1 ampeg_release_oncc106=0.4 #include \"mappings/unitra_clarinet.sfz\" <master> locc18=31 hicc18=40 ampeg_decay_oncc106=1.5 ampeg_release_oncc106=0.6 #include \"mappings/unitra_trombone.sfz\" <master> locc18=41 hicc18=50 ampeg_decay_oncc106=0.5 ampeg_release_oncc106=0.2 #include \"mappings/unitra_trompette.sfz\" <master> locc18=51 hicc18=60 ampeg_decay_oncc106=1.25 ampeg_release_oncc106=0.5 #include \"mappings/unitra_violin.sfz\" <master> locc18=61 hicc18=70 #include \"mappings/unitra_tremolo.sfz\" <master> locc18=71 #include \"mappings/unitra_all.sfz\"","title":"Further envelope possibilities"},{"location":"tutorials/subtractive_synths/#basic-filter","text":"The filter in the example instrument is a single lowpass filter with cutoff and resonance controls, adjustable velocity tracking using var a two-stage filter cutoff envelope . <control> label_cc120=Filter cutoff label_cc121=Resonance label_cc124=Veltrack label_cc125=Pluck label_cc126=Filter attack label_cc127=Filter decay set_cc120=127 set_cc127=40 <global> //Lowpass filter cutoff=250 cutoff_cc120=9600 fil_keytrack=100 resonance=0 resonance_cc121=18 var01_cutoff=6000 //Velocity track var01_mod=mult var01_oncc131=1 var01_oncc124=1 cutoff_cc124=-3000 //Pluck envelope fileg_depth=0 fileg_depthcc125=8400 fileg_sustain=0 fileg_attack=0 fileg_attackcc126=0.5 fileg_decay=0.001 fileg_decaycc127=2","title":"Basic filter"},{"location":"tutorials/subtractive_synths/#filter-keytracking","text":"Making the filter cutoff keytrack is a simple matter of setting the fil_keytrack to 100; however, things get more complicated if filter keytracking is not desired. Although fil_keytrack can be set to 0 and the base filter cutoff will then not keytrack, the filter cutoff modulation in SFZ is specified in cents, not Hertz. This means the amount of the cutoff which is modulated will keytrack, regardless of what fil_keytrack is set to. This isn't a big issue with most synthesizers, but when trying to make an adjustable highpass filter for all pieces of a drum kit except the kick, for example, it can make things complicated. Adjusting keytracking for the modulated amount requires using var and the extended CC 133 (MIDI key number). Var and extended CCs are already used above for the velocity tracking on the filter cutoff. The example instrument has a somewhat convoluted and unusual configuration for the filter keytracking, where when CC 120 has a very high value, the cutoff will be slightly above 22.05 kHz for all keys in the instrument's range, while the cutoff when CC 120 is at zero has 70% keytracking. This is not at all standard, and means the base cutoff has moderate positive keytracking while the cutoff modulation has negative keytracking. //By default, cutoff modulation is measured in cents //To make the modulation not keytrack, we make a kludge //Using var cutoff=250 var02_cutoff=9000 var02_mod=mult var02_oncc120=1 var02_curvecc120=0 var02_oncc133=1 var02_curvecc133=11 fil_keytrack=70 At the end of the SFZ file, the \u2039curve\u203a is then specified: <curve> curve_index=11 v000=1 v024=1 v084=0.63 v127=0.25","title":"Filter keytracking"},{"location":"tutorials/subtractive_synths/#more-filter-possibilities","text":"It would be easy to have more filter envelope stages; only attack and decay are used above to keep things simple, as those parameters are enough to create basic plucks (zero attack, moderate decay) and 303 style basses (slightly longer attack, moderate decay). Using fil2_type and cutoff2 allows two filters in series, for example a lowpass and highpass filter. Fil_type can also be used to choose different filter types, perhaps with locc/hicc . Modulating the filter cutoff with LFOs is added below, in the vibrato section.","title":"More filter possibilities"},{"location":"tutorials/subtractive_synths/#vibrato","text":"Vibrato can affect pitch, volume (for tremolo) and filter cutoff (for wobble). Here is a typical setup using one LFO to modulate all three. <control> label_cc111=Vibrato to pitch label_cc112=Vibrato speed label_cc113=Vibrato to cutoff label_cc114=Vibrato to volume label_cc115=Vibrato delay label_cc116=Vibrato fade set_cc112=40 <global> lfo01_pitch_oncc111=22 //Vibrato LFO lfo01_freq=0.1 lfo01_freq_oncc112=9.9 lfo01_delay_oncc115=0.500 lfo01_fade_oncc116=0.500 lfo01_volume_oncc114=6 //Wobble lfo01_cutoff=0 lfo01_cutoff_oncc113=3600","title":"Vibrato"},{"location":"tutorials/subtractive_synths/#humanized-vibrato","text":"Humanization is obviously not a standard feature of synthesizers. Technically, though, it's not difficult to implement. The example instrument adds CC 117 for controlling the amount of randomization of the vibrato LFOs. This is similar to the humanization described in the vibrato tutorial , but using CC 135 to generate a true random number for each voice, which means any unison voices' vibrato will drift out of sync with those belonging to other voices. This is musically useful for creating more complex pads, for example. Similar principles could also be used to emulate analog oscillators' much more subtle pitch drift. <control> label_cc111=Vibrato to pitch label_cc112=Vibrato speed label_cc113=Vibrato to cutoff label_cc114=Vibrato to volume label_cc115=Vibrato delay label_cc116=Vibrato fade label_cc117=Vibrato humanize set_cc112=40 <global> //Vibrato and humanization setup lfo01_pitch_oncc111=22 //Vibrato LFO lfo01_freq=0.1 lfo01_freq_oncc112=9.9 lfo01_delay_oncc115=0.500 lfo01_fade_oncc116=0.500 lfo01_volume_oncc114=6 //Wobble lfo01_cutoff=0 lfo01_cutoff_oncc113=3600 lfo02_wave=1 //Second LFO to make things wobblier lfo02_phase=0 lfo02_phase_oncc135=1 //Phase randomized lfo02_freq=0.01 //Basically no movement at very slow speeds, just randomization lfo02_freq_oncc117=1 //Max rate is not very high, so it doesn't sound too obvious lfo02_pitch_oncc117=6 //Slight pitch wobbliness lfo02_freq_lfo01_oncc117=0.5 //Affect the rate of the other LFO for unsteady vibrato lfo02_freq_lfo01_oncc112=2.5 //Faster when the first LFO is going faster lfo03_wave=1 //And a third LFO for secondhand complex wobbliness lfo03_phase=0.4 lfo03_phase_oncc135=0.179 //Different phase response to random than the second LFO lfo03_freq=0.5 lfo03_freq_oncc117=-0.4 lfo03_freq_lfo2_oncc117=1 lfo03_pitch_oncc117=-4 lfo04_wave=1 //Fourth LFO for slowly changing the oscillator mix lfo04_phase_oncc135=1 lfo04_freq=0.01 lfo04_freq_oncc135=0.25 //Randomly from almost not moving at all to still pretty slow lfo04_volume_oncc117=1.5 //Slight volume changes","title":"Humanized vibrato"},{"location":"tutorials/subtractive_synths/#unison-and-detune","text":"Unison is a simple matter of triggering multiple regions with one MIDI note. If using a simple sound source such as a saw oscillators, all regions will sound identical so the only result will be additional volume. Making the unison more interesting requires some of: using different samples for each voice, detuning the voices, and shifting the phase of the voices. The example instrument uses many sets of samples from an analog keyboard, with every key producing a slightly different timbre, and transposed versions of those sounds used for unison. The detune and width amounts vary for each of the three oscillators, but here is a simplified version assuming there is only one oscillator. Note that although there is a width opcodes for use with stereo samples, in this case the left channel and right are separate mono samples, so pan is used to spread them in stereo - not width. As the samples here are quite long, offset_random is applied globally to effecitvely randomize each voice's phase. With true single-cycle waveforms, the max offset would have to be set to match each voice's max sample length. <control> label_cc25=Unison label_cc26=Width label_cc27=Detune set_cc26=63 set_cc27=63 <global> //Randomizing the start points of the samples to randomize phase offset_random=1000 //Center voice <master> #include \"sample_map_basic.sfz\" //Left voice <region> amplitude_cc25=100 amplitude_cc25=100 locc25=1 pan_cc26=-100 tune_cc27=-33 #include \"sample_map_transposed_1.sfz\" //Right voice <region> amplitude_cc25=100 locc25=1 pan_cc26=100 tune_cc27=33 amplitude_cc25=100 #include \"sample_map_transposed_2.sfz\"","title":"Unison and detune"},{"location":"tutorials/subtractive_synths/#more-complex-detune","text":"Another highly unsual feature of Caveman Cosmonaut, though, is that the detune doesn't have to be fixed. There are additional detune controls which detune the additional voices more at the start of the note, and then drift towards a common pitch over time, using pitch envelopes . This is definitely not part of any typical hardware analog synthesizer's feature set, but it does have something in common with the way real world choirs or instrumental ensembles find a commmon pitch. <control> label_cc25=Unison label_cc26=Width label_cc27=Detune label_cc28=Extra detune amt label_cc29=Extra detune time set_cc26=63 set_cc27=63 set_cc29=16 <global> //Randomizing the start points of the samples to randomize phase offset_random=1000 //Pitch envelope defaults for the fancy detune pitcheg_sustain=0 pitcheg_decay_shape=-2 //Center voice <master> #include \"sample_map_basic.sfz\" //Left voice <region> amplitude_cc25=100 locc25=1 pan_cc26=-100 tune_cc27=-33 pitcheg_depth_oncc28=-150 pitcheg_decay_oncc29=5 #include \"sample_map_transposed_1.sfz\" //Right voice <region> amplitude_cc25=100 locc25=1 pan_cc26=100 tune_cc27=33 pitcheg_depth_oncc28=150 pitcheg_decay_oncc29=5 #include \"sample_map_transposed_2.sfz\"","title":"More complex detune"},{"location":"tutorials/subtractive_synths/#waveform-selection-and-oscillator-mixing","text":"This is just locc/hicc for selection, and amplitude for volume controls.","title":"Waveform selection and oscillator mixing"},{"location":"tutorials/subtractive_synths/#mono-mode-and-portamento","text":"This is implemented similarly to any non-synth - see our legato tutorial .","title":"Mono mode and portamento"},{"location":"tutorials/subtractive_synths/#putting-it-all-together","text":"This is the main file for the example instrument. The unison and detune settings, along with oscillator selection and mixing, are inside SFZ files added via the #include directives. <control> label_cc15=Bass Osc Vol label_cc16=Bass Osc Sel label_cc17=Osc 1 Vol label_cc18=Osc 1 Sel label_cc19=Osc 2 Vol label_cc20=Osc 2 Sel label_cc21=Osc 3 Vol label_cc22=Osc 3 Sel label_cc25=Unison label_cc26=Width label_cc27=Detune label_cc28=Extra detune amt label_cc29=Extra detune time label_cc100=Attack time label_cc101=Hold time label_cc102=Decay time label_cc103=Sustain level label_cc104=Release time label_cc106=Env soften label_cc108=Legato switch label_cc109=Porta time label_cc111=Vibrato to pitch label_cc112=Vibrato speed label_cc113=Vibrato to cutoff label_cc114=Vibrato to volume label_cc115=Vibrato delay label_cc116=Vibrato fade label_cc117=Unsteadiness label_cc120=Filter cutoff label_cc121=Resonance label_cc124=Veltrack label_cc125=Pluck label_cc126=Filter attack label_cc127=Filter decay set_cc15=100 set_cc16=15 set_cc17=127 set_cc18=63 set_cc19=100 set_cc20=15 set_cc21=100 set_cc22=44 set_cc26=63 set_cc27=63 set_cc29=16 set_cc102=63 set_cc103=51 set_cc104=31 set_cc109=31 set_cc112=40 set_cc120=127 set_cc127=40 <global> bend_down=-2400 bend_up=2400 off_mode=normal loop_mode=continuous offset=10000 offset_random=1000 //AHDSR ampeg_attack=0.002 ampeg_sustain=0 ampeg_release=0.002 ampeg_attack_oncc100=0.5 ampeg_hold_oncc101=1 ampeg_decay_oncc102=5 ampeg_sustain_oncc103=100 ampeg_release_oncc104=2 //Decay and release are affected by the soften parameter also //This is set separately for each oscillator //Filter //Lowpass filter //By default, cutoff modulation is measured in cents //To make the modulation not keytrack, we make a kludge //Using var cutoff=250 var02_cutoff=9000 var02_mod=mult var02_oncc120=1 var02_curvecc120=0 var02_oncc133=1 var02_curvecc133=11 fil_keytrack=70 resonance=0 resonance_cc121=18 var01_cutoff=6000 //Velocity track var01_mod=mult var01_oncc131=1 var01_oncc124=1 cutoff_cc124=-3000 //Pluck envelope fileg_depth=0 fileg_depthcc125=8400 fileg_sustain=0 fileg_attack=0 fileg_attackcc126=0.5 fileg_decay=0.001 fileg_decaycc127=2 //Vibrato and humanization setup lfo01_pitch_oncc111=22 //Vibrato LFO lfo01_freq=0.1 lfo01_freq_oncc112=9.9 lfo01_delay_oncc115=0.500 lfo01_fade_oncc116=0.500 lfo01_volume_oncc114=6 //Wobble lfo01_cutoff=0 lfo01_cutoff_oncc113=3600 lfo02_wave=1 //Second LFO to make things wobblier lfo02_phase=0 lfo02_phase_oncc135=1 //Phase randomized lfo02_freq=0.01 //Basically no movement at very slow speeds, just randomization lfo02_freq_oncc117=1 //Max rate is not very high, so it doesn't sound too obvious lfo02_pitch_oncc117=6 //Slight pitch wobbliness lfo02_freq_lfo01_oncc117=0.5 //Affect the rate of the other LFO for unsteady vibrato lfo02_freq_lfo01_oncc112=2.5 //Faster when the first LFO is going faster lfo03_wave=1 //And a third LFO for secondhand complex wobbliness lfo03_phase=0.4 lfo03_phase_oncc135=0.179 //Different phase response to random than the second LFO lfo03_freq=0.5 lfo03_freq_oncc117=-0.4 lfo03_freq_lfo2_oncc117=1 lfo03_pitch_oncc117=-4 lfo04_wave=1 //Fourth LFO for slowly changing the oscillator mix lfo04_phase_oncc135=1 lfo04_freq=0.01 lfo04_freq_oncc135=0.25 //Randomly from almost not moving at all to still pretty slow lfo04_volume_oncc117=1.5 //Slight volume changes //Some defaults for the fancy detune stuff pitcheg_sustain=0 pitcheg_decay_shape=-2 //And here come the oscillator mappings //First polyphonic mode #include \"mappings/poly_map.sfz\" #include \"mappings/mono_first_map.sfz\" #include \"mappings/mono_legato_map.sfz\" <curve> curve_index=11 v000=1 v024=1 v084=0.63 v127=0.25","title":"Putting it all together"},{"location":"tutorials/sustained_note_basics/","text":"We've covered the basic opcodes required to map simple drum instruments on another page , and here we are going to apply that knowledge to pitched instruments, plus add more opcodes. Let's say we want to sample a folk flute whose lowest note is a D. If the lowest five notes are D, E, F#, G and A, and there is one sample available for each note, they could be mapped like this: <region>key=50 sample=d4.wav <region>key=52 sample=e4.wav <region>key=54 sample=f#4.wav <region>key=55 sample=g4.wav <region>key=57 sample=a4.wav This would work well enough to make a sound when a MIDI note corresponding to one of the sampled pitches is played. However, playing notes inbetween the D and E, or E and F#, would mean no sound. We can \"stretch\" one of the neighboring notes to cover that D# and that F using the lokey / hikey and pitch_keycenter opcodes instead of key. If a sample does not need to cover multiple notes, it can still use key. Whether to use the D or E sample to cover the D# in our example is a judgment call - which sounds better? <region>lokey=50 hikey=51 pitch_keycenter=50 sample=d4.wav <region>lokey=52 hikey=53 pitch_keycenter=52 sample=e4.wav <region>key=54 sample=f#4.wav <region>lokey=55 hikey=55 pitch_keycenter=56 sample=g4.wav <region>key=57 sample=a4.wav The samples will play as long as a note is held, but when the note is released, they will end suddenly, which is probably not realistic for a flute sound, or indeed most other instruments. We'll need to apply a volume envelope with a release time set, which can be applied to all regions. The ampeg_release opcode accomplishes this. <global>ampeg_release=0.3 <region>lokey=50 hikey=51 pitch_keycenter=50 sample=d4.wav <region>lokey=52 hikey=53 pitch_keycenter=52 sample=e4.wav <region>key=54 sample=f#4.wav <region>key=55 sample=g4.wav If we have samples at various dynamics, such as quiet and loud, we could use note velocity to choose which sample is played - however, while this makes perfect sense for drum hits or piano notes, with instruments such as flute or violin, it's possible for the player to vary the dynamic level while a note is being sustained. This can be simulated with the xfin_loccN / xfin_hiccN and xfout_loccN / xfout_hiccN opcodes. Using only the D4 and E4 samples as an example, and controlling the dynamics with CC1 (mod wheel). The amp_veltrack opcode is set to 0, so that velocity does not affect volume. <global>ampeg_release=0.3 amp_veltrack=0 <group>lokey=50 hikey=51 pitch_keycenter=50 <region>sample=d4_p.wav xfin_locc1=0 xfin_hicc1=42 xfout_locc1=43 xfout_hicc1=85 <region>sample=d4_mf.wav xfin_locc1=43 xfin_hicc1=85 xfout_locc1=86 xfout_hicc1=127 <region>sample=d4_f.wav xfin_locc1=86 xfin_hicc1=127 <group>lokey=52 hikey=53 pitch_keycenter=52 <region>sample=e4_p.wav xfin_locc1=0 xfin_hicc1=42 xfout_locc1=43 xfout_hicc1=85 <region>sample=e4_mf.wav xfin_locc1=43 xfin_hicc1=85 xfout_locc1=86 xfout_hicc1=127 <region>sample=e4_f.wav xfin_locc1=86 xfin_hicc1=127 Now, CC1 would first fade in the quiet sample when it was between 0 and 42. From 43 to 85, the quiet sample is faded out and the medium sample faded in. From 86 to the max value of 127, the medium sample is faded out while the loud sample fades in. If we have multiple techniques or articulation sampled, for example regular sustains and fluttertongue sustains, we need a way to switch between them. Each could be its own independent and complete SFZ file, and we could just load the desired file into the player, but for convenience, especially in live performance, it's good to load both at once and have a way of switching between them. One way is loccN / hiccN where which sample is triggered for a particular note depends on the value of a MIDI CC - let's use MIDI CC 11. Notice that the fluttertongue samples in this example have fewer dynamic layers than the main sustain samples - it's common for the \"core\" articulations of an instrument to be sampled in more detail, and the SFZ format is flexible enough to allow this, or even allow different amounts of dynamic layers or round robins for different notes within the same articulation. <global>ampeg_release=0.3 amp_veltrack=0 <group>lokey=50 hikey=51 pitch_keycenter=50 hicc11=63 <region>sample=d4_p.wav xfin_locc1=0 xfin_hicc1=42 xfout_locc1=43 xfout_hicc1=85 <region>sample=d4_mf.wav xfin_locc1=43 xfin_hicc1=85 xfout_locc1=86 xfout_hicc1=127 <region>sample=d4_f.wav xfin_locc1=86 xfin_hicc1=127 <group>lokey=52 hikey=53 pitch_keycenter=52 hicc11=63 <region>sample=e4_p.wav xfin_locc1=0 xfin_hicc1=42 xfout_locc1=43 xfout_hicc1=85 <region>sample=e4_mf.wav xfin_locc1=43 xfin_hicc1=85 xfout_locc1=86 xfout_hicc1=127 <region>sample=e4_f.wav xfin_locc1=86 xfin_hicc1=127 <group>lokey=50 hikey=51 pitch_keycenter=50 locc11=64 <region>sample=d4_ft_p.wav xfin_locc1=0 xfin_hicc1=63 xfout_locc1=64 xfout_hicc1=127 <region>sample=d4_ft_f.wav xfin_locc1=64 xfin_hicc1=127 <group>lokey=52 hikey=53 pitch_keycenter=52 locc11=64 <region>sample=e4_ft_p.wav xfin_locc1=0 xfin_hicc1=63 xfout_locc1=64 xfout_hicc1=127 <region>sample=e4_ft_f.wav xfin_locc1=64 xfin_hicc1=127 Another, probably more common, way is to use keyswitches. If we define the keyswitch range as the C and C# below our lowest D using sw_lokey / sw_hikey , we can then use sw_last to select articulations. <global>ampeg_release=0.3 amp_veltrack=0 sw_lokey=48 sw_hikey=49 <group>lokey=50 hikey=51 pitch_keycenter=50 sw_last=48 <region>sample=d4_p.wav xfin_locc1=0 xfin_hicc1=42 xfout_locc1=43 xfout_hicc1=85 <region>sample=d4_mf.wav xfin_locc1=43 xfin_hicc1=85 xfout_locc1=86 xfout_hicc1=127 <region>sample=d4_f.wav xfin_locc1=86 xfin_hicc1=127 <group>lokey=52 hikey=53 pitch_keycenter=52 sw_last=48 <region>sample=e4_p.wav xfin_locc1=0 xfin_hicc1=42 xfout_locc1=43 xfout_hicc1=85 <region>sample=e4_mf.wav xfin_locc1=43 xfin_hicc1=85 xfout_locc1=86 xfout_hicc1=127 <region>sample=e4_f.wav xfin_locc1=86 xfin_hicc1=127 <group>lokey=50 hikey=51 pitch_keycenter=50 sw_last=49 <region>sample=d4_ft_p.wav xfin_locc1=0 xfin_hicc1=63 xfout_locc1=64 xfout_hicc1=127 <region>sample=d4_ft_f.wav xfin_locc1=64 xfin_hicc1=127 <group>lokey=52 hikey=53 pitch_keycenter=52 sw_last=49 <region>sample=e4_ft_p.wav xfin_locc1=0 xfin_hicc1=63 xfout_locc1=64 xfout_hicc1=127 <region>sample=e4_ft_f.wav xfin_locc1=64 xfin_hicc1=127 There are other possibilities - for example, since velocity is not needed to control dynamics, we could use that to select articulations using lovel / hivel , for example. However, it' is quite common, especially with string instruments, to use a MIDI CC to control the dynamics of sustained articulations, and velocity to control the dynamics of short articulations such as staccato. In those cases, the short articulations could use amp_veltrack set to 100 instead of 0, and generally be mapped in the same way as the drums we've discussed before . The flute is a monophonic instrument in reality - you can't play chords on it, while you can using our SFZ here. For more realism, playing a note on this flute should mute any previously playing notes. To make an instrument which can only play one note at a time, the group and off_by opcodes can be used. Although these can be used in more complex scenarios, for a monophonic instrument with no multiple microphone positions sampled, it's enough to put all samples in the same group, and have that group muted whenever a new note from that group is played. <global>ampeg_release=0.3 amp_veltrack=0 sw_lokey=48 sw_hikey=49 group=1 off_by=1 <group>lokey=50 hikey=51 pitch_keycenter=50 sw_last=48 <region>sample=d4_p.wav xfin_locc1=0 xfin_hicc1=42 xfout_locc1=43 xfout_hicc1=85 <region>sample=d4_mf.wav xfin_locc1=43 xfin_hicc1=85 xfout_locc1=86 xfout_hicc1=127 <region>sample=d4_f.wav xfin_locc1=86 xfin_hicc1=127 <group>lokey=52 hikey=53 pitch_keycenter=52 sw_last=48 <region>sample=e4_p.wav xfin_locc1=0 xfin_hicc1=42 xfout_locc1=43 xfout_hicc1=85 <region>sample=e4_mf.wav xfin_locc1=43 xfin_hicc1=85 xfout_locc1=86 xfout_hicc1=127 <region>sample=e4_f.wav xfin_locc1=86 xfin_hicc1=127 <group>lokey=50 hikey=51 pitch_keycenter=50 sw_last=49 <region>sample=d4_ft_p.wav xfin_locc1=0 xfin_hicc1=63 xfout_locc1=64 xfout_hicc1=127 <region>sample=d4_ft_f.wav xfin_locc1=64 xfin_hicc1=127 <group>lokey=52 hikey=53 pitch_keycenter=52 sw_last=49 <region>sample=e4_ft_p.wav xfin_locc1=0 xfin_hicc1=63 xfout_locc1=64 xfout_hicc1=127 <region>sample=e4_ft_f.wav xfin_locc1=64 xfin_hicc1=127 However, this cuts off the note suddenly, creating a gap before the next note can reach full volume. That problem can be fixed by setting off_mode to normal, which will make the notes being muted fade out gradually over the duration previously specified with the ampeg_release opcode. <global>ampeg_release=0.3 amp_veltrack=0 sw_lokey=48 sw_hikey=49 group=1 off_by=1 off_mode=normal <group>lokey=50 hikey=51 pitch_keycenter=50 sw_last=48 <region>sample=d4_p.wav xfin_locc1=0 xfin_hicc1=42 xfout_locc1=43 xfout_hicc1=85 <region>sample=d4_mf.wav xfin_locc1=43 xfin_hicc1=85 xfout_locc1=86 xfout_hicc1=127 <region>sample=d4_f.wav xfin_locc1=86 xfin_hicc1=127 <group>lokey=52 hikey=53 pitch_keycenter=52 sw_last=48 <region>sample=e4_p.wav xfin_locc1=0 xfin_hicc1=42 xfout_locc1=43 xfout_hicc1=85 <region>sample=e4_mf.wav xfin_locc1=43 xfin_hicc1=85 xfout_locc1=86 xfout_hicc1=127 <region>sample=e4_f.wav xfin_locc1=86 xfin_hicc1=127 <group>lokey=50 hikey=51 pitch_keycenter=50 sw_last=49 <region>sample=d4_ft_p.wav xfin_locc1=0 xfin_hicc1=63 xfout_locc1=64 xfout_hicc1=127 <region>sample=d4_ft_f.wav xfin_locc1=64 xfin_hicc1=127 <group>lokey=52 hikey=53 pitch_keycenter=52 sw_last=49 <region>sample=e4_ft_p.wav xfin_locc1=0 xfin_hicc1=63 xfout_locc1=64 xfout_hicc1=127 <region>sample=e4_ft_f.wav xfin_locc1=64 xfin_hicc1=127 This is enough to make a basic monophonic wind instrument, vocal, or other monophonic instrument. There are more possibilities - better legato, vibrato emulation, multiple microphone positions etc. - which we'll describe later in another part of this guide. Together with the information covered in drum basics earlier, this should also be enough to make a basic sampled piano or guitar.","title":"Sustained note basics"},{"location":"tutorials/unison/","text":"This tutorial describes various methods of using one set of samples to emulate the sound of larger numbers of instruments - making a small ensemble sound larger, using one set of samples for both first and second violins, automatically multitracking guitars, synthesizer oscillator unison etc. Transposition Let's say we have only one sampled violin section, and need to use both first and second violins. Using just one octave of range for simplicity, this is our first violins example: <global> <region>sample=c4.wav key=48 <region>sample=db4.wav key=49 <region>sample=d4.wav key=50 <region>sample=eb4.wav key=51 <region>sample=e4.wav key=52 <region>sample=f4.wav key=53 <region>sample=gb4.wav key=54 <region>sample=g4.wav key=55 <region>sample=ab4.wav key=56 <region>sample=a4.wav key=57 <region>sample=bb4.wav key=58 <region>sample=b4.wav key=59 <region>sample=c5.wav key=60 Using this for both first and second violins will result in two identical-sounding sections with the same timbre, but it's easily possible to use the same samples transposed, and get a different timbre. Instead of using the C4 sample to play C4, use the Db4 sample transposed down a half step to play C4. This can be done by using lokey, hikey and pitch_keycenter opcodes instead of just key. <region>sample=c4.wav lokey=47 hikey=47 pitch_keycenter=48 <region>sample=db4.wav lokey=48 hikey=48 pitch_keycenter=49 <region>sample=d4.wav lokey=49 hikey=49 pitch_keycenter=50 <region>sample=eb4.wav lokey=50 hikey=50 pitch_keycenter=51 <region>sample=e4.wav lokey=51 hikey=51 pitch_keycenter=52 <region>sample=f4.wav lokey=52 hikey=52 pitch_keycenter=53 <region>sample=gb4.wav lokey=53 hikey=53 pitch_keycenter=54 <region>sample=g4.wav lokey=54 hikey=54 pitch_keycenter=55 <region>sample=ab4.wav lokey=55 hikey=55 pitch_keycenter=56 <region>sample=a4.wav lokey=56 hikey=56 pitch_keycenter=57 <region>sample=bb4.wav lokey=57 hikey=57 pitch_keycenter=58 <region>sample=b4.wav lokey=58 hikey=58 pitch_keycenter=59 <region>sample=c5.wav lokey=59 hikey=59 pitch_keycenter=60 Howerver, in most cases it's easier to use the key and transpose opcodes instead, and set the transpose amount for all the transposed regions at once. <global> transpose=-1 <region>sample=c4.wav key=47 <region>sample=db4.wav key=48 <region>sample=d4.wav key=49 <region>sample=eb4.wav key=50 <region>sample=e4.wav key=51 <region>sample=f4.wav key=52 <region>sample=gb4.wav key=53 <region>sample=g4.wav key=54 <region>sample=ab4.wav key=55 <region>sample=a4.wav key=56 <region>sample=bb4.wav key=57 <region>sample=b4.wav key=58 <region>sample=c5.wav key=59 This still requires changing the key opcode for every region, however. Doing this editing manually on large sample sets would be time-consuming, but the old tool sfzed allows easily adding, subtracting or multiplying current parameter values to regions, which becomes very useful when doing this with thousands of samples. This shifts the entire range of the instrument down by a half-step, though. In order to preserve the correct range, we can remove the transposed notes which got moved below the lowest pitch the instrument is capable of. That's easy. The top range is more tricky - if we extend the highest note to cover its original pitch as well, but then the same sample would be used for the same pitch by both sections. So, we can instead use the next-to-highest note, transposed up. This might not sound very consistent with the rest, but under these limitations, it can be a reasonable compromise. <global> transpose=-1 <region>sample=db4.wav key=48 <region>sample=d4.wav key=49 <region>sample=eb4.wav key=50 <region>sample=e4.wav key=51 <region>sample=f4.wav key=52 <region>sample=gb4.wav key=53 <region>sample=g4.wav key=54 <region>sample=ab4.wav key=55 <region>sample=a4.wav key=56 <region>sample=bb4.wav key=57 <region>sample=b4.wav key=58 <region>sample=c5.wav key=59 <region>sample=b4.wav key=60 transpose=1 Transposition Values In general, transposing downwards will result in a warmer sound, and transposing upwards will make the sound brighter and thinner. Transposing by more than a half step can be a good idea. In general, transposing by a minor third is a common way to create a big change in timbre. Transposing by much more than a minor third doesn't seem common outside of sound design not intended to be a realistic instrument emulation. Transposing down by a minor third while preserving the range in our example, and filling in the lost top of the range by transposing upwards might look like this: <global> transpose=-3 <region>sample=eb4.wav key=48 <region>sample=e4.wav key=49 <region>sample=f4.wav key=50 <region>sample=gb4.wav key=51 <region>sample=g4.wav key=52 <region>sample=ab4.wav key=53 <region>sample=a4.wav key=54 <region>sample=bb4.wav key=55 <region>sample=b4.wav key=56 <region>sample=c5.wav key=57 <region>sample=a4.wav key=58 transpose=1 <region>sample=bb4.wav key=59 transpose=1 <region>sample=b4.wav key=60 transpose=1 Note that all of the above assumes the instrument is sampled chromatically; for instruments which are sampled at wholetone intervals or diatonically, transposition by at least a whole step will be necessary to avoid using the same samples for a note. Instruments which are sampled every minor third will need an interval of at least a minor third etc. Unison By Transposition If we put both the original and transposed samples in the same SFZ file, each MIDI note will trigger two regions, and we now will have the sound of an ensemble which is twice as large as what was actually sampled. <group> <region>sample=c4.wav key=48 <region>sample=db4.wav key=49 <region>sample=d4.wav key=50 <region>sample=eb4.wav key=51 <region>sample=e4.wav key=52 <region>sample=f4.wav key=53 <region>sample=gb4.wav key=54 <region>sample=g4.wav key=55 <region>sample=ab4.wav key=56 <region>sample=a4.wav key=57 <region>sample=bb4.wav key=58 <region>sample=b4.wav key=59 <region>sample=c5.wav key=60 <group> transpose=-1 <region>sample=db4.wav key=48 <region>sample=d4.wav key=49 <region>sample=eb4.wav key=50 <region>sample=e4.wav key=51 <region>sample=f4.wav key=52 <region>sample=gb4.wav key=53 <region>sample=g4.wav key=54 <region>sample=ab4.wav key=55 <region>sample=a4.wav key=56 <region>sample=bb4.wav key=57 <region>sample=b4.wav key=58 <region>sample=c5.wav key=59 <region>sample=b4.wav key=60 transpose=1 Unison By Round Robin For cases where the goal is to emulate overdubbed copies of the same instrument with the same timbre, rather than different instruments with different timbres, it's still necessary to avoid triggering the same samples. For example, is how guitar multitracking is typically emulated. This approach also works for instruments which are not pitched but it makes sense to layer them, for example handclaps. In such cases, unison can be implemented by using different round robin samples for each simultaneously playing sample. Using one note with four round robins as an example: <group>seq_length=4 key=48 <region>sample=c4_rr1.wav seq_position=1 <region>sample=c4_rr2.wav seq_position=2 <region>sample=c4_rr3.wav seq_position=3 <region>sample=c4_rr4.wav seq_position=4 We can create two by offsetting the round robins like this: <group>seq_length=4 key=48 <region>sample=c4_rr1.wav seq_position=1 <region>sample=c4_rr2.wav seq_position=2 <region>sample=c4_rr3.wav seq_position=3 <region>sample=c4_rr4.wav seq_position=4 <group>seq_length=4 key=48 <region>sample=c4_rr1.wav seq_position=4 <region>sample=c4_rr2.wav seq_position=1 <region>sample=c4_rr3.wav seq_position=2 <region>sample=c4_rr4.wav seq_position=3 The group headers aren't necessary and everything could be under one group, but for organizational purposes, they can make things easier. Or three, or a maximum of four: <group>seq_length=4 key=48 <region>sample=c4_rr1.wav seq_position=1 <region>sample=c4_rr2.wav seq_position=2 <region>sample=c4_rr3.wav seq_position=3 <region>sample=c4_rr4.wav seq_position=4 <group>seq_length=4 key=48 <region>sample=c4_rr1.wav seq_position=4 <region>sample=c4_rr2.wav seq_position=1 <region>sample=c4_rr3.wav seq_position=2 <region>sample=c4_rr4.wav seq_position=3 <group>seq_length=4 key=48 <region>sample=c4_rr1.wav seq_position=3 <region>sample=c4_rr2.wav seq_position=4 <region>sample=c4_rr3.wav seq_position=1 <region>sample=c4_rr4.wav seq_position=2 <group>seq_length=4 key=48 <region>sample=c4_rr1.wav seq_position=2 <region>sample=c4_rr2.wav seq_position=3 <region>sample=c4_rr3.wav seq_position=4 <region>sample=c4_rr4.wav seq_position=1 Note that this will not work well with random round robins, as it's possible that the same sample will be randomly selected for multiple regions. Width And Detune Multitracked guitars will often be spread in stereo, as will unison voices in synthesizers etc. Spreading the above quad-tracked guitar in stereo is simple: <group>seq_length=4 key=48 pan=-100 <region>sample=c4_rr1.wav seq_position=1 <region>sample=c4_rr2.wav seq_position=2 <region>sample=c4_rr3.wav seq_position=3 <region>sample=c4_rr4.wav seq_position=4 <group>seq_length=4 key=48 pan=100 <region>sample=c4_rr1.wav seq_position=4 <region>sample=c4_rr2.wav seq_position=1 <region>sample=c4_rr3.wav seq_position=2 <region>sample=c4_rr4.wav seq_position=3 <group>seq_length=4 key=48 pan=-50 <region>sample=c4_rr1.wav seq_position=3 <region>sample=c4_rr2.wav seq_position=4 <region>sample=c4_rr3.wav seq_position=1 <region>sample=c4_rr4.wav seq_position=2 <group>seq_length=4 key=48 pan=50 <region>sample=c4_rr1.wav seq_position=2 <region>sample=c4_rr2.wav seq_position=3 <region>sample=c4_rr3.wav seq_position=4 <region>sample=c4_rr4.wav seq_position=1 It's also possible to apply slight detuning to each voice. That's probably not common with guitars, and unnecessary with section recordings where natural tuning differences will already be captured in the recordings, but it is very common in synthesizers, and can also be helpful when trying to turn solo instrument samples into a small section. Detune can even be used by itself to create multiple voices, and this is an especially viable approach for synthesizers. The amount of detune, as well as width, can be modulated. Here is an example of a saw oscillator with seven voices. <region>sample=*saw <region>pitch_oncc100=20 pan_oncc101=100 sample=*saw <region>pitch_oncc100=-20 pan_oncc101=-100 sample=*saw <region>pitch_oncc100=30 pan_oncc101=67 sample=*saw <region>pitch_oncc100=-30 pan_oncc101=-67 sample=*saw <region>pitch_oncc100=40 pan_oncc101=33 sample=*saw <region>pitch_oncc100=-40 pan_oncc101=-33 sample=*saw Legato When self-muting is implemented, each set of unison samples will need to have its own polyphony groups, same as would be needed with multiple microphone positions. If there are true legato samples, that adds considerable complexity to the transposition trick. The below steps are not a universal set of instructions, but have worked successfully for at least two instruments. Create an extended-range map extending the range by the largest transposition amount in the direction opposite of the transposition. For example, if there are four transposed voices and are to be transposed down by a half-step, a full step, a minor third and a major third, add a major third of range to the top of the extended map. See the range extension tutorial for details on the basics. In addition to extending the lokey/hikey range, remember that the sw_previous range will also need to be extended. For the extremes of the range, there will be no samples with the correct interval available - use the nearest available interval. For the highest note of the extended range, there will be no upward interval sample available, but in practice using a sample of a downward half-step interval seems to work tolerably well. Make copies of this extended map to create the to-be-transposed maps. In each map, add the amount of shift for the particular map (for example -1) to lokey, hikey and sw_previous. Delete any regions with lokey or hikey above or below the final desired range, which might be both at the top and bottom of a map. Delete any regions with sw_previous above or below the final desired range. This isn't strictly necessary as those regions \"should\" never be played and will not affect the visible keyboard map, but will reduce parsing time and prevent weirdness when a note slightly outside the range is held by mistake and a note inside the range is pressed. Delete any regions where the sw_previous ened up being the same as the lokey/hikey, as these will likewise be never triggered. In theory these should never be created, so this is just to catch mistakes. Humanization When trying to emulate the sound of a larger section of instruments, especially when trying to turn a solo instrument into an emulated section, it can be useful to create small differences between each voice, especially when vibrato and legato are also emulated. This is probably not that important with sampled ensembles, such as emulating second violins, but with solo instruments it becomes crucial. Without independent per-voice humanization, emulated vibrato and legato can sound more like a solo instrument run through a chorus or other doubling effect, rather than separate performances. Aspects of the sound which can be humanized or randomized include timing, smoothing, phase, pitch, vibrato speed and vibrato depth. Here is a rather lengthy example, adapted from a real instrument, where each voice has separate pan settings for stereo spread and separate polyphony groups - these are basic features of unison, and not related to humanization, of course. The humanizing differences between the voices are differences in bend smoothing, in maximum vibrato depth, in the initial phase of the vibrato humanization LFOs, and in the fade times of the legato regions. The shallower vibrato and slower legato of the transposed regions emulate less confident, more hesitant players. <global> //Basic global stuff shared by all voices ampeg_release=0.25 ampeg_attack_oncc106=1 ampeg_release_oncc107=1.25 off_mode=normal bend_down=-1200 bend_up=1200 //Pitch bend smoothing is set separately for each voice amplitude_oncc100=100 amplitude_smoothcc1=100 locc100=1 amp_veltrack=0 loop_mode=loop_continuous //Vibrato //Pitch LFO depth is set separately for each voice lfo01_freq=2 //Any slower than this sounds really lousy lfo01_freq_oncc112=6 //8 Hz is about as fast as vibrato on cello can go lfo01_delay_oncc115=0.500 lfo01_fade_oncc116=0.500 //This LFO also does tremolo lfo01_volume_oncc21=1 //Not much - just a subtle effect on volume eq1_freq=2200 //EQ band for vibrato eq1_bw=2 lfo01_eq1gain_oncc21=3 //Again, pretty subtle lfo02_wave=1 //Second LFO to make things wobblier //Initial phase is set separately for each voice lfo02_phase_oncc131=0.7 //Phase affected by velocity, to pseudo-randomize while keeping both mics' LFOs in sync lfo02_freq=0.01 //Basically no movement at very slow speeds, just randomization lfo02_freq_oncc117=1 //Max rate is not very high, so it doesn't sound too obvious lfo02_pitch_oncc117=6 //Slight pitch wobbliness lfo02_freq_lfo01_oncc117=0.2 lfo02_freq_lfo01_oncc112=0.8 //Affect the rate of the other LFO for unsteady vibrato lfo03_wave=1 //And a third LFO for secondhand complex wobbliness //Initial phase is set separately for each voice lfo03_phase_oncc131=0.479 //Different phase response to velocity than the second LFO lfo03_freq=0.5 lfo03_freq_oncc117=-0.4 lfo03_freq_lfo2_oncc117=1 lfo03_pitch_oncc117=-4 <master> //Central voice bend_smooth=80 lfo01_pitch_oncc21=29 lfo02_phase=0 lfo03_phase=0.4 group=1 off_by=1 //Sustains legato <group> trigger=first #include \"mappings/ord_sus_map.sfz\" <group> trigger=legato offset=5000 offset_random=500 ampeg_attack=0.5 ampeg_vel2attack=-0.35 #include \"mappings/ord_sus_map.sfz\" <master> //Left voice using sample maps transposed by a half-step //Pan control not used in the central voice pan_oncc101=-100 //Values different than the central voice, for humanization purposes bend_smooth=91 lfo01_pitch_oncc21=17 lfo02_phase=0.05 lfo03_phase=0.3 group=2 off_by=2 //Sustains legato <group> trigger=first #include \"mappings/t1/ord_sus_map.sfz\" <group> trigger=legato offset=5000 offset_random=500 //Values different than the central voice, for humanization purposes ampeg_attack=0.55 ampeg_vel2attack=-0.4 #include \"mappings/t1/ord_sus_map.sfz\" <master> //Right voice using sample maps transposed by a whole step //Pan control not used in the central voice pan_oncc101=100 //Values different than the central voice, for humanization purposes bend_smooth=87 lfo01_pitch_oncc21=19 lfo02_phase=0.02 lfo03_phase=0.28 group=3 off_by=3 //Sustains legato <master> trigger=first #include \"mappings/t2/ord_sus_map.sfz\" <master> trigger=legato offset=5000 offset_random=500 //Values different than the central voice, for humanization purposes ampeg_attack=0.58 ampeg_vel2attack=-0.43 #include \"mappings/t2/ord_sus_map.sfz\" Releases Implementing release samples with unison requires a little extra effort. It's easiest to simply implement releases for the center voice only, but even then it's necessary to be careful to avoid triggering too many release samples. At least in ARIA and Sforzando, a note-on event which triggers multiple regions (for example a multimic instrument, or one with simulated unison) will have multiple corresponding regions for the release region, causing the release region to be triggered multiple times. With seven mics and a separate release for each mic, this would mean a key release would trigger a total of 49 samples if not controlled with note_polyphony. However, setting note_polyphony=1 and giving each mic a different group number solves this. There's no need tu use off_by with the release groups. An example with releases only for the center voice: <global> //Basic global stuff shared by all voices ampeg_release=0.25 off_mode=normal //Center voice <master> //Sustains <group> #include \"mappings/ord_sus_map.sfz\" //Releases <group> trigger=release group=501 note_polyphony=1 #include \"mappings/ord_rel_map.sfz\" <master> //Left voice using sample maps transposed by a half-step //Pan control not used in the central voice pan_oncc101=-100 //Sustains <group> #include \"mappings/t1/ord_sus_map.sfz\" <master> //Right voice using sample maps transposed by a whole step //Pan control not used in the central voice pan_oncc101=100 //Sustains <master> #include \"mappings/t2/ord_sus_map.sfz\" With releases for all voices, just use a different group number for each voice's releases, like this example: <global> //Basic global stuff shared by all voices ampeg_release=0.25 off_mode=normal //Center voice <master> //Sustains <group> #include \"mappings/ord_sus_map.sfz\" //Releases <group> trigger=release group=501 note_polyphony=1 #include \"mappings/ord_rel_map.sfz\" <master> //Left voice using sample maps transposed by a half-step //Pan control not used in the central voice pan_oncc101=-100 //Sustains <group> #include \"mappings/t1/ord_sus_map.sfz\" //Releases <group> trigger=release group=502 note_polyphony=1 #include \"mappings/t1/ord_rel_map.sfz\" <master> //Right voice using sample maps transposed by a whole step //Pan control not used in the central voice pan_oncc101=100 //Sustains <master> #include \"mappings/t2/ord_sus_map.sfz\" //Releases <group> trigger=release group=503 note_polyphony=1 #include \"mappings/t2/ord_rel_map.sfz\" When using releases with round robins, it can be tricky to make the release sample round robin counter advance correctly. When there are 2 \"matching\" samples playing, ARIA appears to advance the counter for the releases by 2, and if there are 4 release round robins, only 2 of them will actually be used. One workaround for that is triggering an extra region of silence to make the round robin counter advance by 3, but this will only work if the number of regions is consistent and predictable. With instruments that have release samples with a number of microphone positions or organ stops, any of which could be on or off, the total number of matching regions is very difficult to assess, and it's far easier to use lorand/hirand to select the release samples instead. Round Robin Neighbor Borrowing Although not a method of achieving unison, round robin neighbor borrowing is another use of transposition, which likewise milks more out of a limited set of samples - specifically, emulating round robins where there are none, or increasing the amonut of available round robins. This works with either sequential round robin and random round robin approaches, or both at once. Let's use sequential round robins for this example, with a very small note range and three round robins sampled. <global> seq_length=3 <group> seq_position=1 <region>sample=c5_rr1.wav key=60 <region>sample=c#5_rr1.wav key=61 <region>sample=d5_rr1.wav key=62 <group> seq_position=2 <region>sample=c5_rr2.wav key=60 <region>sample=c#5_rr2.wav key=61 <region>sample=d5_rr2.wav key=62 <group> seq_position=3 <region>sample=c5_rr3.wav key=60 <region>sample=c#5_rr3.wav key=61 <region>sample=d5_rr3.wav key=62 We can double the amount of round robins by using a transposed sample from a neighboring note for every other note in the sequence. This means every other note repeat has a slightly different timbre, but it should sound more acceptable than using untransposed notes for the first three sequence positions and transposed notes for positions four through six. So, we increase the sequence length to six, and alternate between transposed and untransposed samples like this: <global> seq_length=6 <group> seq_position=1 <region>sample=c5_rr1.wav key=60 <region>sample=c#5_rr1.wav key=61 <region>sample=d5_rr1.wav key=62 <group> seq_position=2 <region>sample=c#5_rr1.wav key=60 transpose=-1 <region>sample=d5_rr1.wav key=61 transpose=-1 <region>sample=c#5_rr1.wav key=62 transpose=1 <group> seq_position=3 <region>sample=c5_rr2.wav key=60 <region>sample=c#5_rr2.wav key=61 <region>sample=d5_rr2.wav key=62 <group> seq_position=4 <region>sample=c#5_rr2.wav key=60 transpose=-1 <region>sample=d5_rr2.wav key=61 transpose=-1 <region>sample=c#5_rr2.wav key=62 transpose=1 <group> seq_position=5 <region>sample=c5_rr3.wav key=60 <region>sample=c#5_rr3.wav key=61 <region>sample=d5_rr3.wav key=62 <group> seq_position=6 <region>sample=c#5_rr3.wav key=60 transpose=-1 <region>sample=d5_rr3.wav key=61 transpose=-1 <region>sample=c#5_rr3.wav key=62 transpose=1 It's also possible to triple the amount of round robins by borrowing neighbors in both upwards and downwards direction for each note (except the lowest and highest note in the range, of course). In general, transposing by more than a half-step is not a good idea, as the timbral differences grow larger with larger transposition, but with some instruments it can be possible to get away with it. If there are many dynamic layers available, it's also possible to borrow from nearby dynamic layers, especially in the case of drums.","title":"Unison"},{"location":"tutorials/unison/#transposition","text":"Let's say we have only one sampled violin section, and need to use both first and second violins. Using just one octave of range for simplicity, this is our first violins example: <global> <region>sample=c4.wav key=48 <region>sample=db4.wav key=49 <region>sample=d4.wav key=50 <region>sample=eb4.wav key=51 <region>sample=e4.wav key=52 <region>sample=f4.wav key=53 <region>sample=gb4.wav key=54 <region>sample=g4.wav key=55 <region>sample=ab4.wav key=56 <region>sample=a4.wav key=57 <region>sample=bb4.wav key=58 <region>sample=b4.wav key=59 <region>sample=c5.wav key=60 Using this for both first and second violins will result in two identical-sounding sections with the same timbre, but it's easily possible to use the same samples transposed, and get a different timbre. Instead of using the C4 sample to play C4, use the Db4 sample transposed down a half step to play C4. This can be done by using lokey, hikey and pitch_keycenter opcodes instead of just key. <region>sample=c4.wav lokey=47 hikey=47 pitch_keycenter=48 <region>sample=db4.wav lokey=48 hikey=48 pitch_keycenter=49 <region>sample=d4.wav lokey=49 hikey=49 pitch_keycenter=50 <region>sample=eb4.wav lokey=50 hikey=50 pitch_keycenter=51 <region>sample=e4.wav lokey=51 hikey=51 pitch_keycenter=52 <region>sample=f4.wav lokey=52 hikey=52 pitch_keycenter=53 <region>sample=gb4.wav lokey=53 hikey=53 pitch_keycenter=54 <region>sample=g4.wav lokey=54 hikey=54 pitch_keycenter=55 <region>sample=ab4.wav lokey=55 hikey=55 pitch_keycenter=56 <region>sample=a4.wav lokey=56 hikey=56 pitch_keycenter=57 <region>sample=bb4.wav lokey=57 hikey=57 pitch_keycenter=58 <region>sample=b4.wav lokey=58 hikey=58 pitch_keycenter=59 <region>sample=c5.wav lokey=59 hikey=59 pitch_keycenter=60 Howerver, in most cases it's easier to use the key and transpose opcodes instead, and set the transpose amount for all the transposed regions at once. <global> transpose=-1 <region>sample=c4.wav key=47 <region>sample=db4.wav key=48 <region>sample=d4.wav key=49 <region>sample=eb4.wav key=50 <region>sample=e4.wav key=51 <region>sample=f4.wav key=52 <region>sample=gb4.wav key=53 <region>sample=g4.wav key=54 <region>sample=ab4.wav key=55 <region>sample=a4.wav key=56 <region>sample=bb4.wav key=57 <region>sample=b4.wav key=58 <region>sample=c5.wav key=59 This still requires changing the key opcode for every region, however. Doing this editing manually on large sample sets would be time-consuming, but the old tool sfzed allows easily adding, subtracting or multiplying current parameter values to regions, which becomes very useful when doing this with thousands of samples. This shifts the entire range of the instrument down by a half-step, though. In order to preserve the correct range, we can remove the transposed notes which got moved below the lowest pitch the instrument is capable of. That's easy. The top range is more tricky - if we extend the highest note to cover its original pitch as well, but then the same sample would be used for the same pitch by both sections. So, we can instead use the next-to-highest note, transposed up. This might not sound very consistent with the rest, but under these limitations, it can be a reasonable compromise. <global> transpose=-1 <region>sample=db4.wav key=48 <region>sample=d4.wav key=49 <region>sample=eb4.wav key=50 <region>sample=e4.wav key=51 <region>sample=f4.wav key=52 <region>sample=gb4.wav key=53 <region>sample=g4.wav key=54 <region>sample=ab4.wav key=55 <region>sample=a4.wav key=56 <region>sample=bb4.wav key=57 <region>sample=b4.wav key=58 <region>sample=c5.wav key=59 <region>sample=b4.wav key=60 transpose=1","title":"Transposition"},{"location":"tutorials/unison/#transposition-values","text":"In general, transposing downwards will result in a warmer sound, and transposing upwards will make the sound brighter and thinner. Transposing by more than a half step can be a good idea. In general, transposing by a minor third is a common way to create a big change in timbre. Transposing by much more than a minor third doesn't seem common outside of sound design not intended to be a realistic instrument emulation. Transposing down by a minor third while preserving the range in our example, and filling in the lost top of the range by transposing upwards might look like this: <global> transpose=-3 <region>sample=eb4.wav key=48 <region>sample=e4.wav key=49 <region>sample=f4.wav key=50 <region>sample=gb4.wav key=51 <region>sample=g4.wav key=52 <region>sample=ab4.wav key=53 <region>sample=a4.wav key=54 <region>sample=bb4.wav key=55 <region>sample=b4.wav key=56 <region>sample=c5.wav key=57 <region>sample=a4.wav key=58 transpose=1 <region>sample=bb4.wav key=59 transpose=1 <region>sample=b4.wav key=60 transpose=1 Note that all of the above assumes the instrument is sampled chromatically; for instruments which are sampled at wholetone intervals or diatonically, transposition by at least a whole step will be necessary to avoid using the same samples for a note. Instruments which are sampled every minor third will need an interval of at least a minor third etc.","title":"Transposition Values"},{"location":"tutorials/unison/#unison-by-transposition","text":"If we put both the original and transposed samples in the same SFZ file, each MIDI note will trigger two regions, and we now will have the sound of an ensemble which is twice as large as what was actually sampled. <group> <region>sample=c4.wav key=48 <region>sample=db4.wav key=49 <region>sample=d4.wav key=50 <region>sample=eb4.wav key=51 <region>sample=e4.wav key=52 <region>sample=f4.wav key=53 <region>sample=gb4.wav key=54 <region>sample=g4.wav key=55 <region>sample=ab4.wav key=56 <region>sample=a4.wav key=57 <region>sample=bb4.wav key=58 <region>sample=b4.wav key=59 <region>sample=c5.wav key=60 <group> transpose=-1 <region>sample=db4.wav key=48 <region>sample=d4.wav key=49 <region>sample=eb4.wav key=50 <region>sample=e4.wav key=51 <region>sample=f4.wav key=52 <region>sample=gb4.wav key=53 <region>sample=g4.wav key=54 <region>sample=ab4.wav key=55 <region>sample=a4.wav key=56 <region>sample=bb4.wav key=57 <region>sample=b4.wav key=58 <region>sample=c5.wav key=59 <region>sample=b4.wav key=60 transpose=1","title":"Unison By Transposition"},{"location":"tutorials/unison/#unison-by-round-robin","text":"For cases where the goal is to emulate overdubbed copies of the same instrument with the same timbre, rather than different instruments with different timbres, it's still necessary to avoid triggering the same samples. For example, is how guitar multitracking is typically emulated. This approach also works for instruments which are not pitched but it makes sense to layer them, for example handclaps. In such cases, unison can be implemented by using different round robin samples for each simultaneously playing sample. Using one note with four round robins as an example: <group>seq_length=4 key=48 <region>sample=c4_rr1.wav seq_position=1 <region>sample=c4_rr2.wav seq_position=2 <region>sample=c4_rr3.wav seq_position=3 <region>sample=c4_rr4.wav seq_position=4 We can create two by offsetting the round robins like this: <group>seq_length=4 key=48 <region>sample=c4_rr1.wav seq_position=1 <region>sample=c4_rr2.wav seq_position=2 <region>sample=c4_rr3.wav seq_position=3 <region>sample=c4_rr4.wav seq_position=4 <group>seq_length=4 key=48 <region>sample=c4_rr1.wav seq_position=4 <region>sample=c4_rr2.wav seq_position=1 <region>sample=c4_rr3.wav seq_position=2 <region>sample=c4_rr4.wav seq_position=3 The group headers aren't necessary and everything could be under one group, but for organizational purposes, they can make things easier. Or three, or a maximum of four: <group>seq_length=4 key=48 <region>sample=c4_rr1.wav seq_position=1 <region>sample=c4_rr2.wav seq_position=2 <region>sample=c4_rr3.wav seq_position=3 <region>sample=c4_rr4.wav seq_position=4 <group>seq_length=4 key=48 <region>sample=c4_rr1.wav seq_position=4 <region>sample=c4_rr2.wav seq_position=1 <region>sample=c4_rr3.wav seq_position=2 <region>sample=c4_rr4.wav seq_position=3 <group>seq_length=4 key=48 <region>sample=c4_rr1.wav seq_position=3 <region>sample=c4_rr2.wav seq_position=4 <region>sample=c4_rr3.wav seq_position=1 <region>sample=c4_rr4.wav seq_position=2 <group>seq_length=4 key=48 <region>sample=c4_rr1.wav seq_position=2 <region>sample=c4_rr2.wav seq_position=3 <region>sample=c4_rr3.wav seq_position=4 <region>sample=c4_rr4.wav seq_position=1 Note that this will not work well with random round robins, as it's possible that the same sample will be randomly selected for multiple regions.","title":"Unison By Round Robin"},{"location":"tutorials/unison/#width-and-detune","text":"Multitracked guitars will often be spread in stereo, as will unison voices in synthesizers etc. Spreading the above quad-tracked guitar in stereo is simple: <group>seq_length=4 key=48 pan=-100 <region>sample=c4_rr1.wav seq_position=1 <region>sample=c4_rr2.wav seq_position=2 <region>sample=c4_rr3.wav seq_position=3 <region>sample=c4_rr4.wav seq_position=4 <group>seq_length=4 key=48 pan=100 <region>sample=c4_rr1.wav seq_position=4 <region>sample=c4_rr2.wav seq_position=1 <region>sample=c4_rr3.wav seq_position=2 <region>sample=c4_rr4.wav seq_position=3 <group>seq_length=4 key=48 pan=-50 <region>sample=c4_rr1.wav seq_position=3 <region>sample=c4_rr2.wav seq_position=4 <region>sample=c4_rr3.wav seq_position=1 <region>sample=c4_rr4.wav seq_position=2 <group>seq_length=4 key=48 pan=50 <region>sample=c4_rr1.wav seq_position=2 <region>sample=c4_rr2.wav seq_position=3 <region>sample=c4_rr3.wav seq_position=4 <region>sample=c4_rr4.wav seq_position=1 It's also possible to apply slight detuning to each voice. That's probably not common with guitars, and unnecessary with section recordings where natural tuning differences will already be captured in the recordings, but it is very common in synthesizers, and can also be helpful when trying to turn solo instrument samples into a small section. Detune can even be used by itself to create multiple voices, and this is an especially viable approach for synthesizers. The amount of detune, as well as width, can be modulated. Here is an example of a saw oscillator with seven voices. <region>sample=*saw <region>pitch_oncc100=20 pan_oncc101=100 sample=*saw <region>pitch_oncc100=-20 pan_oncc101=-100 sample=*saw <region>pitch_oncc100=30 pan_oncc101=67 sample=*saw <region>pitch_oncc100=-30 pan_oncc101=-67 sample=*saw <region>pitch_oncc100=40 pan_oncc101=33 sample=*saw <region>pitch_oncc100=-40 pan_oncc101=-33 sample=*saw","title":"Width And Detune"},{"location":"tutorials/unison/#legato","text":"When self-muting is implemented, each set of unison samples will need to have its own polyphony groups, same as would be needed with multiple microphone positions. If there are true legato samples, that adds considerable complexity to the transposition trick. The below steps are not a universal set of instructions, but have worked successfully for at least two instruments. Create an extended-range map extending the range by the largest transposition amount in the direction opposite of the transposition. For example, if there are four transposed voices and are to be transposed down by a half-step, a full step, a minor third and a major third, add a major third of range to the top of the extended map. See the range extension tutorial for details on the basics. In addition to extending the lokey/hikey range, remember that the sw_previous range will also need to be extended. For the extremes of the range, there will be no samples with the correct interval available - use the nearest available interval. For the highest note of the extended range, there will be no upward interval sample available, but in practice using a sample of a downward half-step interval seems to work tolerably well. Make copies of this extended map to create the to-be-transposed maps. In each map, add the amount of shift for the particular map (for example -1) to lokey, hikey and sw_previous. Delete any regions with lokey or hikey above or below the final desired range, which might be both at the top and bottom of a map. Delete any regions with sw_previous above or below the final desired range. This isn't strictly necessary as those regions \"should\" never be played and will not affect the visible keyboard map, but will reduce parsing time and prevent weirdness when a note slightly outside the range is held by mistake and a note inside the range is pressed. Delete any regions where the sw_previous ened up being the same as the lokey/hikey, as these will likewise be never triggered. In theory these should never be created, so this is just to catch mistakes.","title":"Legato"},{"location":"tutorials/unison/#humanization","text":"When trying to emulate the sound of a larger section of instruments, especially when trying to turn a solo instrument into an emulated section, it can be useful to create small differences between each voice, especially when vibrato and legato are also emulated. This is probably not that important with sampled ensembles, such as emulating second violins, but with solo instruments it becomes crucial. Without independent per-voice humanization, emulated vibrato and legato can sound more like a solo instrument run through a chorus or other doubling effect, rather than separate performances. Aspects of the sound which can be humanized or randomized include timing, smoothing, phase, pitch, vibrato speed and vibrato depth. Here is a rather lengthy example, adapted from a real instrument, where each voice has separate pan settings for stereo spread and separate polyphony groups - these are basic features of unison, and not related to humanization, of course. The humanizing differences between the voices are differences in bend smoothing, in maximum vibrato depth, in the initial phase of the vibrato humanization LFOs, and in the fade times of the legato regions. The shallower vibrato and slower legato of the transposed regions emulate less confident, more hesitant players. <global> //Basic global stuff shared by all voices ampeg_release=0.25 ampeg_attack_oncc106=1 ampeg_release_oncc107=1.25 off_mode=normal bend_down=-1200 bend_up=1200 //Pitch bend smoothing is set separately for each voice amplitude_oncc100=100 amplitude_smoothcc1=100 locc100=1 amp_veltrack=0 loop_mode=loop_continuous //Vibrato //Pitch LFO depth is set separately for each voice lfo01_freq=2 //Any slower than this sounds really lousy lfo01_freq_oncc112=6 //8 Hz is about as fast as vibrato on cello can go lfo01_delay_oncc115=0.500 lfo01_fade_oncc116=0.500 //This LFO also does tremolo lfo01_volume_oncc21=1 //Not much - just a subtle effect on volume eq1_freq=2200 //EQ band for vibrato eq1_bw=2 lfo01_eq1gain_oncc21=3 //Again, pretty subtle lfo02_wave=1 //Second LFO to make things wobblier //Initial phase is set separately for each voice lfo02_phase_oncc131=0.7 //Phase affected by velocity, to pseudo-randomize while keeping both mics' LFOs in sync lfo02_freq=0.01 //Basically no movement at very slow speeds, just randomization lfo02_freq_oncc117=1 //Max rate is not very high, so it doesn't sound too obvious lfo02_pitch_oncc117=6 //Slight pitch wobbliness lfo02_freq_lfo01_oncc117=0.2 lfo02_freq_lfo01_oncc112=0.8 //Affect the rate of the other LFO for unsteady vibrato lfo03_wave=1 //And a third LFO for secondhand complex wobbliness //Initial phase is set separately for each voice lfo03_phase_oncc131=0.479 //Different phase response to velocity than the second LFO lfo03_freq=0.5 lfo03_freq_oncc117=-0.4 lfo03_freq_lfo2_oncc117=1 lfo03_pitch_oncc117=-4 <master> //Central voice bend_smooth=80 lfo01_pitch_oncc21=29 lfo02_phase=0 lfo03_phase=0.4 group=1 off_by=1 //Sustains legato <group> trigger=first #include \"mappings/ord_sus_map.sfz\" <group> trigger=legato offset=5000 offset_random=500 ampeg_attack=0.5 ampeg_vel2attack=-0.35 #include \"mappings/ord_sus_map.sfz\" <master> //Left voice using sample maps transposed by a half-step //Pan control not used in the central voice pan_oncc101=-100 //Values different than the central voice, for humanization purposes bend_smooth=91 lfo01_pitch_oncc21=17 lfo02_phase=0.05 lfo03_phase=0.3 group=2 off_by=2 //Sustains legato <group> trigger=first #include \"mappings/t1/ord_sus_map.sfz\" <group> trigger=legato offset=5000 offset_random=500 //Values different than the central voice, for humanization purposes ampeg_attack=0.55 ampeg_vel2attack=-0.4 #include \"mappings/t1/ord_sus_map.sfz\" <master> //Right voice using sample maps transposed by a whole step //Pan control not used in the central voice pan_oncc101=100 //Values different than the central voice, for humanization purposes bend_smooth=87 lfo01_pitch_oncc21=19 lfo02_phase=0.02 lfo03_phase=0.28 group=3 off_by=3 //Sustains legato <master> trigger=first #include \"mappings/t2/ord_sus_map.sfz\" <master> trigger=legato offset=5000 offset_random=500 //Values different than the central voice, for humanization purposes ampeg_attack=0.58 ampeg_vel2attack=-0.43 #include \"mappings/t2/ord_sus_map.sfz\"","title":"Humanization"},{"location":"tutorials/unison/#releases","text":"Implementing release samples with unison requires a little extra effort. It's easiest to simply implement releases for the center voice only, but even then it's necessary to be careful to avoid triggering too many release samples. At least in ARIA and Sforzando, a note-on event which triggers multiple regions (for example a multimic instrument, or one with simulated unison) will have multiple corresponding regions for the release region, causing the release region to be triggered multiple times. With seven mics and a separate release for each mic, this would mean a key release would trigger a total of 49 samples if not controlled with note_polyphony. However, setting note_polyphony=1 and giving each mic a different group number solves this. There's no need tu use off_by with the release groups. An example with releases only for the center voice: <global> //Basic global stuff shared by all voices ampeg_release=0.25 off_mode=normal //Center voice <master> //Sustains <group> #include \"mappings/ord_sus_map.sfz\" //Releases <group> trigger=release group=501 note_polyphony=1 #include \"mappings/ord_rel_map.sfz\" <master> //Left voice using sample maps transposed by a half-step //Pan control not used in the central voice pan_oncc101=-100 //Sustains <group> #include \"mappings/t1/ord_sus_map.sfz\" <master> //Right voice using sample maps transposed by a whole step //Pan control not used in the central voice pan_oncc101=100 //Sustains <master> #include \"mappings/t2/ord_sus_map.sfz\" With releases for all voices, just use a different group number for each voice's releases, like this example: <global> //Basic global stuff shared by all voices ampeg_release=0.25 off_mode=normal //Center voice <master> //Sustains <group> #include \"mappings/ord_sus_map.sfz\" //Releases <group> trigger=release group=501 note_polyphony=1 #include \"mappings/ord_rel_map.sfz\" <master> //Left voice using sample maps transposed by a half-step //Pan control not used in the central voice pan_oncc101=-100 //Sustains <group> #include \"mappings/t1/ord_sus_map.sfz\" //Releases <group> trigger=release group=502 note_polyphony=1 #include \"mappings/t1/ord_rel_map.sfz\" <master> //Right voice using sample maps transposed by a whole step //Pan control not used in the central voice pan_oncc101=100 //Sustains <master> #include \"mappings/t2/ord_sus_map.sfz\" //Releases <group> trigger=release group=503 note_polyphony=1 #include \"mappings/t2/ord_rel_map.sfz\" When using releases with round robins, it can be tricky to make the release sample round robin counter advance correctly. When there are 2 \"matching\" samples playing, ARIA appears to advance the counter for the releases by 2, and if there are 4 release round robins, only 2 of them will actually be used. One workaround for that is triggering an extra region of silence to make the round robin counter advance by 3, but this will only work if the number of regions is consistent and predictable. With instruments that have release samples with a number of microphone positions or organ stops, any of which could be on or off, the total number of matching regions is very difficult to assess, and it's far easier to use lorand/hirand to select the release samples instead.","title":"Releases"},{"location":"tutorials/unison/#round-robin-neighbor-borrowing","text":"Although not a method of achieving unison, round robin neighbor borrowing is another use of transposition, which likewise milks more out of a limited set of samples - specifically, emulating round robins where there are none, or increasing the amonut of available round robins. This works with either sequential round robin and random round robin approaches, or both at once. Let's use sequential round robins for this example, with a very small note range and three round robins sampled. <global> seq_length=3 <group> seq_position=1 <region>sample=c5_rr1.wav key=60 <region>sample=c#5_rr1.wav key=61 <region>sample=d5_rr1.wav key=62 <group> seq_position=2 <region>sample=c5_rr2.wav key=60 <region>sample=c#5_rr2.wav key=61 <region>sample=d5_rr2.wav key=62 <group> seq_position=3 <region>sample=c5_rr3.wav key=60 <region>sample=c#5_rr3.wav key=61 <region>sample=d5_rr3.wav key=62 We can double the amount of round robins by using a transposed sample from a neighboring note for every other note in the sequence. This means every other note repeat has a slightly different timbre, but it should sound more acceptable than using untransposed notes for the first three sequence positions and transposed notes for positions four through six. So, we increase the sequence length to six, and alternate between transposed and untransposed samples like this: <global> seq_length=6 <group> seq_position=1 <region>sample=c5_rr1.wav key=60 <region>sample=c#5_rr1.wav key=61 <region>sample=d5_rr1.wav key=62 <group> seq_position=2 <region>sample=c#5_rr1.wav key=60 transpose=-1 <region>sample=d5_rr1.wav key=61 transpose=-1 <region>sample=c#5_rr1.wav key=62 transpose=1 <group> seq_position=3 <region>sample=c5_rr2.wav key=60 <region>sample=c#5_rr2.wav key=61 <region>sample=d5_rr2.wav key=62 <group> seq_position=4 <region>sample=c#5_rr2.wav key=60 transpose=-1 <region>sample=d5_rr2.wav key=61 transpose=-1 <region>sample=c#5_rr2.wav key=62 transpose=1 <group> seq_position=5 <region>sample=c5_rr3.wav key=60 <region>sample=c#5_rr3.wav key=61 <region>sample=d5_rr3.wav key=62 <group> seq_position=6 <region>sample=c#5_rr3.wav key=60 transpose=-1 <region>sample=d5_rr3.wav key=61 transpose=-1 <region>sample=c#5_rr3.wav key=62 transpose=1 It's also possible to triple the amount of round robins by borrowing neighbors in both upwards and downwards direction for each note (except the lowest and highest note in the range, of course). In general, transposing by more than a half-step is not a good idea, as the timbral differences grow larger with larger transposition, but with some instruments it can be possible to get away with it. If there are many dynamic layers available, it's also possible to borrow from nearby dynamic layers, especially in the case of drums.","title":"Round Robin Neighbor Borrowing"},{"location":"tutorials/vibrato/","text":"Basic LFO vibrato Emulating vibrato for solo instruments or voices with LFOs is not difficult. The challenges are understanding the key aspects of vibrato on the real instrument, and keeping the number of parameters from growing too large to be easy to use. The examples here use SFZ 2 spec numbered LFOs , rather than the dedicated pitch, volume and filter LFOs and envelopes of SFZ 1. A lot of this can be done under the SFZ 1 specification as well, but there are some limitations. The most basic, typical vibrato is pitch vibrato - just an LFO modulating pitch. Making the minimum and maximum rates and depths that would be used by players in real life is important, of course. The numbers here are examples which would be decent for bowed strings - it has a rate of 2-10 Hz and a maximum depth of 35 cents. Wider and slower are certainly possible on real instruments, but isn't commonly used in performance. lfo01_pitch_oncc111=35 lfo01_freq=2 lfo01_freq_oncc112=8 Additional parameters In real life, however, players and singers will often start a note without vibrato, and add vibrato a fraction of a second later. This is where modulating the LFO delay parameter becomes useful, and possibly LFO fade as well. Delay seems like enough for most wind instruments and vocals, but having both delay and fade seems effective with bowed strings. lfo01_pitch_oncc111=35 lfo01_freq=2 lfo01_freq_oncc112=8 lfo01_delay_oncc115=0.500 lfo01_fade_oncc116=0.500 Vibrato on many instruments doesn't just affect pitch; on bowed strings, it seems to have a subtle effect on volume and timbre as well. We can have the same MIDI CC parameter control how much the vibrato LFO affects pitch, volume, and an EQ band, with the latter two being quite subtle. This is a good a time as any to note that not all vibrato is equal - it's not really practical to add vibrato to the lowest note playable on a cello, for example, or to a natural harmonic. With pizzicato, vibrato is possible, but probably should not affect the EQ band, and either only affect pitch or pitch plus a subtle effect on volume. The below will work reasonably for most bowed notes, however. lfo01_pitch_oncc111=35 lfo01_volume_oncc111=1 lfo01_freq=2 lfo01_freq_oncc112=8 lfo01_delay_oncc115=0.500 lfo01_fade_oncc116=0.500 eq1_freq=2000 eq1_bw=2 lfo01_eq1gain_oncc111=2 lfo01_eq1freq_oncc111=500 Humanization Vibrato can also be humanized, by varying the rate of the vibrato LFO. This can be done by modulating the rate of the vibrato LFO with another LFO. The ARIA sample & hold waveform can be used here, and the modulation depth controlled by MIDI CC, so when that's at zero, no humanization happens. lfo02_freq=1 lfo02_wave=12 //Sample & hold LFO waveform number lfo02_freq_lfo01_oncc117=1 Or, to stay in the SFZ 2 spec and not use ARIA extensions, a sine wave with randomized starting phase will also work: lfo02_freq=1 lfo02_phase_oncc135=1 lfo02_freq_lfo01_oncc117=1 However, when playing multiple layers, such as sustain samples with crossfaded dynamics or multiple mic positions, this can cause each layer's vibrato to drift out of sync and sound like separate instruments. This is generally not desirable, so it is possible to pseudo-randomize the starting phase using a non-random CC, such as velocity (which is often otherwise unused in sustain sounds with crossfaded dynamics). If the SFZ player can have a global sample and hold LFO which does not retrigger for each note, this would also be a solution, though ARIA does not allow this. lfo02_freq=1 lfo02_phase_oncc132=0.7 lfo02_freq_lfo01_oncc117=1 This will vary the rate of the vibrato, but the depth will be constant. It is possible to have an LFO modulate the depth of another LFO, measured as a percentage, for example 120% for 20% variation: lfo02_freq=1 lfo02_phase_oncc132=0.7 lfo02_freq_lfo01_oncc117=1 lfo02_depth_lfo01=120 For additional complexity, it's also possible to have the random LFO itself modulate pitch, which will create some pitch drift, and have more than two LFOs involved. Here is a fairly sophisticated example. //Vibrato lfo01_pitch_oncc21=29 //Vibrato LFO lfo01_freq=2 //Any slower than this sounds really lousy lfo01_freq_oncc112=6 //8 Hz is about as fast as vibrato on cello can go lfo01_delay_oncc115=0.500 lfo01_fade_oncc116=0.500 //This LFO also does tremolo lfo01_volume_oncc21=1 //Not much - just a subtle effect on volume eq1_freq=2200 //EQ band for vibrato eq1_bw=2 lfo01_eq1gain_oncc21=3 //Again, pretty subtle lfo02_wave=1 //Second LFO to make things wobblier lfo02_phase=0 lfo02_phase_oncc131=0.7 //Phase affected by velocity, to pseudo-randomize while keeping both mics' LFOs in sync lfo02_freq=0.01 //Basically no movement at very slow speeds, just randomization lfo02_freq_oncc117=1 //Max rate is not very high, so it doesn't sound too obvious lfo02_pitch_oncc117=6 //Slight pitch wobbliness lfo02_freq_lfo01_oncc117=1 //Affect the rate of the other LFO for unsteady vibrato lfo03_wave=1 //And a third LFO for secondhand complex wobbliness lfo03_phase=0.4 lfo03_phase_oncc131=0.479 //Different phase response to velocity than the second LFO lfo03_freq=0.5 lfo03_freq_oncc117=-0.4 lfo03_freq_lfo02_oncc117=1 lfo03_pitch_oncc117=-4 However, note that the depth modulation is fixed, and not modulated by cc117 like the frequency modulation is. This is because having a CC modulate the depth modulation does not appear to be implemented in ARIA. It is, however, possible to modulate the depth of a flex envelope with MIDI CC, and then have that envelope depth modulate the depth of the secondary LFO. This is, admittedly, very much a kludge, but it appears to work. lfo02_freq=1 lfo02_phase_oncc132=0.7 lfo02_freq_lfo01_oncc117=1 lfo02_depth_lfo01=120 eg1_level0_oncc117=1 eg1_level1_oncc117=1 eg1_depth_lfo02=100 However, when the depth of lfo02 is zero, this will effectively also make lfo01's depth zero, so there will be no vibrato at all unless cc117 is turned up. Getting around this requires another kludge, which is leaving lfo01 with fixed depth and creating yet another LFO for the variable part of the depth. //Vibrato lfo01_pitch_oncc21=29 //Vibrato LFO lfo01_freq=2 //Any slower than this sounds really lousy lfo01_freq_oncc112=6 //8 Hz is about as fast as vibrato on cello can go lfo01_delay_oncc115=0.500 lfo01_fade_oncc116=0.500 //This LFO also does tremolo lfo01_volume_oncc21=1 //Not much - just a subtle effect on volume eq1_freq=2200 //EQ band for vibrato eq1_bw=2 lfo01_eq1gain_oncc21=3 //Again, pretty subtle lfo02_pitch_oncc21=19 //Extra LFO for variable depth, shallower than main and pitch only lfo02_freq=2 //Same timing as first LFO lfo02_freq_oncc112=6 lfo02_delay_oncc115=0.500 lfo02_fade_oncc116=0.500 lfo03_wave=1 //Third LFO to make the flrst two LFOs wobblier lfo03_phase=0 lfo03_phase_oncc131=0.7 //Phase affected by velocity, to pseudo-randomize while keeping both mics' LFOs in sync lfo03_freq=0.01 //Basically no movement at very slow speeds, just randomization lfo03_freq_oncc117=1 //Max rate is not very high, so it doesn't sound too obvious lfo03_pitch=6 //Slight pitch wobbliness lfo03_freq_lfo01=1 lfo03_freq_lfo02=1 //Affect the rate of the vibrato LFOs for unsteady vibrato lfo04_wave=1 //And a fourth LFO for secondhand complex wobbliness lfo04_phase=0.4 lfo04_phase_oncc131=0.479 //Different phase response to velocity than the second LFO lfo04_freq=0.5 lfo04_freq_oncc117=-0.4 lfo04_freq_lfo03=1 lfo04_pitch=-4 lfo03_depth_lfo02=100 lfo04_depth_lfo02=100 eg1_level0_oncc117=1 eg1_level1_oncc117=1 eg1_depth_lfo03=100 eg1_depth_lfo04=100 Asymmetrical vibrato Something similar to the above will work fairly well for a range of strings and voices. However, there are cases where vibrato should only go in one direction - for example, bending guitar strings only moves the pitch upwards, while on saxophone it's possible to play vibrato centered around the pitch, but most of the time players will go only below the pitch. Let's use saxophone vibrato as an example. To keep it simple, let's just go back to a simple, non-humanized vibrato with only depth and rate paremeters. To have vibrato which will go below the main pitch is simple - the LFO phase can be set so the wave starts at the top, and the note tuned down by the vibrato depth amount. lfo01_pitch_oncc111=20 lfo01_phase=0.25 lfo01_freq=1.5 lfo01_freq_oncc112=6 pitch_oncc111=-20 This will work fine, as long as we don't try to apply delay or fade to the LFO, which would result in the note starting out flat with no vibrato. To solve that problem, we can combine the LFO with a pitch envelope . Here is an example with just delay: lfo01_pitch_oncc111=20 lfo01_freq=1.5 lfo01_freq_oncc112=6 lfo01_phase=0.25 lfo01_delay_oncc116=1 pitcheg_delay_oncc116=1 pitcheg_depth_oncc111=-20 To have the choice of idiomatic sax vibrato and violin-style vibrato centered around the pitch can be done separate LFOs and separate depth controls. It's also possible to duplicate all the regions and use loccN/hiccN to select between ones with different styles of vibrato. lfo01_pitch_oncc111=20 //Sax vibrato LFO - goes down from the main pitch lfo01_freq=1.5 lfo01_freq_oncc112=6 lfo01_phase=0.25 //Starts at top lfo01_delay_oncc116=1 pitcheg_delay_oncc116=1 //Pitch envelope to drop the central pitch when sax vibrato kicks in pitcheg_depth_oncc111=-20 lfo02_pitch_oncc114=20 //Violin vibrato LFO - goes below and above main pitch lfo02_freq=1.5 lfo02_freq_oncc112=6 //Same rate as the first LFO lfo02_phase=0.5 //Starts in the middle, goes down first before going up lfo02_delay_oncc116=1 //Same delay, too This covers jaw vibrato, but sax players also use diaphragm vibrato, which changes volume and has no effect on pitch, which means there are now three vibrato depths. Having the volume modulated by the second LFO is a little easier, as the phase setting of the first LFO would mean having to apply a volume envelope as well. lfo01_pitch_oncc111=20 //Sax vibrato LFO - goes down from the main pitch lfo01_freq=1.5 lfo01_freq_oncc112=6 lfo01_phase=0.25 //Starts at top lfo01_delay_oncc116=1 pitcheg_delay_oncc116=1 //Pitch envelope to drop the central pitch when sax vibrato kicks in pitcheg_depth_oncc111=-20 lfo02_pitch_oncc114=20 //Violin vibrato LFO - goes below and above main pitch lfo02_freq=1.5 lfo02_freq_oncc112=6 //Same rate as the first LFO lfo02_delay_oncc116=1 //Same delay, too lfo02_phase=0.5 //Starts in the middle, goes down first before going up lfo02_volume=0 //This LFO also does tremolo lfo02_volume_oncc113=3 There is one additional consideration with diaphragm vibrato - when the volume of the note drops down, the breath noise can become more prominent, especially on quiet notes or when using the subtone technique. If the volume of the breath noise can be modulated separately, the noise regions should not be affected by pitch vibrato, and be affected by the diaphragm vibrato in an opposite direction to the notes. So, if the above vibrato settings are set under a \u2039global\u203a header, the breath noise sample regions could have settings similar to this. lfo01_pitch_oncc111=0 //LFOs do not affect pitch pitcheg_depth_oncc111=0 lfo02_pitch_oncc114=0 lfo02_volume_oncc113=-3 //Diaphragm vibrato affects volume in the opposite direction Humanization and having the diaphragm vibrato affect timbre can be done similarly as with the strings above, ensuring both LFOs are humanized in sync with each other, so they do not drift apart. More special cases Some instruments will have vibrato types which require special treatment, for example guitar tremolo bridges will bend each string's pitch by a different amount when playing chords. This requires different pitch modulation depths for each string. Vibrato can also be used to modulate filter cutoffs , which is commonly used in synthesizers to create evolving pads or wobble basses. This is not difficult to implement. Here is an example of a synthesizer style vibrato with a typical lowpass filter, and vibrato which can affect pitch, volume or filter cutoff. //Filter //Lowpass filter cutoff=120 cutoff_cc120=13200 fil_keytrack=100 resonance=0 resonance_cc121=12 //Vibrato lfo01_freq=1 lfo01_freq_oncc112=11 lfo01_delay_oncc115=0.500 lfo01_fade_oncc116=0.500 lfo01_pitch_oncc111=22 //Vibrato LFO affects pitch lfo01_volume_oncc114=6 //Volume tremolo lfo01_cutoff=0 //Filter wobble lfo01_cutoff_oncc113=3600 An unusual use of extremely deep vibrato and tremolo plus humanization is emulating vinyl scratching. Pitch sweeps of 2+ octaves with strongly humanized LFO rate can resemble vinyl scratching, though unlike real scratching, these LFOs are not controllable, and therefore rhythmic scratching is not an option. //Extreme vibrato that can resemble vinyl scratching //The depths are high but will be made even higher by the modulation of the LFO depth lfo01_pitch_oncc21=1333 //Extremely deep vibrato for vinyl emulation lfo01_freq=1 lfo01_freq_oncc112=9 //No delay but there is fade lfo01_fade_oncc116=0.5 //This LFO also does tremolo lfo01_volume_oncc21=7 //Again very heavy lfo02_wave=1 //Second LFO to make things wobblier lfo02_phase=0 lfo02_phase_oncc135=1 //Random lfo02_freq=0.01 //Basically no movement at very slow speeds, just randomization lfo02_freq_oncc117=1 //Max rate is not very high, so it doesn't sound too obvious lfo02_freq_lfo01_oncc117=1 //Affect the rate of the other LFO for unsteady vibrato lfo03_wave=1 //And a third LFO for secondhand complex wobbliness lfo03_phase=0.4 lfo03_phase_oncc135=0.479 //Different phase response to velocity than the second LFO lfo03_freq=0.5 lfo03_freq_oncc117=-0.4 lfo03_freq_lfo2_oncc117=1 lfo03_depth_lfo01=200 lfo02_depth_lfo01=233 eg1_level0_oncc117=1 eg1_level1_oncc117=1 eg1_depth_lfo2=100 eg1_depth_lfo3=100 This by no means exhausts all the possibilties of vibrato. It does provide a decent combination of control and realism for a lot of common instrument types, as well as some wild possibilities.","title":"Vibrato"},{"location":"tutorials/vibrato/#basic-lfo-vibrato","text":"Emulating vibrato for solo instruments or voices with LFOs is not difficult. The challenges are understanding the key aspects of vibrato on the real instrument, and keeping the number of parameters from growing too large to be easy to use. The examples here use SFZ 2 spec numbered LFOs , rather than the dedicated pitch, volume and filter LFOs and envelopes of SFZ 1. A lot of this can be done under the SFZ 1 specification as well, but there are some limitations. The most basic, typical vibrato is pitch vibrato - just an LFO modulating pitch. Making the minimum and maximum rates and depths that would be used by players in real life is important, of course. The numbers here are examples which would be decent for bowed strings - it has a rate of 2-10 Hz and a maximum depth of 35 cents. Wider and slower are certainly possible on real instruments, but isn't commonly used in performance. lfo01_pitch_oncc111=35 lfo01_freq=2 lfo01_freq_oncc112=8","title":"Basic LFO vibrato"},{"location":"tutorials/vibrato/#additional-parameters","text":"In real life, however, players and singers will often start a note without vibrato, and add vibrato a fraction of a second later. This is where modulating the LFO delay parameter becomes useful, and possibly LFO fade as well. Delay seems like enough for most wind instruments and vocals, but having both delay and fade seems effective with bowed strings. lfo01_pitch_oncc111=35 lfo01_freq=2 lfo01_freq_oncc112=8 lfo01_delay_oncc115=0.500 lfo01_fade_oncc116=0.500 Vibrato on many instruments doesn't just affect pitch; on bowed strings, it seems to have a subtle effect on volume and timbre as well. We can have the same MIDI CC parameter control how much the vibrato LFO affects pitch, volume, and an EQ band, with the latter two being quite subtle. This is a good a time as any to note that not all vibrato is equal - it's not really practical to add vibrato to the lowest note playable on a cello, for example, or to a natural harmonic. With pizzicato, vibrato is possible, but probably should not affect the EQ band, and either only affect pitch or pitch plus a subtle effect on volume. The below will work reasonably for most bowed notes, however. lfo01_pitch_oncc111=35 lfo01_volume_oncc111=1 lfo01_freq=2 lfo01_freq_oncc112=8 lfo01_delay_oncc115=0.500 lfo01_fade_oncc116=0.500 eq1_freq=2000 eq1_bw=2 lfo01_eq1gain_oncc111=2 lfo01_eq1freq_oncc111=500","title":"Additional parameters"},{"location":"tutorials/vibrato/#humanization","text":"Vibrato can also be humanized, by varying the rate of the vibrato LFO. This can be done by modulating the rate of the vibrato LFO with another LFO. The ARIA sample & hold waveform can be used here, and the modulation depth controlled by MIDI CC, so when that's at zero, no humanization happens. lfo02_freq=1 lfo02_wave=12 //Sample & hold LFO waveform number lfo02_freq_lfo01_oncc117=1 Or, to stay in the SFZ 2 spec and not use ARIA extensions, a sine wave with randomized starting phase will also work: lfo02_freq=1 lfo02_phase_oncc135=1 lfo02_freq_lfo01_oncc117=1 However, when playing multiple layers, such as sustain samples with crossfaded dynamics or multiple mic positions, this can cause each layer's vibrato to drift out of sync and sound like separate instruments. This is generally not desirable, so it is possible to pseudo-randomize the starting phase using a non-random CC, such as velocity (which is often otherwise unused in sustain sounds with crossfaded dynamics). If the SFZ player can have a global sample and hold LFO which does not retrigger for each note, this would also be a solution, though ARIA does not allow this. lfo02_freq=1 lfo02_phase_oncc132=0.7 lfo02_freq_lfo01_oncc117=1 This will vary the rate of the vibrato, but the depth will be constant. It is possible to have an LFO modulate the depth of another LFO, measured as a percentage, for example 120% for 20% variation: lfo02_freq=1 lfo02_phase_oncc132=0.7 lfo02_freq_lfo01_oncc117=1 lfo02_depth_lfo01=120 For additional complexity, it's also possible to have the random LFO itself modulate pitch, which will create some pitch drift, and have more than two LFOs involved. Here is a fairly sophisticated example. //Vibrato lfo01_pitch_oncc21=29 //Vibrato LFO lfo01_freq=2 //Any slower than this sounds really lousy lfo01_freq_oncc112=6 //8 Hz is about as fast as vibrato on cello can go lfo01_delay_oncc115=0.500 lfo01_fade_oncc116=0.500 //This LFO also does tremolo lfo01_volume_oncc21=1 //Not much - just a subtle effect on volume eq1_freq=2200 //EQ band for vibrato eq1_bw=2 lfo01_eq1gain_oncc21=3 //Again, pretty subtle lfo02_wave=1 //Second LFO to make things wobblier lfo02_phase=0 lfo02_phase_oncc131=0.7 //Phase affected by velocity, to pseudo-randomize while keeping both mics' LFOs in sync lfo02_freq=0.01 //Basically no movement at very slow speeds, just randomization lfo02_freq_oncc117=1 //Max rate is not very high, so it doesn't sound too obvious lfo02_pitch_oncc117=6 //Slight pitch wobbliness lfo02_freq_lfo01_oncc117=1 //Affect the rate of the other LFO for unsteady vibrato lfo03_wave=1 //And a third LFO for secondhand complex wobbliness lfo03_phase=0.4 lfo03_phase_oncc131=0.479 //Different phase response to velocity than the second LFO lfo03_freq=0.5 lfo03_freq_oncc117=-0.4 lfo03_freq_lfo02_oncc117=1 lfo03_pitch_oncc117=-4 However, note that the depth modulation is fixed, and not modulated by cc117 like the frequency modulation is. This is because having a CC modulate the depth modulation does not appear to be implemented in ARIA. It is, however, possible to modulate the depth of a flex envelope with MIDI CC, and then have that envelope depth modulate the depth of the secondary LFO. This is, admittedly, very much a kludge, but it appears to work. lfo02_freq=1 lfo02_phase_oncc132=0.7 lfo02_freq_lfo01_oncc117=1 lfo02_depth_lfo01=120 eg1_level0_oncc117=1 eg1_level1_oncc117=1 eg1_depth_lfo02=100 However, when the depth of lfo02 is zero, this will effectively also make lfo01's depth zero, so there will be no vibrato at all unless cc117 is turned up. Getting around this requires another kludge, which is leaving lfo01 with fixed depth and creating yet another LFO for the variable part of the depth. //Vibrato lfo01_pitch_oncc21=29 //Vibrato LFO lfo01_freq=2 //Any slower than this sounds really lousy lfo01_freq_oncc112=6 //8 Hz is about as fast as vibrato on cello can go lfo01_delay_oncc115=0.500 lfo01_fade_oncc116=0.500 //This LFO also does tremolo lfo01_volume_oncc21=1 //Not much - just a subtle effect on volume eq1_freq=2200 //EQ band for vibrato eq1_bw=2 lfo01_eq1gain_oncc21=3 //Again, pretty subtle lfo02_pitch_oncc21=19 //Extra LFO for variable depth, shallower than main and pitch only lfo02_freq=2 //Same timing as first LFO lfo02_freq_oncc112=6 lfo02_delay_oncc115=0.500 lfo02_fade_oncc116=0.500 lfo03_wave=1 //Third LFO to make the flrst two LFOs wobblier lfo03_phase=0 lfo03_phase_oncc131=0.7 //Phase affected by velocity, to pseudo-randomize while keeping both mics' LFOs in sync lfo03_freq=0.01 //Basically no movement at very slow speeds, just randomization lfo03_freq_oncc117=1 //Max rate is not very high, so it doesn't sound too obvious lfo03_pitch=6 //Slight pitch wobbliness lfo03_freq_lfo01=1 lfo03_freq_lfo02=1 //Affect the rate of the vibrato LFOs for unsteady vibrato lfo04_wave=1 //And a fourth LFO for secondhand complex wobbliness lfo04_phase=0.4 lfo04_phase_oncc131=0.479 //Different phase response to velocity than the second LFO lfo04_freq=0.5 lfo04_freq_oncc117=-0.4 lfo04_freq_lfo03=1 lfo04_pitch=-4 lfo03_depth_lfo02=100 lfo04_depth_lfo02=100 eg1_level0_oncc117=1 eg1_level1_oncc117=1 eg1_depth_lfo03=100 eg1_depth_lfo04=100","title":"Humanization"},{"location":"tutorials/vibrato/#asymmetrical-vibrato","text":"Something similar to the above will work fairly well for a range of strings and voices. However, there are cases where vibrato should only go in one direction - for example, bending guitar strings only moves the pitch upwards, while on saxophone it's possible to play vibrato centered around the pitch, but most of the time players will go only below the pitch. Let's use saxophone vibrato as an example. To keep it simple, let's just go back to a simple, non-humanized vibrato with only depth and rate paremeters. To have vibrato which will go below the main pitch is simple - the LFO phase can be set so the wave starts at the top, and the note tuned down by the vibrato depth amount. lfo01_pitch_oncc111=20 lfo01_phase=0.25 lfo01_freq=1.5 lfo01_freq_oncc112=6 pitch_oncc111=-20 This will work fine, as long as we don't try to apply delay or fade to the LFO, which would result in the note starting out flat with no vibrato. To solve that problem, we can combine the LFO with a pitch envelope . Here is an example with just delay: lfo01_pitch_oncc111=20 lfo01_freq=1.5 lfo01_freq_oncc112=6 lfo01_phase=0.25 lfo01_delay_oncc116=1 pitcheg_delay_oncc116=1 pitcheg_depth_oncc111=-20 To have the choice of idiomatic sax vibrato and violin-style vibrato centered around the pitch can be done separate LFOs and separate depth controls. It's also possible to duplicate all the regions and use loccN/hiccN to select between ones with different styles of vibrato. lfo01_pitch_oncc111=20 //Sax vibrato LFO - goes down from the main pitch lfo01_freq=1.5 lfo01_freq_oncc112=6 lfo01_phase=0.25 //Starts at top lfo01_delay_oncc116=1 pitcheg_delay_oncc116=1 //Pitch envelope to drop the central pitch when sax vibrato kicks in pitcheg_depth_oncc111=-20 lfo02_pitch_oncc114=20 //Violin vibrato LFO - goes below and above main pitch lfo02_freq=1.5 lfo02_freq_oncc112=6 //Same rate as the first LFO lfo02_phase=0.5 //Starts in the middle, goes down first before going up lfo02_delay_oncc116=1 //Same delay, too This covers jaw vibrato, but sax players also use diaphragm vibrato, which changes volume and has no effect on pitch, which means there are now three vibrato depths. Having the volume modulated by the second LFO is a little easier, as the phase setting of the first LFO would mean having to apply a volume envelope as well. lfo01_pitch_oncc111=20 //Sax vibrato LFO - goes down from the main pitch lfo01_freq=1.5 lfo01_freq_oncc112=6 lfo01_phase=0.25 //Starts at top lfo01_delay_oncc116=1 pitcheg_delay_oncc116=1 //Pitch envelope to drop the central pitch when sax vibrato kicks in pitcheg_depth_oncc111=-20 lfo02_pitch_oncc114=20 //Violin vibrato LFO - goes below and above main pitch lfo02_freq=1.5 lfo02_freq_oncc112=6 //Same rate as the first LFO lfo02_delay_oncc116=1 //Same delay, too lfo02_phase=0.5 //Starts in the middle, goes down first before going up lfo02_volume=0 //This LFO also does tremolo lfo02_volume_oncc113=3 There is one additional consideration with diaphragm vibrato - when the volume of the note drops down, the breath noise can become more prominent, especially on quiet notes or when using the subtone technique. If the volume of the breath noise can be modulated separately, the noise regions should not be affected by pitch vibrato, and be affected by the diaphragm vibrato in an opposite direction to the notes. So, if the above vibrato settings are set under a \u2039global\u203a header, the breath noise sample regions could have settings similar to this. lfo01_pitch_oncc111=0 //LFOs do not affect pitch pitcheg_depth_oncc111=0 lfo02_pitch_oncc114=0 lfo02_volume_oncc113=-3 //Diaphragm vibrato affects volume in the opposite direction Humanization and having the diaphragm vibrato affect timbre can be done similarly as with the strings above, ensuring both LFOs are humanized in sync with each other, so they do not drift apart.","title":"Asymmetrical vibrato"},{"location":"tutorials/vibrato/#more-special-cases","text":"Some instruments will have vibrato types which require special treatment, for example guitar tremolo bridges will bend each string's pitch by a different amount when playing chords. This requires different pitch modulation depths for each string. Vibrato can also be used to modulate filter cutoffs , which is commonly used in synthesizers to create evolving pads or wobble basses. This is not difficult to implement. Here is an example of a synthesizer style vibrato with a typical lowpass filter, and vibrato which can affect pitch, volume or filter cutoff. //Filter //Lowpass filter cutoff=120 cutoff_cc120=13200 fil_keytrack=100 resonance=0 resonance_cc121=12 //Vibrato lfo01_freq=1 lfo01_freq_oncc112=11 lfo01_delay_oncc115=0.500 lfo01_fade_oncc116=0.500 lfo01_pitch_oncc111=22 //Vibrato LFO affects pitch lfo01_volume_oncc114=6 //Volume tremolo lfo01_cutoff=0 //Filter wobble lfo01_cutoff_oncc113=3600 An unusual use of extremely deep vibrato and tremolo plus humanization is emulating vinyl scratching. Pitch sweeps of 2+ octaves with strongly humanized LFO rate can resemble vinyl scratching, though unlike real scratching, these LFOs are not controllable, and therefore rhythmic scratching is not an option. //Extreme vibrato that can resemble vinyl scratching //The depths are high but will be made even higher by the modulation of the LFO depth lfo01_pitch_oncc21=1333 //Extremely deep vibrato for vinyl emulation lfo01_freq=1 lfo01_freq_oncc112=9 //No delay but there is fade lfo01_fade_oncc116=0.5 //This LFO also does tremolo lfo01_volume_oncc21=7 //Again very heavy lfo02_wave=1 //Second LFO to make things wobblier lfo02_phase=0 lfo02_phase_oncc135=1 //Random lfo02_freq=0.01 //Basically no movement at very slow speeds, just randomization lfo02_freq_oncc117=1 //Max rate is not very high, so it doesn't sound too obvious lfo02_freq_lfo01_oncc117=1 //Affect the rate of the other LFO for unsteady vibrato lfo03_wave=1 //And a third LFO for secondhand complex wobbliness lfo03_phase=0.4 lfo03_phase_oncc135=0.479 //Different phase response to velocity than the second LFO lfo03_freq=0.5 lfo03_freq_oncc117=-0.4 lfo03_freq_lfo2_oncc117=1 lfo03_depth_lfo01=200 lfo02_depth_lfo01=233 eg1_level0_oncc117=1 eg1_level1_oncc117=1 eg1_depth_lfo2=100 eg1_depth_lfo3=100 This by no means exhausts all the possibilties of vibrato. It does provide a decent combination of control and realism for a lot of common instrument types, as well as some wild possibilities.","title":"More special cases"},{"location":"tutorials/videos/","text":"Here are a couple of videos to help you get started with SFZ SFZ Tutorial Part 1 : Hello World! by David Viens SFZ Tutorial Part 2 : Generators, transpose and ADSR by David Viens VSCO 2: Community Edition - SFZ Tutorial by Versilian Studios How to use our Free SFZ Instruments by Versilian Studios Folder to SFZ Converter / Automapper by Sam Gossner Sforzando introduction and overview by PatchArena Getting Started with SFZ by David Hilowitz Music How to make TRUE legato sample libraries in SFZ by David Hilowitz Music Recording samples using Ardour and LinuxSampler by Sonoj Convention","title":"SFZ Programming Video Tutorials"},{"location":"tutorials/volume/","text":"The SFZ format allows many different ways of controlling volume. There's the modulation of volume by opcodes, there's velocity tracking, and there's also modualtion by envelopes and LFOs. This is currently a work in progress, collecting information in tutorial form, though it might be turned into another type of page eventually. Opcodes affecting playback volume The relevant opcodes are: volume , amplitude , xfin / xfout , amp_veltrack , amp_keytrack , amp_velcurve_N . There are also envelope and LFO modulation sources: ampeg , amplfo , and volume-related targets for egN and lfoN . Some of them will have multiple stages, points, CCs etc, so the volume of one sample can be affected by many different things at once. Velocity tracking This is affected by amp_veltrack and amp_velcurve_N. In addition, vel2 modulations can affect amp envelope durations as well as the sustain level (though not the peak level at the end of the attack phase) and in ARIA extended CC 131 can also modulate things which affect volume, for example egN levels. Remember that amp_veltrack is 100 by default, so if dynamics are to be controlled by things other than velocity and dynamics should be controlled, for examle, by mod wheel, then set amp_veltrack to 0, as in the code example in the next section. When using velocity layers, remember that a quiet velocity layer will have a certain max velocity, for example if a region has hivel set to 31, it will never be triggered by velocities higher than 31, and therefore should usually either have amp_velcurve_31 set to 1, or amp_veltrack should be set to 0. <group> hivel=42 amp_velcurve_42=1 #include \"quiet_layer.sfz\" <group> lovel=43 hivel=84 amp_velcurve_84=1 #include \"middle_layer.sfz\" <group> lovel=85 #include \"loud_layer.sfz\" Volume, amplitude and crossfade Volume, amplitude, and crossfade generally affect the playback volume of the entire region, beginning to end. \"Generally\" because amplitude and volume can be modulated by CCs while the sample is playing. Volume is additive and measured in decibels, so volume=6 adds 6 dB to the sample's playback volume. Amplitude is multiplicative, and is a percentage of full amplitude, so amplitude=6 would mean the sample is played at 6% amplitude. Xfin and xfout are intended for cross-fading dynamic layers, and set the CC values for zero amplitude and full amplitude. One limitation here is that it's not possible to have a layer which has more than zero amplitude at the start of the fade-in. This is important for instruments such as bowed strings, which have a certain minimum practical playable loudness. These will often have dynamics linked to CC1 or some other CC, and need to have some small amount of audible volume even at the lowest CC level. Here, amplitude with curveccN can be used to fade in the lowest layer. It's still possible to use xfout to fade the layer out at higher CC values as the next layer fades in, though it may be simpler to just use amplitude for all layers, for example like this: <global> amp_veltrack=0 <group> amplitude_oncc1=100 amplitude_curvecc1=11 #include \"quiet_layer.sfz\" <group> amplitude_oncc1=100 amplitude_curvecc1=12 #include \"loud_layer.sfz\" <curve> curve_index=11 v000=0.4 v063=1 v127=0 <curve> curve_index=12 v000=0 v063=0 v127=1 Envelopes and LFOs Both the ampeg envelope and one or more egN flex envelopes can be used in parallel. The same is true of amplfo and lfoN flex LFOs. These affect the volume of the region differently across time, obviously. Randomization amp_random and its alias gain_random work like volume/gain and are measured in decibels. In ARIA and Cakewalk, amp_random is unipolar. In the rgc sfz player, amp_random is bipolar. In ARIA, CC135 (unipolar random) and 136 (bipolar random) can also be used by various opcodes which modulate volume. Stacking mutliple modulations It is possible to have multiple CCs modulating the same opcode for the same region. This can make sense with multiple mic positions, for example. There can be a release samples volume control affecting release sample amplitude for all mics, and individual mic controls with the amplitude for all samples recorded through that mic. The effect with amplitude would be multiplicative - so with either control at 0, there would be no sound. <master> amplitude_oncc80=100 //Close mic volume <group> #include \"close_notes.sfz\" <group> trigger=release amplitude_oncc82=100 //Release noise volume #include \"close_releases.sfz\" <master> amplitude_oncc81=100 //Far mic volume <group> #include \"far_notes.sfz\" <group> trigger=release amplitude_oncc82=100 //Release noise volume #include \"far_releases.sfz\"","title":"Control of volume"},{"location":"tutorials/volume/#opcodes-affecting-playback-volume","text":"The relevant opcodes are: volume , amplitude , xfin / xfout , amp_veltrack , amp_keytrack , amp_velcurve_N . There are also envelope and LFO modulation sources: ampeg , amplfo , and volume-related targets for egN and lfoN . Some of them will have multiple stages, points, CCs etc, so the volume of one sample can be affected by many different things at once.","title":"Opcodes affecting playback volume"},{"location":"tutorials/volume/#velocity-tracking","text":"This is affected by amp_veltrack and amp_velcurve_N. In addition, vel2 modulations can affect amp envelope durations as well as the sustain level (though not the peak level at the end of the attack phase) and in ARIA extended CC 131 can also modulate things which affect volume, for example egN levels. Remember that amp_veltrack is 100 by default, so if dynamics are to be controlled by things other than velocity and dynamics should be controlled, for examle, by mod wheel, then set amp_veltrack to 0, as in the code example in the next section. When using velocity layers, remember that a quiet velocity layer will have a certain max velocity, for example if a region has hivel set to 31, it will never be triggered by velocities higher than 31, and therefore should usually either have amp_velcurve_31 set to 1, or amp_veltrack should be set to 0. <group> hivel=42 amp_velcurve_42=1 #include \"quiet_layer.sfz\" <group> lovel=43 hivel=84 amp_velcurve_84=1 #include \"middle_layer.sfz\" <group> lovel=85 #include \"loud_layer.sfz\"","title":"Velocity tracking"},{"location":"tutorials/volume/#volume-amplitude-and-crossfade","text":"Volume, amplitude, and crossfade generally affect the playback volume of the entire region, beginning to end. \"Generally\" because amplitude and volume can be modulated by CCs while the sample is playing. Volume is additive and measured in decibels, so volume=6 adds 6 dB to the sample's playback volume. Amplitude is multiplicative, and is a percentage of full amplitude, so amplitude=6 would mean the sample is played at 6% amplitude. Xfin and xfout are intended for cross-fading dynamic layers, and set the CC values for zero amplitude and full amplitude. One limitation here is that it's not possible to have a layer which has more than zero amplitude at the start of the fade-in. This is important for instruments such as bowed strings, which have a certain minimum practical playable loudness. These will often have dynamics linked to CC1 or some other CC, and need to have some small amount of audible volume even at the lowest CC level. Here, amplitude with curveccN can be used to fade in the lowest layer. It's still possible to use xfout to fade the layer out at higher CC values as the next layer fades in, though it may be simpler to just use amplitude for all layers, for example like this: <global> amp_veltrack=0 <group> amplitude_oncc1=100 amplitude_curvecc1=11 #include \"quiet_layer.sfz\" <group> amplitude_oncc1=100 amplitude_curvecc1=12 #include \"loud_layer.sfz\" <curve> curve_index=11 v000=0.4 v063=1 v127=0 <curve> curve_index=12 v000=0 v063=0 v127=1","title":"Volume, amplitude and crossfade"},{"location":"tutorials/volume/#envelopes-and-lfos","text":"Both the ampeg envelope and one or more egN flex envelopes can be used in parallel. The same is true of amplfo and lfoN flex LFOs. These affect the volume of the region differently across time, obviously.","title":"Envelopes and LFOs"},{"location":"tutorials/volume/#randomization","text":"amp_random and its alias gain_random work like volume/gain and are measured in decibels. In ARIA and Cakewalk, amp_random is unipolar. In the rgc sfz player, amp_random is bipolar. In ARIA, CC135 (unipolar random) and 136 (bipolar random) can also be used by various opcodes which modulate volume.","title":"Randomization"},{"location":"tutorials/volume/#stacking-mutliple-modulations","text":"It is possible to have multiple CCs modulating the same opcode for the same region. This can make sense with multiple mic positions, for example. There can be a release samples volume control affecting release sample amplitude for all mics, and individual mic controls with the amplitude for all samples recorded through that mic. The effect with amplitude would be multiplicative - so with either control at 0, there would be no sound. <master> amplitude_oncc80=100 //Close mic volume <group> #include \"close_notes.sfz\" <group> trigger=release amplitude_oncc82=100 //Release noise volume #include \"close_releases.sfz\" <master> amplitude_oncc81=100 //Far mic volume <group> #include \"far_notes.sfz\" <group> trigger=release amplitude_oncc82=100 //Release noise volume #include \"far_releases.sfz\"","title":"Stacking mutliple modulations"}]}